{"pages":[{"title":"about","text":"🤡 前言 金庸武侠新序里写到 “小说是写给人看的”。博客也是也给人看的，要求 纯粹、易懂，能够启迪与人是最好的。古人云：”达则兼济天下，穷则独善其身“，对我本人而言，能够使读者有些许收获算是意外之喜，只求不误人子弟，贻笑大方。本站名为求索，取自于屈原《离骚》中的 “路漫漫其修远兮，吾将上下而求索”。王国维在《人间词话》中写到 “古今之成大事业、大学问者，必经过三种之境界：‘昨夜西风凋碧树。独上高楼，望尽天涯路’。此第一境也。‘衣带渐宽终不悔，为伊消得人憔悴。’此第二境也。‘众里寻他千百度，蓦然回首，那人却在，灯火阑珊处’。此第三境也。” ，希望我能够践行之～～～ 👨‍💻 博主是谁一个未脱离低级趣味之人，一个努力求索之人。","link":"/about/index.html"}],"posts":[{"title":"about","text":"","link":"/2021/07/06/about/"},{"title":"find-majority-element-lcci","text":"数组中占比超过一半的元素称之为主要元素。给你一个 整数 数组，找出其中的主要元素。若没有，返回 -1 。请设计时间复杂度为 O(N) 、空间复杂度为 O(1) 的解决方案。 示例 1： 12输入：[1,2,5,9,5,9,5,5,5]输出：5 示例 2： 输入：[3,2]输出：-1 示例 3： 12输入：[2,2,1,1,1,2,2]输出：2 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-majority-element-lcci著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思想假设存在元素a的数量超过一半,则将所有不同的元素相互抵消，剩余的那一个肯定是a.如： 12[2,2,1,1,1,2,2]-&gt; [2] 当不存在这样的元素时，也可能最后剩余的元素不符合条件，这时候就需要统计剩余元素的个数，然后判断是否超过总数的一半即可。如： 12[1,2,3]-&gt; [3] Code123456789101112131415161718192021222324class Solution {public: int majorityElement(vector&lt;int&gt;&amp; nums) { int num = nums[0], count = 1, n = nums.size(); for(int i =1; i&lt;n; i++){ if(count == 0){ num = nums[i]; count = 1; }else{ if(nums[i] != num){ count --; }else count++; } } if(count == 0) return -1; else{ count = 0; for(int nu: nums){ if(nu == num) count++; } return count*2 &gt;= n ? num:-1; } }};","link":"/2021/07/09/find-majority-element-lcci/"},{"title":"group-anagrams-lcci [计数统计]","text":"编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。 注意：本题相对原题稍作修改 示例: 123456789输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],输出:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/group-anagrams-lcci著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解由于只有小写字母，只需要申请一个长度为26的数组统计每一个字符串的字母数量即可（类似于hashcode的构造思想）。这样所有的变位词可以映射到相同的数组，使用map，将数组（或者转为字符串）作为key，value 即是对应的字符数组。 Code12345678910111213141516171819202122232425262728293031class Solution {public: string hashcode(vector&lt;int&gt; chs){ string ans = &quot;&quot;; for(int ch: chs){ ans.append(to_string(ch) + &quot;_&quot;); } return ans; } vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) { // hash 编码 // eat tea tan ate nat bat unordered_map&lt;string,vector&lt;string&gt;&gt; containers; for(string str: strs){ vector&lt;int&gt; counts(26,0); for(char c: str){ counts[c-'a'] ++; } containers[hashcode(counts)].emplace_back(str); } vector&lt;vector&lt;string&gt;&gt; res; for(auto &amp;p: containers){ res.push_back(p.second); } return res; }};","link":"/2021/07/18/group-anagrams-lcci/"},{"title":"minimize-maximum-pair-sum-in-array","text":"一个数对 (a,b) 的 数对和 等于 a + b 。最大数对和 是一个数对数组中最大的 数对和 。 比方说，如果我们有数对 (1,5) ，(2,3) 和 (4,4)，最大数对和 为 max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8 。给你一个长度为 偶数 n 的数组 nums ，请你将 nums 中的元素分成 n / 2 个数对，使得： nums 中每个元素 恰好 在 一个 数对中，且最大数对和 的值 最小 。请你在最优数对划分的方案下，返回最小的 最大数对和 。 示例 1： 12345输入：nums = [3,5,2,3]输出：7解释：数组中的元素可以分为数对 (3,3) 和 (5,2) 。最大数对和为 max(3+3, 5+2) = max(6, 7) = 7 。 示例 2： 12345输入：nums = [3,5,4,2,4,6]输出：8解释：数组中的元素可以分为数对 (3,5)，(4,4) 和 (6,2) 。最大数对和为 max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8 。 提示： n == nums.length2 &lt;= n &lt;= 105n 是 偶数 。1 &lt;= nums[i] &lt;= 105 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 Solution贪心算法，假设序列 [a1,a2,a3,a4,a5,a6],且 a1 &lt;= a2 &lt;= a3 &lt;= .. &lt;= a6, 则必有最小的 最大数对和只能是(a1,a6),(a2,a5),(a3,a4)数对之和的最大值。 证明简单证明一下，假设存在四个数 a &lt; b &lt; c &lt; d, 则符合条件的数为 max(a+d,b+c)。反证法: 若 d 不与 a搭配,与其它任意搭配，都存在结果为 d + ?. Code12345678910111213class Solution {public: int minPairSum(vector&lt;int&gt;&amp; nums) { sort(nums.begin(),nums.end()); int ans = 0, n = nums.size() - 1, i = 0; while(i &lt; n){ ans = max(ans,nums[i]+nums[n]); i++; n--; } return ans; }};","link":"/2021/07/20/minimize-maximum-pair-sum-in-array/"},{"title":"template","text":"常见的一些latex、hexo bug 或者其它的使用说明书. 1. latexlatex syntax 1.1 行内样式 inline synatx$\\hat{x}_{k}=\\hat{x}_{k}^{-}+K_{t}\\left(y_{k}\\right)$ 1.2 equation \\begin{align} & \\arg\\min_{w,b} \\frac{1}{2m}\\sum_{i=1}^m (\\hat{y_i} - y_i)^2 \\\\ & s.t \\quad \\hat{y_i}(w^x_i + b) >= 0\\\\ \\end{align} 1.3 矩阵 $$\\begin{bmatrix} {a_{11}}&{a_{12}}&{\\cdots}&{a_{1n}}\\\\ {a_{21}}&{a_{22}}&{\\cdots}&{a_{2n}}\\\\ {\\vdots}&{\\vdots}&{\\ddots}&{\\vdots}\\\\ {a_{m1}}&{a_{m2}}&{\\cdots}&{a_{mn}}\\\\ \\end{bmatrix}$$ 1.4 分母$$P(A_i \\mid B) = \\frac{P(B\\mid A)P(A_i)}{\\sum_{j=1}^{n}P(A_j)P(B \\mid A_j)}$$ 1.5 常见的希腊字符 希腊字符 latex 大写 latex｜ $\\alpha$ \\alpha $\\lambda$ \\lambda $\\Lambda$ \\Lambda $\\delta$ \\delta $\\Delta$ \\Delta $\\beta$ \\beta $\\sigma$ \\sigma $\\Sigma$ \\Sigma $\\theta$ \\theta $\\Theta$ \\Theta $\\epsilon$ \\epsilon To be continue","link":"/2021/07/06/template/"},{"title":"time-based-key-value-store","text":"创建一个基于时间的键值存储类 TimeMap，它支持下面两个操作： set(string key, string value, int timestamp) 存储键 key、值 value，以及给定的时间戳 timestamp。 get(string key, int timestamp) 返回先前调用 set(key, value, timestamp_prev) 所存储的值，其中 timestamp_prev &lt;= timestamp。如果有多个这样的值，则返回对应最大的 timestamp_prev 的那个值。如果没有值，则返回空字符串（””）。 示例 1：12345678910输入：inputs = [&quot;TimeMap&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;], inputs = [[],[&quot;foo&quot;,&quot;bar&quot;,1],[&quot;foo&quot;,1],[&quot;foo&quot;,3],[&quot;foo&quot;,&quot;bar2&quot;,4],[&quot;foo&quot;,4],[&quot;foo&quot;,5]]输出：[null,null,&quot;bar&quot;,&quot;bar&quot;,null,&quot;bar2&quot;,&quot;bar2&quot;]解释： TimeMap kv; kv.set(&quot;foo&quot;, &quot;bar&quot;, 1); // 存储键 &quot;foo&quot; 和值 &quot;bar&quot; 以及时间戳 timestamp = 1 kv.get(&quot;foo&quot;, 1); // 输出 &quot;bar&quot; kv.get(&quot;foo&quot;, 3); // 输出 &quot;bar&quot; 因为在时间戳 3 和时间戳 2 处没有对应 &quot;foo&quot; 的值，所以唯一的值位于时间戳 1 处（即 &quot;bar&quot;） kv.set(&quot;foo&quot;, &quot;bar2&quot;, 4); kv.get(&quot;foo&quot;, 4); // 输出 &quot;bar2&quot; kv.get(&quot;foo&quot;, 5); // 输出 &quot;bar2&quot; 示例 2：12输入：inputs = [&quot;TimeMap&quot;,&quot;set&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;,&quot;get&quot;,&quot;get&quot;,&quot;get&quot;], inputs = [[],[&quot;love&quot;,&quot;high&quot;,10],[&quot;love&quot;,&quot;low&quot;,20],[&quot;love&quot;,5],[&quot;love&quot;,10],[&quot;love&quot;,15],[&quot;love&quot;,20],[&quot;love&quot;,25]]输出：[null,null,null,&quot;&quot;,&quot;high&quot;,&quot;high&quot;,&quot;low&quot;,&quot;low&quot;] 提示： 所有的键/值字符串都是小写的。 所有的键/值字符串长度都在 [1, 100] 范围内。 所有 TimeMap.set 操作中的时间戳 timestamps 都是严格递增的。 1 &lt;= timestamp &lt;= 10^7 TimeMap.set 和 TimeMap.get 函数在每个测试用例中将（组合）调用总计 120000 次。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/time-based-key-value-store著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 Code123456789101112131415161718192021222324252627282930313233class TimeMap {public: using P = pair&lt;int,string&gt;; unordered_map&lt;string,vector&lt;P&gt;&gt; container; /** Initialize your data structure here. */ TimeMap() { // unordered_map&lt;string,priority_queue&lt;Point&gt;&gt; container; } void set(string key, string value, int timestamp) { container[key].emplace_back(P(timestamp,value)); } string get(string key, int timestamp) { auto &amp;pairs = container[key]; auto it = upper_bound(pairs.begin(),pairs.end(),P(timestamp,string({127}))); if(it != pairs.begin()){ return (it -1)-&gt;second; } return &quot;&quot;; }};/** * Your TimeMap object will be instantiated and called as such: * TimeMap* obj = new TimeMap(); * obj-&gt;set(key,value,timestamp); * string param_2 = obj-&gt;get(key,timestamp); */ More Info1. Pair&lt;int,string&gt;2. Vector&lt;Pair&lt;int,string&gt;&gt;","link":"/2021/07/10/time-based-key-value-store/"},{"title":"applications_of_parallel_computers","text":"cs267 是cmu的一门关于并行算法的公开课下面是它的一个详细的课程表 CS267 Master Schedule Sp21 并行算法","link":"/2021/09/03/applications-of-parallel-computers/"},{"title":"感知机","text":"感知机(Perceptron), 是一种二分类的线性分类器。 其输入是一个待分类的实例，输出为该实例对应的类型。 根据模型、策略和算法三部曲，来说： 1. 模型由于是一个分类器，其函数模型为： $$ {\\begin{aligned} &z = w^Tx + b \\\\ &f(x) = sign(z) = \\begin{cases} 1, & \\text{if z > 0} \\\\ -1, & \\text{if z < 0} \\end{cases} \\end{aligned}} $$ 2. 策略分类问题的误差函数，可以采用误分类个数之和 $$Loss(w,b) = \\sum_i I(y_i,f(x_i)) \\\\ I(y_i,f(x_i)) = \\begin{cases} 1, &\\text{if $y_i\\neq f(x_i)$ } \\\\ 0, &\\text{if $y_i = f(x_i)$} \\\\ \\end{cases}$$ 但是，该函数无法使用梯度下降法来进行求解。可以考虑一下，每个点到该分类器超平点的距离。 2.1 损失函数假设存在一个超平面 S: $w^Tx + b = 0$ ，将特征划分为正、负两个超平面。超平面 S，其中 w是法向量，b为截距，如下图绿线 此时，我们采用误分类点到超平面的距离之和来作为损失函数。向量空间的任意一点 x 到超平面S的距离为 $ dis = \\frac{1}{||w||}|w^Tx_i + b| \\\\$ 由于， 对于误分类的点有： $$ \\begin{cases} w^Tx + b < 0,&\\text{if $y = 1$} \\\\ w^Tx + b > 0,&\\text{if $y = -1$} \\\\ \\end{cases} \\\\ -y(w^Tx + b) > 0 , x\\subset M \\\\ $$ 因此损失函数为： $L(w,b) = \\sum_i^M -y_i(w^Tx_i + b) \\qquad (3) \\\\$ > 这里省略掉了 ||w|| 或者说是加了约束条件 ||w|| = 1, 思考为什么可以？ > 答案见附录 B-1 明显是一个无约束的线性优化问题，转化为优化问题为： $\\arg\\min_{w,b} L(w,b) \\\\ s.t \\rightarrow x\\in M \\qquad (4)$ M 是所有误分类的集合，即： $$ M = {x| y(w^Tx + b )","link":"/2021/03/28/%E6%84%9F%E7%9F%A5%E6%9C%BA/"},{"title":"朴素贝叶斯","text":"朴素贝叶斯（naive bayes）是基于贝叶斯理论的分类器，它以变量的各个特征之间相互独立为前提，利用条件概率来最大化后验概率或者最小化期望风险，来实现判别其类别。 1. 基础理论根据条件概率或者贝叶斯理论有： $$P(Y = c_k/ X = x) = \\frac{P(Y = c_k, X = x)}{P(X = x)} = \\frac{ P(X = x/ Y = c_k)P(Y = c_k)}{\\sum_k^K P(X = x/ Y = c_k)P(Y = c_k) } \\$$ 其中 Y 为类别集合 {${c_1,c_2,…c_k}$};X 为输入空间的 n 维向量集合 {${x_i,x_2,…x_n}$} 。 目标为对于给定的一个输入向量，通过模型能够获取其类别（这里取给定x情况下，取概率最大的类别作为最终类别），即 $$Given,x \\in X \\y = f(x) = \\arg\\max_{ck}P(Y = c_k/X = x), k =1,2,3…K$$求解概率 $P(Y = c_k/X = x)$，可以有贝叶斯理论可知，先求解$P(Y = c_k, X = x), P(X = x)$。 1.1 求解$P(Y = c_k,X = x)$这里假设了，对于变量$$x = [x^{(1)},…,x^{(m)}]$$的不同特征之间相互独立，因此: $$\\begin{aligned}P(Y=c_k,X=x) &amp;= P(Y=c_k,X^{(1)} \\ &amp;= x^{(1)},…,X^{(m)} = x^{(m)} ) \\ &amp;= \\prod_{i}^m P(Y=c_k,X^{(i)} = x^{(i)}) \\ &amp;= P(Y = c_k) \\prod_{i}^m P(X^{(i)}= x^{(i)}/ Y = c_k )\\end{aligned}$$ 1.2 求解 $P(X = x)$有贝叶斯可知：$$\\begin{aligned}P(X = x) &amp;= \\sum_k^K P(X = x/ Y = c_k)P(Y = c_k) \\&amp;= \\sum_k^K P(Y=c_k) \\prod_i^m P(X^{(i)} = x^{(i)}/ Y = c_k )\\end{aligned}$$ 但是 $P(Y = c_k ) , , P(X^{(i)} = x^{(i)}/ Y = c_k )$ 如何确定呢？ 2. 最大化后验概率或者最小化期望风险后验概率最大化即：$\\max P(Y=c_k/X=x)$ 假设误差损失函数：$$\\begin{aligned}L(Y, f(X)) = \\begin{cases} 0 &amp;, Y = f(X) \\ 1 &amp;, Y \\neq f(X)\\\\end{cases}\\end{aligned}$$则模型目标为最小化期望风险即： $$\\begin{aligned}R_{exp}(f) &amp;= E[L(Y,f(X)]\\&amp;= E_X\\sum_k^KP(c_k/X) L(c_k,f(X)) \\&amp;= E_X\\sum_k^{K}L(y,c_k)P(c_k/X=x) \\&amp;= E_X\\sum_k^{K}P(y \\neq c_k/X=x) \\qquad (1)\\end{aligned}$$ 最小化式子(1)，只需要对 X=x 逐个最小化即可。 $$\\begin{aligned}f(x) &amp;= \\arg\\min P(y\\neq c_k/X=x) \\&amp;= \\arg\\min (1 - P(y = c_k/X= x)) \\&amp;= \\arg \\max P(y=c_k/X=x)\\end{aligned}$$ 因此，两者是等价的 3. 贝叶斯的参数估计前面提到问题：但是 $P(Y = c_k ) , , P(X^{(i)} = x^{(i)}/ Y = c_k )$ 如何确定呢？对于离散变量，一个直观的概念是使用其统计学方法来近似估计概率。对于连续变量，采用一个概率分布拟合其变量分布，如高斯分布 3.1 离散型变量估计令 $\\theta = P(Y = c_k)$ 参与极大似然概率来估计 $\\theta$, 设变量个数为n,其中类别为$c_k$的有t个，则有： $$\\begin{aligned}&amp;L(\\theta) = (\\theta)^{t}(1 - \\theta)^{(n-t)} \\&amp;LnL(\\theta) = tLn(\\theta) + (n-t)Ln(1-\\theta) \\&amp;\\frac{dLnL(\\theta)}{d\\theta} = \\frac{t}{\\theta} + \\frac{-(n-t)}{1 - \\theta} = 0 \\&amp;\\hat\\theta = \\frac{t}{n}\\end{aligned}$$即： $P(Y=c_k) = \\frac{t}{n}$同理可知：$P(X^{(i)} = x^{(i)}/ Y = c_k ) = \\frac{t_{ni}}{n_k}$, 其中 $n_k$ 为类别为 $c_k$的数量，$t_{ni}$为在类别为$c_k$的数据中，$X^{(i)} = x^{(i)}$的数量由于，对于任意类别 $P(X = x)$ 的值是相同的，因此可以省略… 3.2 连续性变量估计如果X的各个特征是连续的，这是可以采用某种具体的分布函数来拟合X各个特征的分布，比如采用 Normal Distribution 等等。通常在确定分布函数类型之前，先对数据进行可视化处理，观察其数字特征等，在确定采用哪种分布函数来拟合。 以高斯分布为例，此时 $X_i \\sim (\\mu\\sigma)$： $$\\begin{aligned}&amp;\\mu_i = Ex_i = \\bar{x} \\&amp;\\sigma_i^2 = E((X_i-\\mu_i)^2)\\end{aligned}$$ 这里其实要使用最大似然来估计一下变量 $\\mu$和 $\\sigma$ $$L(\\mu,\\sigma) = \\prod_i^mf(x_i)\\LnL = \\sum_i^m\\ln{f(x_i)}$$对上式分别对 $\\mu$和 $\\sigma$求偏导数，并令其为0即可 更简化，由于变量的各个维度都是独立的，因此可以联合分布为各个分布函数的乘积，如果都是符合高斯分布，即有： $$\\begin{aligned}f(x_1,x_2…x_m) &amp;= \\prod_i^mf(x_i) \\&amp;= \\prod_i^m \\frac{1}{(2\\pi\\sigma_i^2)^{1/2}} \\exp{\\frac{-(x_i - \\mu_i)^2}{2\\sigma_i^2}} \\&amp;= \\frac{1}{(2\\pi)^m||\\Sigma||}^{1/2} \\exp{-\\frac{1}{2}(X - \\mu)^T\\Sigma^{-1}(X - \\mu)} \\\\end{aligned}$$ 只需要计算 X 的方差和均值即可。 另外，如果 X 得来源于一个公共得资源，可以假设各个特征得方差均相同 if we have reason to believe that noise in the observed _Xi _comes from a common source, then we might further assume that all of the σ_ik _are identical, regardless of the attribute _i _or class _k _(see the homework exercise on this issue). 贝叶斯模型存在的问题 无偏差的贝叶斯模型是不现实的？ 思考一下，如果变量的特征一个离散型的，一个是连续性的，如何设计和求解模型呢？逻辑回归模型 2. 从朴素贝叶斯到逻辑回归首先在了解逻辑回归模型的之前，我们以二分类为例，使用朴素贝叶斯的方法来判别分类。 $$\\begin{aligned}P(Y = c_1/X = x) &amp;= \\frac{P(Y = c_1)P(X =x/ Y =c_1)}{P(X = x)} \\&amp;=\\frac{P(Y = c_1) P(X =x/Y=c_1)}{\\sum_i^2 P(Y = c_1) P(X =x/Y=c_1)} \\&amp;=\\frac{1}{1 + \\frac{P(Y=c_2)P(X =x/Y=c_2)}{P(Y =c_1)P(X =x/Y=c_1)}} , (3) \\\\end{aligned}$$ 由于 $P(X = x/ Y= c_1 ) = f(x) = \\frac{1}{(2\\pi)^m||\\Sigma||}^{1/2} \\exp{-\\frac{1}{2}(x - \\mu)^T\\Sigma^{-1}(x - \\mu)}$ 带入到式（3） 中，可得： $P(Y=c_1/X= x) = \\frac{1}{1 + \\exp(-z)} = \\sigma(z)$ 这就是 Sigmoid Function $z = ln(\\frac{P(c1)P(x/c1)}{P(c2)P(x/c2)}) = ln\\frac{P(c1)}{P(c2)} + ln\\frac{P(x/c1)}{P(x/c2)}$ 其中 $P(Y=c_k) = \\frac{t}{n}$，可知 $ln\\frac{P(c1)}{P(c2)}$ 是常数 这里假设 $\\Sigma_1 = \\Sigma_2 = \\Sigma$ $$ln\\frac{P(x/c1)}{P(x/c2)} = \\frac{1}{2}(x-\\mu_1)^T\\Sigma^{-1}(x-\\mu_1) - \\frac{1}{2}(x-\\mu_2)^T\\Sigma^{-1}(x-\\mu_2) \\= (\\mu_1-\\mu_2)^T\\Sigma^{-1}x - \\frac{1}{2}( \\mu_1^T\\Sigma^{-1}\\mu_1 - \\mu_2^T\\Sigma^{-1}\\mu_2 )$$ 令 $b = ln\\frac{P(c1)}{P(c2)} + - \\frac{1}{2}( \\mu_1^T\\Sigma^{-1}\\mu_1 - \\mu_2^T\\Sigma^{-1}\\mu_2 )$, $w^T = (\\mu_1-\\mu_2)^T\\Sigma^{-1}$ 则有 $z = w^Tx + b$ 这里其实是有一个差异，因为 w 和 b 之间是有某种依赖关系的，但是如果只看作是 w 和 b变量，则w和b之间相互独立，这样子大大减少了训练的参数，这也就是逻辑回归。 3. 从回归模型到逻辑回归 还是以二分类为例 回归模型为 $y(x) = W^Tx + b$ ， 这里我们想要找到一种模型使：$P_{w,b}(c/x)$ $$\\begin{cases} output , c1 ,, P_{w,b}(c/x) &gt;= 0.5 \\ otherwise ,, output ,c2\\end{cases}$$ 这里我们考虑是有 sigmoid funcion $\\sigma(z) = \\frac{1}{1 + \\exp{(-z)}}$其取值范围为 (0 , 1 )，自变量取值为$( -\\infty，+\\infty)$, $z = w^Tx + b$其图形如下： 其实就是使用 sigmoid function 来替代 p(y/x)的概率，因此这种模型与前文看到模型不同。前文（贝叶斯）是使用间接计算，即由 P(y) 和 P(x/y) 来间接求的 p(y/c)的概率，这种模型叫做生成模型（Generative model）。而逻辑回归，是直接采用一个函数来模拟 p(y/x)的分布，成为判别模型(discriminative model) 3.1 策略逻辑回归的损失函数可以分为两种，一种为 maximum likelihood estimation ，另外一种为 the least squares , 一般采用最大似然概率。 想一下为什么？ 其损失函数为：假设 $z_1,z_2 … z_m 为 c_1, z_{m+1}… z_n 为 c_2$则$$L(w,b) = \\prod_i^{m} \\sigma(z_i) \\prod_{i = m+1}^n (1- \\sigma(z_i))\\\\ln{L} = \\sum_i^m \\ln{(\\sigma(z_i))} + \\sum_{m+1}^{n} \\ln{(\\sigma(z_i))} \\= E_{x\\sim c_1} \\ln{\\sigma(z)} + E_{x\\sim c_2} \\ln{\\sigma(z)}\\= \\sum_i^n\\hat{y_i}\\ln{\\sigma(z_i)} + (1 - \\hat{y_i} )ln{(1 - \\sigma(z_i))}$$ 对于每一个给定的x, 使 $f = \\sigma(z_i)ln{\\sigma(z_i)} + (1 - \\sigma(z_i) )ln{(1 - \\sigma(z_i))}$ 最大。这里直接对w,b 求偏导数，使用随机梯度下降法即可。 $$\\frac{df}{dw} = \\frac{df}{dz} \\frac{dz}{dw} \\ \\frac{d\\sigma}{dz} = \\frac{\\exp{(-z)}}{(1 + \\exp{(-z)})^2} = \\sigma(1 - \\sigma) \\\\frac{dz}{dw} = x\\\\frac{df}{dw} = (y(1-\\sigma) - (1-y)\\sigma)x = (y - \\sigma)x \\\\frac{df}{db} = (y(1-\\sigma) - (1-y)\\sigma)x = y - \\sigma$$ 4. 思考一下 朴素贝叶斯法和逻辑回归做分类问题的时候，有什么区别？各自有什么优势？ 逻辑回归的损失函数使用 cross entropy 和 square error 用什么优劣？ 参考 《统计学习方法》 李航， chapter 4 Machine Learning , Tom M. Mitchell , chapter 3 Classification 李宏毅","link":"/2020/09/22/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%92%8C%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"},{"title":"多层感知机与BP算法","text":"前面讲解 感知机 , 说明其有一个很大的不足之处，即它无法求解非线性问题或者异或问题。后面就发展出了多层感知机（deep feebforward network or multilayer perceptron），以及求解使用的BP算法。这也是深度学习的基础。 http://speech.ee.ntu.edu.tw/~tlkagk/courses/ML_2016/Lecture/DL%20(v2).pdf 1. 多层感知机 1.1 Neuron我们将逻辑回归抽象成一个neural network的一个“Neuron”，而多层感知机即是将这些神经元连接在一起。对于深度学习网络来说，它也是有一个个神经元组成，但是它可以有各个不同的网络结构（网络堆叠）。 1.2 Multilayer Perceptron多层感知机,其中一个小白色长方形（f）为一个一个”Neuron”，每一层可以有多个 Neruon, 而多层感知机可以有很多层。其中灰色部分为隐含层（Hidden Layer），绿色为输入层(Input Layer),黄色部分为输出层 (Output Layer) 。蓝色线可以看作是一个权重（w), 而 f 代表激活函数（activate function）。 目前激活函数有很多种，常用的有 Sigmoid、Relu 、Tanh、Leaky Relu、Softmax 等。 多层感知机是一种监督模型，它可以解决分类和回归问题（输出层的结构有所不同）。一般在解决分类问题时，它会在输出层前增加一层 softmax 处理，来模拟各个分类的概率。下面一分类问题为例子，来了解它的整个运作过程。 1.2.1 数据流动 数据是如何在感知机内流动的？ 本质上，多层感知机是一个个矩阵的乘法运算，它的数据流是从前向后流动的，即 Feedforward 如，输入为 $x = [x_1, x_2,…,x_m]$, 其中$x \\in R^n$, 即单个x存在m个特征。对于隐含层第元素有： $w_{ji}^L$代表第L层的j个z值与第L-1层的第i个输入之间的权重 $b_j^L$代表第L层的偏移量 $a_i^L$代表第L层输出的第i的元素，同时是第L+1的输入的第i个元素 f为激活函数 $z_{j}^L = \\sum_i w_{ji}^La_i^{L-1} + b_j^L$ $a_j^L = \\sigma(z_j^L)$ 对于输入层有： $a_i^0 = x_i$ 对于输出层有（这里不考虑softmax）： $y_i = a_i^L$ 数据流通为： $$ \\begin{aligned} z^L &= \\begin{bmatrix} w_{00}^L & w_{01}^L& ... &w_{0i}^L\\\\ w_{10}^L & w_{11}^L& ... &w_{1i}^L\\\\ ... & ...& ... & ...\\\\ w_{j0}^L & w_{j1}^L& ... &w_{ji}^L\\\\ \\end{bmatrix} \\begin{bmatrix} a_0^{L-1}\\\\ a_1^{L-1}\\\\ ...\\\\ a_i^{L-1}\\\\ \\end{bmatrix} + \\begin{bmatrix} b_0^{L}\\\\ b_1^{L}\\\\ ...\\\\ b_j^{L}\\\\ \\end{bmatrix} \\\\ & = w^La^{L-1} + b^L \\\\ a^L &= f(z^L) = f(w^L a^{L-1} + b^L ) \\end{aligned}\\tag{2} $$ 其中 $w^L$ 为 jxi 得 matrix, j为第L层的输出Dimensions，i为第``L层的输入的Dimensions。根据公式1, 2,可以推出输出为: $$ \\begin{aligned} y &= a^L \\\\ &= f(w^La^{L-1} + b^L ) = f(w^Lf(w^{L-1}a^{L-2}+ b^{L-1})+ b^L ) \\\\ &= ... \\\\ &= f(w^Lf(w^{L-1}f(...f(...f(w^1a^0 + b^0) + b^{l} ) + b^{L-1}) + b^L ) \\\\ \\end{aligned}\\tag{3} $$ 1.2.2 损失函数由于多层感知机可以处理分类和回归问题，所有其损失函数也分为两类，下面以分类问题为例。可以看作是多分类问题，这是可以采取最大似然概率来作为其损失函数（交叉熵）。做分类问题时，需要在输出层之前增加一个 softmax 层。 Tips 这里看出多层感知机其实是一个 discriminative model 。 假设共有m个类别 $(c_1,…c_m)$，$\\theta$ 为所有的参数，则 Loss Function 为： $$ \\begin{aligned} L(\\theta) &= \\sum_i^m {\\sum_{x^j\\in c_i}\\ln(y_i^j) + \\sum_{x^j\\notin c_i}\\ln(1 - y_i^j) } \\\\ & = \\sum_i^m { E_{x^j\\sim c_i} \\ln{y_i^j} + E_{x^j\\sim \\bar{c_i}} \\ln{(1 - y_i^j) }} \\\\ &= \\sum_i^m\\sum_j^{n_{c_i}} \\{\\hat{y}_{i}^j\\ln{y_i^j} + (1- \\hat{y}_{i}^j) \\ln{(1 - y_i^j)} \\} \\\\ &= \\sum_i^n \\sum_j^m \\hat{y}_j\\ln{y_j} + (1-\\hat{y}_j )\\ln{(1 - y_j)} \\end{aligned} \\tag{4} $$ 或者使用 $$ \\begin{aligned} L(\\theta) &= \\sum_i^m {\\sum_{x^j \\in c_i}\\ln(y_i^j)} \\\\ & = \\sum_i^m {E_{x^j\\sim c_i} \\ln{y_i^j} } \\\\ &= \\sum_i^m\\sum_j^{n_{c_i}} \\hat{y}_{i}^j \\ln{y_i^j} \\\\ &= \\sum_i^n \\sum_j^m \\hat{y}_j\\ln{y_j} \\end{aligned} \\tag{5} $$ 其中 $\\hat{y} = \\begin{bmatrix} 0,0,.,1,.,0 \\end{bmatrix}^T$ ,one-shot vector 的样式 Tips: 如果是回归模型的话，无需添加 softmax 层，而且可以使用 mean square errors 作为损失函数 Thinking 式4和式5在使用过程中，有什么区别呢？那个效果更好呢？ 了解了损失函数之后，那么如何来寻找损失函数的极大值呢？或者是如何解决这个优化问题呢？这里就引出了BackPropagation, 即BP算法 2. BP算法由式子（5） 可知, 使用SGD来解该优化问题，在给定x的情况下, 令 c 为损失函数。首先对隐含层某个参数求偏导数，如 $w_{ji}^L$ $$\\frac{dc}{dw_{ji}^L} = \\frac{dc}{da_j^L}\\frac{da_j^L}{dw_{ji}^L} \\tag{6}$$ 其中 $\\frac{da_j^L}{dw_{ji}^L}$ $$\\frac{da_j^L}{dw_{ji}^L} = \\frac{da_j^L}{dz_j^L}\\frac{dz_j^L}{dw_{ji}^L} = f’(z_j^L)\\frac{dz_j^L}{dw_{ji}^L} = f’(z_j^L)a_i^{L-1} \\tag{7}$$ 其中$\\frac{dc}{da_j^L}$ $$\\begin{aligned}\\delta_j^L &amp;= \\frac{dc}{da_j^L} \\&amp;= \\sum_k^K \\frac{dc}{dz_k^{L+1}}\\frac{dz_k^{L+1}}{da_j^L}\\&amp; = \\sum_k^K\\frac{dc}{dz_k^{L+1}}w_{kj}^{L+1} \\&amp;= \\sum_k^K\\frac{dc}{da_k^{L+1}}\\frac{da_k^{L+1}}{dz_k^{L+1}}w_{kj}^{L+1} \\&amp;= \\sum_k^K \\delta_k^{L+1}f’(z_k^{L+1})w_{kj}^{L+1}\\end{aligned}\\tag{8}$$ 令 $\\delta^L = \\begin{bmatrix} \\delta_1^L, …, \\delta_J^L \\end{bmatrix}^T$, $\\sigma ^L = \\begin{bmatrix} f’(z_1^L), …, f’(z_J^L) \\end{bmatrix}^T$, $w^L = \\begin{bmatrix} w_1^L,…,w_J^L\\end{bmatrix}$ 则 $$\\begin{aligned}\\delta_j^L &amp;= \\sum_k^K \\delta_k^{L+1}f’(z_k^{L+1})w_{kj}^{L+1} \\&amp;= \\langle{(\\delta^{L+1} \\odot \\sigma^L),w_j^{L+1}} \\rangle\\end{aligned} \\tag{9}$$ 由于$\\delta^L = \\begin{bmatrix} \\delta_1^L, …, \\delta_J^L \\end{bmatrix}^T$, 故： $$\\delta^L =\\begin{bmatrix} \\delta_1^L, …, \\delta_J^L \\end{bmatrix}^T = (w^{L+1})^T (\\delta^{L+1} \\odot \\sigma^L) \\tag{10}$$ 因此找到了$\\delta^L$和$\\delta^{L+1}$ 之间的关系，一旦得到了$\\delta^{L+1}$就可以求出$\\delta^L$。令 $\\frac{dc}{dw_j^L} =\\begin{bmatrix}\\frac{dc}{dw_{j1}^L},…,\\frac{dc}{dw_{jI}^L}\\end{bmatrix}^T$又因为：$\\frac{dc}{dw_{ji}^L} = f’(z_j^L)a_i^{L-1}\\delta_j^L$故有 $$\\frac{dc}{dw_{j}^L} = \\sigma^L \\odot a^{L-1} \\odot \\delta^L \\tag{11}$$在输出层有：$\\frac{dc}{dy}$， 这个要根据具体的损失函数来确定 $\\frac{dy_i}{da_i^L}$ 这个如果没有 softmax 层或者说是回归问题的话，值因为1 Tips 如果是softmax的话，应该怎么做？ 因此，对最后一个隐含层的输出有 $$\\begin{aligned} \\delta &amp;= \\frac{dc}{da} = \\frac{dc}{dy}\\frac{dy}{da}\\end{aligned} \\tag{12}$$ 然后一次向前求解，即可求出对所有参数的倒数。 对 $b_j^L$求导数时： $\\frac{dc}{db_{j}^L} = \\frac{dc}{da_j^L}\\frac{da_j^L}{db_j^L} = \\delta_j^Lf’(z_j^L) \\\\frac{da_j^L}{db_{j}^L} = \\frac{da_j^L}{dz_j^L}\\frac{dz_j^L}{db_{j}^L} = f’(z_j^L)$因此 $$\\frac{dc}{db^L} = \\delta^L \\odot \\sigma^L$$","link":"/2020/09/23/%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA%E4%B8%8EBP%E7%AE%97%E6%B3%95/"},{"title":"线性回归","text":"1. 线性回归模型给定数据集 $D = { (x_1,y_1),(x_2,y_2) …,(x_n,y_n)}$, 其中 $x_i = (x_i^1, x_i^2, … x_i^m)$。 线性回归是试图使用一个线性模型来尽可能的预测实际数值的输出标记。 假设，使用函数: $$ \\begin{aligned} y = w^Tx + b \\\\ w = \\begin{bmatrix} w^1 \\\\ ...\\\\ w^m \\end{bmatrix} \\end{aligned} $$ b 是一个 scalar 。使用均方误差作为回归模型的性能度量，则可以转化为一个无约束的优化问题： $\\min_{w,b} L(w,b) = \\frac{1}{2n}\\sum_i^n(y_i - \\hat{y}_i)^2$ 解决这个优化问题，可以求导并令其偏导数为0，即可。下面是分别对 w , b 求导的结果 $$\\begin{aligned} \\frac{dL}{dw} &amp;= \\frac{1}{2n}\\sum_i^n 2(y_i-\\hat{y}_i)\\frac{dy_i}{dw} \\&amp;= \\frac{1}{n}\\sum_i^n(y_i-\\hat{y}_i)x_i \\qquad (1)\\\\frac{dL}{db} &amp;= \\frac{1}{n}\\sum_i^n(y_i - \\hat{y}_i) \\qquad (2)\\end{aligned}$$ 通常会把(1),(2) 式写成矩阵的形式，即: $$\\begin{aligned}\\frac{dL}{dw}&amp;= \\frac{1}{n}X^T(Xw - \\hat{Y}) \\qquad (3) \\\\frac{dL}{db}&amp;= \\frac{1}{n}I(Xw -\\hat{Y}) \\qquad (4) \\\\end{aligned}$$ 其中 $X=\\begin{bmatrix}x_1 \\ x_2 \\ … \\ x_n \\end{bmatrix}$, $\\hat{Y}=\\begin{bmatrix}\\hat{y}_1 \\ \\hat{y}_2 \\ … \\ \\hat{y}_n\\end{bmatrix}$, $I=\\begin{bmatrix}1,1 … 1\\end{bmatrix}$ 令式（3）等于0， 可以得到 $w^{\\star} = (X^TX)^{-1}X^T\\hat{Y}$, 此时 $A = X^TX$ 必须是非奇异矩阵。但是实际情况下，可能存在A并不是满秩的，比如特征的维度大于样本数。 因此，此时可能会接触多个w，能够使均方误差最小化。选择哪一个作为最优的w，由算法的归纳偏好来决定，比如引入正则化项。 2. 对数似然估计使用线性回归做分类问题，以二分类问题为例。 可以将其结果y映射到[0,1]区间，然后规定其值大于0.5作为正例，否则作为反例。 如何选择映射函数 f 呢，这里可以采用 sigmoid 函数：$$\\begin{aligned} f &amp;= \\sigma(z) = \\frac{1}{1 + \\exp{-z}} \\ z &amp;= w^Tx + b \\\\end{aligned}$$其曲线为：sigmoid 曲线此时，将f看作是概率分布，可以采用最大似然概率作为性能度量（它等价于最小化交叉熵）等价于优化问题： $$\\min_{w,b} L(w,b) = -\\sum_i^n(\\hat{y}_i\\log(f(x_i)) + (1-\\hat{y}_i)\\log(1 - f(x_i)))$$ 分别对 w,b求偏导数可得： $$ \\begin{aligned} \\frac{dL}{dw} &= -\\sum_i^n(\\frac{\\hat{y}_i}{f}\\frac{df}{dw} - \\frac{1-\\hat{y}_i}{1-f}\\frac{df}{dw}) \\\\ &= -\\sum_i^n(\\frac{\\hat{y}_i}{f}f(1-f)x_i - \\frac{1-\\hat{y}_i}{1-f}f(1-f)x_i )) \\\\ &= -\\sum_i^n(\\hat{y}_i - f)x_i \\qquad (5) \\\\ \\frac{dL}{db} &= -\\sum_i^n(\\hat{y}_i - f) \\qquad (6) \\end{aligned} $$ 分别对为w,b求偏导数其中$f = f(x_i)$。 可以发现与线性回归的偏导数有一样的格式。 3. LDA 线性判别分析LDA（Linear Discriminant Analysis), 又称为 fisher 判别分析 。它的主要思想是，将给定的样本，投影到一条直线上，并且保证类内的投影点越接近越好，但是类间的投影点越分散越好。类内投影点，越接近越好，可以采用方差（协方差举证）指标来衡量，即使其同类样本之间的协反差尽可能的小。对于类间的投影点，越分散越好。这里可以采用不同类别之间的均值相差尽可能的大。总结起来的公式为: $$\\max_{w} J(w) = \\frac{||w^T\\mu_0 - w^T\\mu_1||}{w^T\\Sigma_0w + w^T\\Sigma_1w}$$ LDA的度量函数w 代表被投影的直线。 令$S_w = \\Sigma_0 + \\Sigma_1$,$S_b = (\\mu_0 - \\mu_1)(\\mu_0 - \\mu_1)^T$则$J(w) = \\frac{w^TS_bw}{w^TS_ww}$。由于w代表被投影的直线，只与其方向有关，不妨设置$w^TS_ww = 1$, 则转化为以下有约束的优化问题 $$\\begin{aligned}&amp;\\min_{w}\\quad -w^TS_bw \\&amp;s.t \\quad w^TS_ww = 1\\end{aligned}$$ 可以使用拉格朗日乘法公式，可得: $$\\begin{aligned}L(w) &amp;= -w^TS_bw + \\lambda(w^TS_ww - 1) \\\\frac{dL}{dw} &amp;= -2S_bw + 2\\lambda S_ww = 0 \\&amp; S_w^{-1}S_bw = \\lambda w\\end{aligned}$$ 易知，$\\lambda$ 为矩阵 $S_w^{-1}S_w$的特征值和特征向量。 求解$S_w^{-1}$时，要考虑其稳定性，通常采用其SVD分解。即$S_w^{-1} = V\\Sigma^{-1}U^T$。","link":"/2020/12/26/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"},{"title":"拉格朗日乘法和KKT条件","text":"千秋摄于黄山 最近看了 《最优化理论与方法》, 学习了常见的优化问题以及解决方法。同时，之前学习 SVM 时，对拉格朗日乘法以及 KKT 条件有一些疑问，这里做一下学习笔记，便于后面复习和理解！ Notion: 同时参考了网上找到的一个PPT（见附件），觉得写的相当棒！ 主要设计四种优化问题： 无约束优化 等式约束优化 不等式约束优化 等式和不等式约束优化 讨论的对象是优化问题的标准形式: $$ \\begin{aligned} &\\min_{x\\in X } \\quad f(x) \\\\ &s.t \\quad \\begin{cases} g_i(x) = 0 \\quad i = 1,2...\\\\ h_j(x)","link":"/2021/08/18/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E6%B3%95%E5%92%8CKKT%E6%9D%A1%E4%BB%B6/"},{"title":"Soft-SVM","text":"由于随机噪声或者误差等问题，因此允许一些点不符合不等式约束条件。理想条件下(hard-svm), 优化问题如下: $$\\begin{aligned}&amp;\\min_{w,b} \\frac{w^Tw}{2} \\s.t.\\quad &amp; y_i(w^Tx_i + b) - 1 &gt;= 0 \\quad i = 1,2,…,n \\\\end{aligned}\\tag{1}$$ 我们允许其存在一定的违规量，这里引入松弛变量 $\\eta &gt;= 0$, 优化问题变为: $$\\begin{aligned}&amp; \\min_{w,b} \\frac{w^Tw}{2} + C\\sum_i^n \\eta_i \\s.t. \\quad &amp; y_i(w^Tx_i + b) - 1 + \\eta_i &gt;= 0\\&amp; \\eta_i &gt;= 0\\ \\tag{2} \\end{aligned}$$ 其中 C &gt; 0 ,成为惩罚参数，当C比较大时对误分类的惩罚较大，C较小时对误分类的惩罚较小，其值通常由应用决定。优化问题 (2) 其实也是个凸二次规划问题，其求解与Hard-SVM一样 1. Lagrange Multiplier对应的拉格朗日乘法公式为 $$\\begin{aligned}L(w,b,\\eta,\\delta) &amp;= \\frac{w^Tw}{2} + C\\sum_i^n \\eta_i - \\sum_i^n \\alpha_i( y_i(w^Tx_i + b) - 1 + \\eta_i) - \\sum_i^n \\delta_i\\eta_i \\\\alpha_i &amp;&gt;= 0 \\quad \\delta_i &gt;=0 \\\\end{aligned} \\tag{3}$$ $\\theta_p(w,b) = \\max_{\\eta,\\delta}L(w,b,\\eta,\\delta)$ 则优化问题（2）可以写作： $$\\begin{aligned}&amp; \\min_{w,b} \\theta_p(w,b) = \\min_{w,b} \\max_{\\eta,\\delta} L(w,b,\\eta,\\delta) \\s.t.\\quad &amp; \\alpha_i &gt;= 0 \\quad \\delta_i &gt;=0 \\ &amp; y_i(w^Tx_i + b) - 1 + \\eta_i &gt;= 0\\&amp; \\eta_i &gt;= 0\\\\end{aligned} \\tag{4}$$ 其对偶问题为： $$\\begin{aligned}&amp;\\max_{\\eta,\\delta} \\min_{w,b} L(w,b,\\eta,\\delta)\\s.t. \\quad &amp; \\eta_i &gt;=0 \\quad \\delta_i &gt;=0 \\ &amp; y_i(w^Tx_i + b) - 1 + \\eta_i &gt;= 0\\&amp; \\eta_i &gt;= 0\\\\end{aligned}\\tag{5}$$ 证明见Hard-SVM求解过程 求解 $\\min_{w,b} L(w,b,\\eta,\\del)$, 分别对w和b求导，并令其偏导数为0 $$\\begin{aligned}\\frac{dL}{dw} &amp;= w - \\sum_i^n\\alpha_iy_ix_i = 0\\\\frac{dL}{db} &amp;= -\\sum_i^n\\alpha_iy_i = 0\\\\end{aligned}\\tag{6}$$ 将(6)带入到 L 中，得到 G","link":"/2020/10/10/SVM(2)_%20Soft-SVM/"},{"title":"Hard-SVM","text":"支持向量机（Support Vector Machine）， 是一种解决分类和回归的经典机器学习模型。以解决分类问题为例，它的核心思想是，最大化输入向量到超平面的间隔。 之前在 感知机 里面我们已经了解到其思想为找到一个超平面，来划分特征空间为正负空间，从而实现分类的目的（如下图）。但是，这样的超平面不只一个，怎么来从中找到一个最优的超平面呢？ 如何评价超平面的优劣呢？这就是SVM解决分类问题的思想。 1. Hard-SVM1.1 模型SVM的思想，通俗来讲是，最大化 Margin(x), Margin(x)代表为，所有点到超平面距离中的最小距， 即 $\\min{Distance(x_i)}$ i = 1,2,3…,n化为最优化的标准型为： $$\\max_{w,b}Margin(x) = \\max_{w,b} \\min_{x_i}Distance(x_i) \\= \\max_{w,b}\\min_{x_i} \\frac{|w^Tx_i + b|}{||w||} \\s.t. \\quad y_i(w^Tx_i + b) &gt; 0$$ 由于 y = 1 or -1， 且分类正确时 $y（w^x + b）&gt; 0$, 因此 $｜w^T + b｜ = y(w^T + b)$这里假设，$y(w^Tx +b ) &gt;= \\sigma &gt; 0$, 此时问题改写为：$\\max_{w,b} \\frac{\\sigma}{||w||} \\s.t. \\quad y_i(w^Tx_i + b) &gt;= \\sigma$ 由于我们可以等比例的修改 w和b是的，$\\sigma$ 变为 1， 这样做并不改变问题的解。同时，$\\frac{1}{||w||}$等同于$\\frac{w^Tw}{2}$，此时问题修改为： $$ \\begin{aligned} &\\min_{w,b}\\frac{w^Tw}{2} \\\\ s.t. \\quad &y_i(w^Tx_i + b) -1 >= 0 \\end{aligned} \\tag{2} $$ 由于该问题是典型的二次优化问题，可以采用优化工具包来解决，也可以转化为对偶问题解决。 2. 策略如何求解式（1）中的二次优化问题，这里可以采用拉格朗日乘法来解决。采用拉格朗日乘法有一个前提，即该问题满足 KKT 条件 2.1 Dual Problem优化问题的标准形式为: $\\max_{x} f(x) \\s.t. \\quad h(x_i) = 0 \\\\quad g(x_i) &gt;= 0 \\quad(2)\\$ 这里引入广义拉格朗日乘法: $$L(x,\\lambda,\\eta) = f(x) - \\sum_i \\lambda_ih(x_i) - \\sum_i\\eta_ig(x_i) \\quad(3) \\\\eta_i &gt;= 0$$ 考虑x的函数$\\theta_p(x) = \\max_{\\lambda,\\eta,\\eta &gt;= 0} L(x,\\lambda,\\eta)$如果x不满足式（2）中的约束条件，即存在 $h(x) \\neq 0$ 或者 $g(x) &lt; 0$, 此时总存在 一个$\\lambda$ 或者$\\eta$ 使得， $\\eta g(x) \\rightarrow +\\infty \\\\lambda h(x) \\rightarrow +\\infty$而当 x符合（2）中条件时，$\\theta_P(x) = f(x)$。因此考虑极小化问题， $$\\begin{aligned}&amp;\\min_{x}{f(x)} = \\min_{x}{\\theta_p(x)} = \\min_{x} \\max_{\\lambda,\\eta,\\eta &gt;= 0}{L(x,\\eta,\\lambda)} \\&amp;\\text{Dual Problem} \\max_{\\lambda, \\eta; \\eta &gt;= 0} \\min_{x L(x,\\eta,\\lambda)}\\end{aligned}$$ 设：$p^{\\star} = \\min_{x}\\theta_p(x) \\d^{\\star} = \\max_{\\lambda, \\eta;\\eta &gt;= 0} \\min_{x} L(x,\\eta,\\lambda)$则有： $$\\min_{x}L(x,\\eta,\\lambda) &lt;= L(x,\\eta,\\lambda) &lt;= \\max_{\\lambda,\\eta,\\eta &gt;= 0}{L(x,\\eta,\\lambda)} \\\\rightarrow \\quad d^{\\star} &lt;= p^{\\star}$$ 当 优化问题的解满足 KKT条件时， $d^{\\star} = p^{\\star}$ 2.2 KKT条件把下面的条件记作 KKT 条件： $$ \\begin{aligned} \\triangledown L(x,\\lambda,\\eta) = 0 \\\\ \\eta_i >= 0 \\\\ \\eta_ig(x_i) = 0 \\\\ g(x_i) >=0 \\\\ h(x_i) = 0 \\end{aligned} $$ 证明： $当g(x_i) &gt; 0 时，此时条件 g(x_i) 不起作用，为等式约束，此时 \\eta_i = 0$ $当 g(x_i) = 0时，此时 \\eta_ig(x_i) = 0$ 2.3 模型求解因此，原问题可以转化为对偶问题 $$ \\begin{aligned} L(w,b,\\lambda) = \\frac{w^Tw}{2} - \\sum_i^n \\lambda_i(y_i(w^Tx_i + b) - 1) \\quad(3)\\\\ \\min_{w,b}\\max_{\\lambda}L(w,b,\\lambda) \\rightarrow \\max_{\\lambda}\\min_{w,b}L(w,b,\\lambda) \\end{aligned} $$ 求解： 对 w，b 求偏导数并令其等于0 $$ \\begin{aligned} \\frac{dL}{dw} = w - \\sum_i^n\\lambda_iy_ix_i = 0 \\quad(4)\\\\ \\frac{dL}{db} = -\\sum_i^n \\lambda_iy_i = 0 \\quad(5) \\end{aligned} $$ 将（4),(5）带入到(3)中，可得： $$ \\begin{aligned} G(\\lambda) &= \\frac{\\sum_i^n\\lambda_iy_ix_i^T\\sum_i^n\\lambda_iy_ix_i}{2} - \\sum_i^n \\lambda_i(y_i(\\sum_j^n\\lambda_jy_jx_j^Tx_i + b) - 1) \\\\ &= \\frac{\\sum_i^n\\lambda_iy_ix_i^T\\sum_i^n\\lambda_iy_ix_i}{2} - \\sum_i^n \\lambda_i(y_i(\\sum_j^n\\lambda_jy_jx_j^Tx_i)) +\\sum_i^n\\lambda_i \\\\ &= \\sum_i^n\\lambda_i - \\frac{\\sum_i^n\\sum_j^n\\lambda_jy_ix_jx_i^T\\lambda_iy_i}{2} \\\\ \\end{aligned}\\tag{6} $$ 此时优化问题为: $$\\begin{aligned} &\\max_{\\lambda} G(\\lambda) \\\\ s.t.\\quad & \\sum_i^n \\lambda_iy_i = 0 \\\\ &\\lambda_i >= 0 \\end{aligned} \\tag{7} $$ 对G函数求极大值，即可得到解 $\\lambda^{\\star}$， 带入到 (4),(5) 可以求解出 $w^{\\star} = \\sum_i^n \\lambda^{\\star}_iy_ix_i$。 求解b, 易知存在 $\\lambda_j \\neq 0$（可以使用反证法证明，若全部$\\lambda$均为0，则 w为0，而w=0不是原始优化问题的解）。此时，有$y_i(w^{\\star} \\cdot x_i + b ) - 1 = 0$,可得 $b^{\\star} = y_i^2 - w^{\\star} \\cdot x_i$ 。 2.4 支撑向量由2.3 第3、4步可知，如果只保留 $\\lambda \\neq 0, \\quad y(w^Tx + b) - 1 = 0$ 对应的x,y，求得的结果w和b不变。 因此把这些向量称之为支撑向量，即 support vector。 reference 统计学习方法. 李航. chapter 7 机器学习. 周志华","link":"/2020/09/27/SVM(1)_%20Hard-SVM/"},{"title":"Disjoint Set (Union-Find )","text":"并查集数据结构 只有 find 和 union 操作, 它用于处理一些不交集的 合并 及 查询 问题。 find : 确定元素所在的集合 union: 合并两个不相交集合 并查集的数据结构 初始化 初始化时，每个节点都是一个集合。 union(x,y) 合并的过程是： 先找到x（y）节点的祖先节点(find(x)) [xp，yp] ，然后比较祖先节点是否相同，若相同则完成合并。负责将其中的祖先节点 (xp) 的父节点指向另一个祖先节点 (yp)：parent[xp] = yp; 一个简单的并查集模版 12345678910111213141516171819202122232425262728int parent[MAXLEN];// 初始化通常将其自身作为父节点void makeSet(int k){ for(int i =0;i&lt;k;i++) parent[i] = i;}// 查找其根节点int find(int x){ if(parent[x] != x){ parent[x] = find(parent[x]); } return parent[x];}// 合并两个不相交集合void union(int x,int y){ int xp = find(x); int yp = find(y); if(xp != yp){ parent[xp] = yp; } while(parent[x]!=yp){ int t = parent[x]; parent[x]=yp; x = t; }} 路径压缩 这样的确可以达成目的，但是显然效率实在太低。为什么呢？因为我们使用了太多没用的信息，我的祖先是谁与我父亲是谁没什么关系，这样一层一层找太浪费时间，不如我直接当祖先的儿子，问一次就可以出结果了。甚至祖先是谁都无所谓，只要这个人可以代表我们家族就能得到想要的效果。把在路径上的每个节点都直接连接到根上，这就是路径压缩。 并查集的应用1. 统计不相交集合的个数 200. 岛屿数量 给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。 示例 1： 输入：grid = [ [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;] ] 输出：1 示例 2： 输入：grid = [ [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;] ] 输出：3 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;class Solution {public: struct Node{ int x; int y; Node():x(0),y(0){}; Node(int x, int y):x(x),y(y){}; bool equal(Node node){return node.x == x &amp;&amp; node.y == y;}; }; Node find(vector&lt;vector&lt;Node&gt;&gt; &amp;parent, Node node){ while(!node.equal(parent[node.x][node.y])){ node = parent[node.x][node.y]; } return node; } bool isParent(vector&lt;vector&lt;Node&gt;&gt; &amp;parent, Node node){ return node.equal(parent[node.x][node.y]); } void unionNode(vector&lt;vector&lt;Node&gt;&gt; &amp;parent, Node x, Node y){ Node xp = find(parent,x); Node yp = find(parent,y); if(!xp.equal(yp)) { parent[xp.x][xp.y] = yp; } while(!x.equal(yp)){ Node node = parent[x.x][x.y]; parent[x.x][x.y] = yp; x = node; } } int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) { int m = grid.size(), n = grid[0].size(); vector&lt;vector&lt;Node&gt;&gt; parent(m,vector&lt;Node&gt;(n,Node())); for(int i =0;i&lt;m;i++){ for(int j=0;j&lt;n;j++){ parent[i][j] = Node(i,j); } } vector&lt;int&gt; xd = {-1,0,1,0}; vector&lt;int&gt; yd = {0,1,0,-1}; for(int i =0;i&lt;m;i++){ for(int j=0;j&lt;n;j++){ if(grid[i][j] == '0') continue; for(int k =0;k&lt; 4;k++){ int x = xd[k] + i; int y = yd[k] + j; if(x &gt;=0 &amp;&amp; x &lt; m &amp;&amp; y &gt;=0 &amp;&amp; y &lt; n){ if(grid[x][y] == '1') unionNode(parent,Node(i,j),Node(x,y)); } } } } int ans = 0; for(int i =0;i&lt;m;i++){ for(int j = 0;j&lt;n;j++){ if(grid[i][j] == '1' &amp;&amp; isParent(parent,Node(i,j))) ans++; } } return ans; }}; Referencehttps://oi-wiki.org/ds/dsu/ https://leetcode-cn.com/problems/number-of-provinces/solution/jie-zhe-ge-wen-ti-ke-pu-yi-xia-bing-cha-0unne/","link":"/2022/01/12/Disjoint%20S%208c71a/"},{"title":"1021 Deepest Root (25分)","text":"A graph which is connected and acyclic can be considered a tree. The height of the tree depends on the selected root. Now you are supposed to find the root that results in a highest tree. Such a root is called the deepest root. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (&lt;=10000) which is the number of nodes, and hence the nodes are numbered from 1 to N. Then N-1 lines follow, each describes an edge by given the two adjacent nodes’ numbers. Output Specification:For each test case, print each of the deepest roots in a line. If such a root is not unique, print them in increasing order of their numbers. In case that the given graph is not a tree, print “Error: K components” where K is the number of connected components in the graph. Sample Input 1:51 21 31 42 5 Sample Output 1:345 Sample Input 2:51 31 42 53 4 Sample Output 2:Error: 2 components Solution本题很关键的一个点是： 有 n 个顶点，但是只有 n-1 条边。由于构成一个连通图的无向图要求，n个顶点最少有n个边，因此本题可以看作为求 一个图的连通分量数目 以及 图的遍历。 对于图的遍历，可以采用 DFS 或者 BFS，求图的连通分量个数，可以采用并查集或者整合到图的遍历过程中 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;void dfs_1021(vector&lt;int&gt; *graph,int *visited,int node,int height,int &amp;maxheight,vector&lt;int&gt; &amp;res){ visited[node] = 1; if(height &gt; maxheight){ maxheight = height; res.clear(); res.push_back(node); } else if(height == maxheight) res.push_back(node); for(int i=0;i&lt;graph[node].size();i++){ if( !visited[graph[node][i]] ) dfs_1021(graph,visited,graph[node][i],height+1,maxheight,res); }}void pat_1021(){ int n,i; cin &gt;&gt; n; // 采用邻接表的来存储无向图 vector&lt;int&gt; graph[n+1]; int x,y,visited[n+1]; // 标记为未访问过 fill(visited,visited+n+1,0); for(i= 0;i&lt;n-1;i++){ cin &gt;&gt; x &gt;&gt; y; graph[x].push_back(y); graph[y].push_back(x); } vector&lt;int&gt; res; int maxheight = 0; int k =0; for(int j=1;j&lt;=n;j++){ if(visited[j]==0){ dfs_1021(graph,visited,j,1,maxheight,res); k++; } } if(k&gt;1) printf(&quot;Error: %d components\\n&quot;,k); else { int nodes[n+1],node = res[0]; fill(nodes,nodes+n+1,0); for(i =0;i&lt;res.size();i++) nodes[res[i]]++; if(n&gt;1){ res.clear(); fill(visited,visited+n+1,0); maxheight = 0; dfs_1021(graph,visited,node,1,maxheight,res); for(i =0;i&lt;res.size();i++) nodes[res[i]]++; } for(i=1;i&lt;=n;i++){ if(nodes[i] &gt; 0) cout &lt;&lt; i &lt;&lt; endl; } } }int main(){ pat_1021(); return 0;}","link":"/2020/03/08/2020-03-08-1021-Deepest-Root-(25%E5%88%86)/"},{"title":"1040 Longest Symmetric String (25分)","text":"Given a string, you are supposed to output the length of the longest symmetric sub-string. For example, given Is PAT&amp;TAP symmetric?, the longest symmetric sub-string is s PAT&amp;TAP s, hence you must output 11. Input Specification:Each input file contains one test case which gives a non-empty string of length no more than 1000. Output Specification:For each test case, simply print the maximum length in a line. SampleInput:Is PAT&amp;TAP symmetric? Output:11 Solution假设回文串在 i,j 之间，所有的 i,j 组合有 $C_2^n$，其中大约有一半的重复( i&gt;j 与 i &lt; j)。因此第一种可以考虑暴力求解法，穷举所有的组合，然后判断是非为回文字符串即可，此时的时间复杂度为 $O(N^3)$ 。 然后，进一步分析会发现，其实存在很多重复的子问题，如 对于下标为i,j的字符串它依赖于i+1,j-1。因此符合动态规划的思想，即从底向上并且对子问题进行记录。它的规划式为 $$ LSS(i,j) = LSS(i+1,j-1) \\And (A[i] == A[j]); $$ 这里有一个问题点，计算 LSS(i,j) 要用到 LSS(i+1,j-1) ，因此计算时不能采用 i,j 这样遍历，而是以 j-i 的长度为依据进行遍历，先计算为1,2的情况，在计算其它情况。 Code暴力12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;bool isSymmetric(string str,int i,int j){ while(i&lt;j){ if(str[i++]!=str[j--]) return false; } return true;}// 暴力求解 o(n^3)void pat_1040(){ string str; getline(cin,str); int i=0,l=str.size()-1,j=l,res = 0; for(;i&lt;=l;i++){ for(j=i;j&lt;=l;j++){ if(isSymmetric(str,i,j)){ res = max(res,j-i+1); } } } cout &lt;&lt; res;}int main(){ pat_1040(); return 0;} 动态规划1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;void pat_1040(){ string str; getline(cin,str); int i=0,l=str.size()-1,j=l,res = 1; bool is[l+1][l+1]; fill(is[0],is[0]+(l+1)*(l+1),false); // 标记 长度为1 和 2 for(i=0;i&lt;=l;i++){ is[i][i] = true; if(i+1&lt;=l &amp;&amp; str[i+1] == str[i]){ is[i][i+1] = true; res = 2; } } j = 3 ; while(j&lt;=l+1){ for(i=0;i + j -1&lt;=l;i++){ int k = i+j-1; if(str[i] == str[k] &amp;&amp; is[i+1][k-1] ){ res = j; is[i][k] = true; } } j++; } cout &lt;&lt; res;}int main(){ pat_1040(); return 0;}","link":"/2020/03/10/2020-03-10-1040-Longest-Symmetric-String-(25%E5%88%86)/"},{"title":"LaTex Markdown Syntax","text":"see https://www.caam.rice.edu/~heinken/latex/symbols.pdf $2x - 5y = 8$$3x + 9y = -12$ $$f(x)=\\frac{P(x)}{Q(x)}$$","link":"/2020/03/10/2020-03-10-LaTex-Markdown-Syntax/"},{"title":"1090 Highest Price in Supply Chain (25分)","text":"A supply chain is a network of retailers（零售商）, distributors（经销商）, and suppliers（供应商）– everyone involved in moving a product from supplier to customer. Starting from one root supplier, everyone on the chain buys products from one’s supplier in a price P and sell or distribute them in a price that is r% higher than P. It is assumed that each member in the supply chain has exactly one supplier except the root supplier, and there is no supply cycle. Now given a supply chain, you are supposed to tell the highest price we can expect from some retailers. Input Specification:Each input file contains one test case. For each case, The first line contains three positive numbers: ($N ≤ 10^5$), the total number of the members in the supply chain (and hence they are numbered from 0 to N−1); P, the price given by the root supplier; and r, the percentage rate of price increment for each distributor or retailer. Then the next line contains N numbers, each number $S_i$ is the index of the supplier for the i-th member. $S_root$ for the root supplier is defined to be −1. All the numbers in a line are separated by a space. Output Specification:For each test case, print in one line the highest price we can expect from some retailers, accurate up to 2 decimal places, and the number of retailers that sell at the highest price. There must be one space between the two numbers. It is guaranteed that the price will not exceed $$10^10$$. SampleInput:129 1.80 1.001 5 4 4 -1 4 5 3 6 Output:11.85 2 Solution例子可以抽象为如下所示的一颗树 123456789 4 / | \\ 2 3 5 / / \\ 7 6 1 / / 8 0 &lt;- height = 4, number = 2 -&gt; 供应链是一个有向无环图，可以抽象为一棵树。本题主要是为了求树的高度以及最后一层树的节点数，采用层序遍历（BFS）即可。注意一点是，float 的表示范围无法到达 $$10^10$$，故需采用 double 类型 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;void pat_1090(){ // n the total number of the numbers in the supply chain int n; // p is the original price // r is the up rate in every convery double p,r; cin &gt;&gt; n &gt;&gt; p &gt;&gt; r; // 拓扑图(无环，有向图)，采用树来模拟 vector&lt;int&gt; tree[n+1]; // 构建树 int i,parent,root; for(int i=0;i&lt;n;i++){ cin &gt;&gt; parent; if(parent == -1) root = i; else tree[parent].push_back(i); } int size ,height = 0,node; // 采用树的层序遍历。即类似于图的 BFS 来寻找最长路径 queue&lt;int&gt; q; q.push(root); while(!q.empty()){ size = q.size(); height ++; for(i=0;i&lt; size;i++){ node = q.front(); q.pop(); // 这里由于是有向无环图，每个节点只访问一次，故无需标记 for(int j=0;j&lt;tree[node].size();j++){ q.push(tree[node][j]); } } } r = 1+0.01*r; double res = pow(r,height-1) * p; printf(&quot;%.2lf %d\\n&quot;,res,size); }int main(){ pat_1090(); return 0;}","link":"/2020/03/10/2020-03-10-1090-Highest-Price-in-Supply-Chain-(25%E5%88%86)/"},{"title":"1045 Favorite Color Stripe (30分)","text":"Eva is trying to make her own color stripe out of a given one. She would like to keep only her favorite colors in her favorite order by cutting off those unwanted pieces and sewing the remaining parts together to form her favorite color stripe. It is said that a normal human eye can distinguish about less than 200 different colors, so Eva’s favorite colors are limited. However the original stripe could be very long, and Eva would like to have the remaining favorite stripe with the maximum length. So she needs your help to find her the best result. Note that the solution might not be unique, but you only have to tell her the maximum length. For example, given a stripe of colors {2 2 4 1 5 5 6 3 1 1 5 6}. If Eva’s favorite colors are given in her favorite order as {2 3 1 5 6}, then she has 4 possible best solutions {2 2 1 1 1 5 6}, {2 2 1 5 5 5 6}, {2 2 1 5 5 6 6}, and {2 2 3 1 1 5 6}. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (≤200) which is the total number of colors involved (and hence the colors are numbered from 1 to N). Then the next line starts with a positive integer M (≤200) followed by M Eva’s favorite color numbers given in her favorite order. Finally the third line starts with a positive integer L (≤$10^4$ ) which is the length of the given stripe, followed by L colors on the stripe. All the numbers in a line a separated by a space. Output Specification:For each test case, simply print in a line the maximum length of Eva’s favorite stripe. SampleInput:123456765 2 3 1 5 612 2 2 4 1 5 5 6 3 1 1 5 6``` ### Output: 7 1234567891011## Solution题目意思为要求出能够留下的喜欢条纹的最大长度，约束主要是喜欢序列的顺序，即必须按照顺序进行保留。对于目标序列 `2 3 1 5 6`，如果`3` 已经保留，后面的条纹如果出现的`2`则被抛弃掉（优先级一次递减的感觉）。而且，结果的同一种条纹可以连续出现，条纹种类可以不完全都有。对于每个最优子结构都有 （F(n) 为当前颜色为`n`的最大长度）```latexF(2) = F(2) + 1 // max(F(2),F(0))+1 F(3) = max(F(2),F(3)) +1... 由此可以得到递推公式: $$ F(n) = max(F(n),F(n-1)) +1 $$ 这里需要 F(n-1)，F(n) 类似于 F(3) ,F(2) ，因此需要保留 目标条纹之间的位置关系，这个可以使用 map 实现，也可以使用 空间换时间的 数组实现 （其实也是 map 的思想） Code123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;void pat_1045(){ int n,m,l,color; cin &gt;&gt; n; int i,wanted[n+1],indexes[n+1]; wanted[0] = 0; fill(indexes,indexes+n+1,0); cin &gt;&gt; m; for(i=1;i&lt;= m;i++){ cin &gt;&gt; color; indexes[color] = i; wanted[i] = color; } cin &gt;&gt; l; int nums[l+1]; for(i=1;i&lt;=l;i++ ) cin &gt;&gt; nums[i]; int res[n+1]; fill(res,res+n+1,0); int max_re = 0; for(i=1;i&lt;=l;i++){ if(indexes[nums[i]]&gt;0) { res[nums[i]] = max(res[nums[i]],res[wanted[indexes[nums[i]]-1]]) + 1; max_re = max(max_re,res[nums[i]]); } } cout &lt;&lt; max_re;}int main(){ pat_1045(); return 0;}","link":"/2020/03/11/2020-03-11-1045-Favorite-Color-Stripe-(30%E5%88%86)/"},{"title":"1099 Build A Binary Search Tree (30分)","text":"A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the node’s key.The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.Both the left and right subtrees must also be binary search trees.Given the structure of a binary tree and a sequence of distinct integer keys, there is only one way to fill these keys into the tree so that the resulting tree satisfies the definition of a BST. You are supposed to output the level order traversal sequence of that tree. The sample is illustrated by Figure 1 and 2. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (&lt;=100) which is the total number of nodes in the tree. The next N lines each contains the left and the right children of a node in the format “left_index right_index”, provided that the nodes are numbered from 0 to N-1, and 0 is always the root. If one child is missing, then -1 will represent the NULL child pointer. Finally N distinct integer keys are given in the last line. Output Specification:For each test case, print in one line the level order traversal sequence of that tree. All the numbers must be separated by a space, with no extra space at the end of the line. SampleInput:123456789101191 62 3-1 -1-1 45 -1-1 -17 -1-1 8-1 -173 45 11 58 82 25 67 38 42 Output:58 25 82 11 38 67 45 73 42 SolutionBST树，有一个特点：它的中序序列是一个有序序列，这道题的关键就是抓住这个特点。步骤也很清晰 构建树 (看清题干，可以选择一个结构体数组来存储树的各个节点) 数据排序，从小到大排序 构建树的中序序列（可以选择递归或者采用非递归遍历），这一步主要是找到树的节点与数据的对应关系 树的层序遍历，遍历的同时打印节点值即可 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;struct TreeNode{ int parent, left, right;};TreeNode nodes[100];vector&lt;int&gt; orders;void inorders(int parent){ if (parent != -1) { TreeNode node = nodes[parent]; inorders(node.left); orders.push_back(node.parent); inorders(node.right); }}void pat_1099(){ int n, parent = 0, i, j; cin &gt;&gt; n; // 构建树 for(i=0;i&lt;n;i++){ cin &gt;&gt; nodes[i].left &gt;&gt; nodes[i].right; nodes[i].parent = i; } // 中序序列 inorders(parent); int nums[n], maps[n]; // 建立起 中序序列与其索引之间的关系 for (i = 0; i &lt; orders.size(); i++) maps[orders[i]] = i; for (i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;nums[i]); // 中序序列为有序序列 sort(nums, nums + n); queue&lt;TreeNode&gt; q; q.push(nodes[0]); int size = 1; // 层序遍历，打印结果 while (!q.empty()) { size = q.size(); for (j = 0; j &lt; size; j++) { TreeNode node = q.front(); q.pop(); if (node.parent != 0) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; nums[maps[node.parent]]; if (node.left != -1) q.push(nodes[node.left]); if (node.right != -1) q.push(nodes[node.right]); } }}int main(){ pat_1099(); return 0;}","link":"/2020/03/12/2020-03-12-1099-Build-A-Binary-Search-Tree-(30%E5%88%86)/"},{"title":"1115 Counting Nodes in a BST (30分)","text":"A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than or equal to the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. Insert a sequence of numbers into an initially empty binary search tree. Then you are supposed to count the total number of nodes in the lowest 2 levels of the resulting tree. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (≤1000) which is the size of the input sequence. Then given in the next line are the N integers in [−1000,1000] which are supposed to be inserted into an initially empty binary search tree. Output Specification:For each case, print in one line the numbers of nodes in the lowest 2 levels of the resulting tree in the format: 1n1 + n2 = n where n1 is the number of nodes in the lowest level, n2 is that of the level above, and n is the sum. SampleInput:12925 30 42 16 20 20 35 -5 28 Output:12 + 4 = 6 Solution先建立BST, 建树的同时可以记录节点的层数即最大层数，最后遍历一遍即可 注意：看清题干，本题 The left subtree of a node contains only nodes with keys less than or equal to the node's key. ， 找了半个小时，才发现 代码就很简单了 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;using namespace std;struct BinaryNode{ int left, right, data, level;};void pat_1115(){ int n,val,i; cin &gt;&gt; n; BinaryNode nodes[n]; for (i = 0; i &lt; n; i++) { cin &gt;&gt; val; nodes[i] = {-1,-1,val,0}; } int root = 0, cur, maxLevel = 0; for (i = 1; i &lt; n; i++) { root = 0; while (root != -1) { if (nodes[root].data &gt;= nodes[i].data) { cur = nodes[root].left; if (cur == -1) { nodes[root].left = i; nodes[i].level = nodes[root].level + 1; } } else { cur = nodes[root].right; if (cur == -1) { nodes[root].right = i; nodes[i].level = nodes[root].level + 1; } } maxLevel = max(maxLevel, nodes[i].level); root = cur; } } int prelevel = 0, curlevel = 0; for (i = 0; i &lt; n; i++) { if (nodes[i].level == maxLevel) curlevel++; else if (nodes[i].level == maxLevel - 1) prelevel++; } printf(&quot;%d + %d = %d\\n&quot;, curlevel, prelevel, curlevel + prelevel);}int main(){ pat_1115(); return 0;}","link":"/2020/03/12/2020-03-12-1115-Counting-Nodes-in-a-BST-(30%E5%88%86)/"},{"title":"1123 Is It a Complete AVL Tree (30分)","text":"An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules. Now given a sequence of insertions, you are supposed to output the level-order traversal sequence of the resulting AVL tree, and to tell if it is a complete binary tree. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (≤ 20). Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space. Output Specification:For each test case, insert the keys one by one into an initially empty AVL tree. Then first print in a line the level-order traversal sequence of the resulting AVL tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Then in the next line, print YES if the tree is complete, or NO if not. SampleInput 1:12588 70 61 63 65 Output 1:1270 63 88 61 65YES ##Sample Input 2:12888 70 61 96 120 90 65 68 Output 2:1288 65 96 61 70 90 120 68NO Solution主要分两步: 建立avl树 (过程参见 AvlTree) 进行层序遍历，遍历过程中判断是否为完全二叉树 完全二叉树的定义为 最多有一个只有一个叶子的节点Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;iostream&gt;#include&lt;cmath&gt;#include &lt;queue&gt;using namespace std; struct avl_node{ struct avl_node *left, *right; int data, height;};typedef struct avl_node *AvlTree, *AvlNode;int height(AvlNode k){ return k ? k-&gt;height : -1;}// lr 旋转AvlNode left_right_rotate(AvlNode k2){ AvlNode k1 = k2-&gt;left; k2-&gt;left = k1-&gt;right; k1-&gt;right = k2; k2-&gt;height = max(height(k2-&gt;left), height(k2-&gt;right)) + 1; k1-&gt;height = max(height(k1-&gt;left), height(k1-&gt;right)) + 1; return k1;}// rl 旋转AvlNode right_left_rotate(AvlNode k1){ AvlNode k2 = k1-&gt;right; k1-&gt;right = k2-&gt;left; k2-&gt;left = k1; k1-&gt;height = max(height(k1-&gt;left), height(k1-&gt;right)) + 1; k2-&gt;height = max(height(k2-&gt;left), height(k2-&gt;right)) + 1; return k2;}// ll 旋转AvlNode left_left_rotate(AvlNode k3){ k3-&gt;left = right_left_rotate(k3-&gt;left); return left_right_rotate(k3);}// rr 旋转AvlNode right_right_rotate(AvlNode k1){ k1-&gt;right = left_right_rotate(k1-&gt;right); return right_left_rotate(k1);}AvlNode insert(AvlNode t, int val){ if (!t) { t = new avl_node(); t-&gt;data = val; t-&gt;height = 0; t-&gt;left = t-&gt;right = nullptr; return t; } // self-check if (t-&gt;data &gt; val) { t-&gt;left = insert(t-&gt;left, val); if (height(t-&gt;left) - height(t-&gt;right) == 2) { // lr 旋转 if (t-&gt;left-&gt;data &gt; val) t = left_right_rotate(t); else t = left_left_rotate(t); } } else { t-&gt;right = insert(t-&gt;right, val); if (height(t-&gt;right) - height(t-&gt;left) == 2) { // rl 旋转 if (t-&gt;right-&gt;data &lt; val) t = right_left_rotate(t); else t = right_right_rotate(t); } } t-&gt;height = max(height(t-&gt;left), height(t-&gt;right)) + 1; return t;}bool level_loop(AvlNode tree){ queue&lt;AvlNode&gt; q; q.push(tree); int flag = 1; bool complete = true, leaf = false, falg = true; while (!q.empty()) { AvlNode node = q.front(); q.pop(); if (!flag) cout &lt;&lt; &quot; &quot;; else flag = false; cout &lt;&lt; node-&gt;data; if (node-&gt;left) q.push(node-&gt;left); if (node-&gt;right) q.push(node-&gt;right); if (!node-&gt;left &amp;&amp; node-&gt;right) complete = false; if (leaf &amp;&amp; (node-&gt;left || node-&gt;right)) complete = false; if (!node-&gt;left || !node-&gt;right) leaf = true; } cout &lt;&lt; endl; return complete;}void pat_1123(){ int n, i, val; cin &gt;&gt; n; AvlTree root = nullptr; for (i = 0; i &lt; n; i++) { cin &gt;&gt; val; root = insert(root, val); } bool complete = level_loop(root); if (complete) cout &lt;&lt; &quot;YES&quot;; else cout &lt;&lt; &quot;NO&quot;;}int main(){ pat_1123(); return 0;}","link":"/2020/03/12/2020-03-12-1123-Is-It-a-Complete-AVL-Tree-(30%E5%88%86)/"},{"title":"Avl Tree","text":"对于二叉搜索树，如果预先输入一堆排好序的序列，其会退化成单链表。为了解决这个问题，规定一个平衡的附加条件:任何节点的深度都不的过深。但是标准的二叉平衡树实现起来复杂性过高，因此介绍一种较为经典的平衡术—avl(adelson-velskii and landis) 树 它的特点是: 每个节点的左子树和右子树相差高度不超过1的二叉搜索树 Insert对于 avl 树最主要的问题应该在于插入后，如何保证其平衡的要求即: 每个节点的左子树和右子树相差高度不超过1 对于一节待平衡节点，破坏其平衡由四种可能 对其左儿子的左子树一次插入 对其左儿子的右子树一次插入 对其右儿子的右子树一次插入 对其右儿子的左子树一次插入 对于每一种情况进行分析 left - left 结构(即第一种) 此时 k2 节点是不平衡的， 此时以k1为节点，顺时针旋转,k2，然后将k1的右孩子置为k2，k2的左孩子置为y 12345678910111213Position single_rotate_with_left(Position k2){ Position k1; k1 = k2-&gt;left; k2-&gt;left = k1-&gt;right; k1-&gt;right = k2; k2-&gt;height = max(height(k2-&gt;left), height(k2-&gt;right)) + 1; k1-&gt;height = max(height(k1-&gt;left), height(k1-&gt;right)) + 1; return k1;} right - right 结构(第三种) 此时与第一种对称 123456789101112Position single_retate_with_right(Position k1){ Position k2; k2 = k1-&gt;right; k1-&gt;right = k2-&gt;left; k2-&gt;left = k1; k2-&gt;height = max(height(k2-&gt;left), height(k2-&gt;right)) + 1; k1-&gt;height = max(height(k1-&gt;left), height(k1-&gt;right)) + 1; return k2;} left-right 结构[第二种结构] 此时可以观察，k1,k2,k3布局，使用两次旋转。第一次对于k1,k2进行一次右单旋(第三种结构)。再对调整后的布局(k2,k3)再进行一次左单旋。 1234567Position rotate_with_right_left(Position k3){ k3-&gt;left = single_rotate_with_right(k3-&gt;left); return single_rotate_with_left(k3);} right-left 结构[第四种结构] 此时可以观察，k1,k2,k3布局，使用两次旋转。第一次对于k2,k3进行一次左单旋(第一种结构)。再对调整后的布局(k1,k2)再进行一次右单旋。 123456Position rotate_with_left_right(Position k1){ k1-&gt;right = single_rotate_with_left(k1-&gt;right); return single_rotate_with_right(k1);} 插入接下来的插入就比较清晰了，插入流程与二叉搜索树一样，但是每次插入之后，要对其平衡性进行判断，根据不同的情形，进行不同的调整: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748AvlTree insert(Element e, AvlTree t, compare_func cmp){ if (t == NULL) { t = (AvlTree)malloc(sizeof(struct AvlNode)); t-&gt;height = 0; t-&gt;e = e; return t; } int cp = cmp(e, t-&gt;e); if (cp == 0) return t; else if (cp &gt; 0) { t-&gt;right = insert(e, t-&gt;right, cmp); if (height(t-&gt;right) - height(t-&gt;left) == 2) { if (cmp(e, t-&gt;right-&gt;e) &gt; 0) { t = single_rotate_with_right(t); } else { t = rotate_with_right_left(t); } } } else { t-&gt;left = insert(e, t-&gt;left, cmp); if (height(t-&gt;left) - height(t-&gt;right) == 2) { if (cmp(e, t-&gt;left-&gt;e) &lt; 0) { t = single_rotate_with_left(t); } else { t = rotate_with_left_right(t); } } } t-&gt;height = max(height(t-&gt;left), height(t-&gt;right)) + 1; return t;} find查找过程与二叉搜索树一样 delete删除采用哑节点的模式，因为删除后的调整更为繁杂。 1234567891011AvlTree remove(Element e, AvlTree t, compare_func cmp){ Position p = find(e, t, cmp); if (p == NULL) { return NULL; } p-&gt;rate = 0; return p;} // TODO更多删除方法，请见… Implementavl_tree","link":"/2020/03/12/2020-03-12-Avl-Tree/"},{"title":"1135 Is It A Red-Black Tree (30分)","text":"There is a kind of balanced binary search tree named red-black tree in the data structure. It has the following 5 properties: (1) Every node is either red or black.(2) The root is black.(3) Every leaf (NULL) is black.(4) If a node is red, then both its children are black.(5) For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.For example, the tree in Figure 1 is a red-black tree, while the ones in Figure 2 and 3 are not.For each given binary search tree, you are supposed to tell if it is a legal red-black tree. Input Specification:Each input file contains several test cases. The first line gives a positive integer K (≤30) which is the total number of cases. For each case, the first line gives a positive integer N (≤30), the total number of nodes in the binary tree. The second line gives the preorder traversal sequence of the tree. While all the keys in a tree are positive integers, we use negative signs to represent red nodes. All the numbers in a line are separated by a space. The sample input cases correspond to the trees shown in Figure 1, 2 and 3. Output Specification:For each test case, print in a line “Yes” if the given tree is a red-black tree, or “No” if not. SampleInput:12345678397 -2 1 5 -4 -11 8 14 -15911 -2 1 -7 5 -4 8 14 -15810 -7 5 -6 8 15 -11 17 Output:123YesNoNo Solution关于红黑树的定义参照 (rb_tree) 了解了红黑树的定义后，步骤就很清晰了 建树（采用链表或者数组均可以） 判断是否为红黑树，主要抓住一下几点 根节点为黑色 每个节点非黑即红 红色节点是叶子结点或者它的孩子节点（左右） 均为黑色节点 每个节点的左右节点的黑高均相等 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495struct RBNode{ struct RBNode *left, *right; int key;};int getheight(RBNode *root){ if (!root) return 0; int l = getheight(root-&gt;left); int r = getheight(root-&gt;right); return root-&gt;key &gt; 0 ? max(l, r) + 1 : max(l, r);}RBNode *insertRBTree(RBNode *root, int val){ if (!root) { root = new RBNode(); root-&gt;left = root-&gt;right = nullptr; root-&gt;key = val; } else { if (abs(val) &lt;= abs(root-&gt;key)) { root-&gt;left = insertRBTree(root-&gt;left, val); } else root-&gt;right = insertRBTree(root-&gt;right, val); } return root;}// 判断是非为 rb treebool isRBTree(RBNode *root){ // 采用 层序遍历 来判断是否符合要求 queue&lt;RBNode *&gt; q; q.push(root); bool is = true; while (!q.empty() &amp;&amp; is) { RBNode *node = q.front(); q.pop(); if (node-&gt;left) { q.push(node-&gt;left); } if (node-&gt;right) { q.push(node-&gt;right); } int left = getheight(node-&gt;left), right = getheight(node-&gt;right); if (left != right) is = false; if (node-&gt;key &lt; 0) { if (!((!node-&gt;left &amp;&amp; !node-&gt;right) || (node-&gt;left &amp;&amp; node-&gt;left-&gt;key &gt; 0 &amp;&amp; node-&gt;right &amp;&amp; node-&gt;right-&gt;key &gt; 0))) is = false; } else if (node-&gt;key == 0) is = false; } return is;}void pat_1135(){ int k, i, j, n, val; cin &gt;&gt; k; for (i = 0; i &lt; k; i++) { cin &gt;&gt; n; RBNode *root = nullptr; for (j = 0; j &lt; n; j++) { cin &gt;&gt; val; root = insertRBTree(root, val); } if (root-&gt;key &lt; 0 || !isRBTree(root)) cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; }}int main(){ pat_1135(); return 0;}","link":"/2020/03/13/2020-03-13-1135-Is-It-A-Red-Black-Tree-(30%E5%88%86)/"},{"title":"1154 Vertex Coloring (25分)","text":"A proper vertex coloring is a labeling of the graph’s vertices with colors such that no two vertices sharing the same edge have the same color. A coloring using at most k colors is called a (proper) k-coloring. Now you are supposed to tell if a given coloring is a proper k-coloring. Input Specification:Each input file contains one test case. For each case, the first line gives two positive integers N and M (both no more than $10^4$), being the total numbers of vertices and edges, respectively. Then M lines follow, each describes an edge by giving the indices (from 0 to N−1) of the two ends of the edge. After the graph, a positive integer K (≤ 100) is given, which is the number of colorings you are supposed to check. Then K lines follow, each contains N colors which are represented by non-negative integers in the range of int. The i-th color is the color of the i-th vertex. Output Specification:For each coloring, print in a line k-coloring if it is a proper k-coloring for some positive k, or No if not. SampleInput:123456789101112131415161710 118 76 84 58 48 11 21 49 89 11 02 440 1 0 1 4 1 0 1 3 00 1 0 1 4 1 0 1 0 08 1 0 1 4 1 0 5 3 01 2 3 4 5 6 7 8 8 9 Output:12344-coloringNo6-coloringNo Solution实际上考察的是图的遍历，这里采用的是无向图的邻接表的存法，BFS (类似于) Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;vector&gt;using namespace std; void pat_1154(){ int n, m; cin &gt;&gt; n &gt;&gt; m; int i, v1, v2, visited[n]; vector&lt;int&gt; vertices[n]; for (i = 0; i &lt; m; i++) { cin &gt;&gt; v1 &gt;&gt; v2; vertices[v1].push_back(v2); vertices[v2].push_back(v1); } int k; cin &gt;&gt; k; for (int j = 0; j &lt; k; j++) { int color = 0, colors[n], num = 0; map&lt;int, int&gt; maps; fill(visited, visited + n, 0); for (i = 0; i &lt; n; i++) { cin &gt;&gt; color; if (maps.count(color) == 0) { num++; maps[color] = 1; } colors[i] = color; } bool ok = true; for (i = 0; i &lt; n; i++) { if (!visited[i]) { for (int k = 0; k &lt; vertices[i].size(); k++) { if (!visited[vertices[i][k]]) { if (colors[i] == colors[vertices[i][k]]) { ok = false; break; } } } visited[i] = 1; } } if (ok) printf(&quot;%d-coloring\\n&quot;, num); else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; }}int main(){ pat_1154(); return 0;}","link":"/2020/03/13/2020-03-13-1154-Vertex-Coloring-(25%E5%88%86)/"},{"title":"RB Tree","text":"上面介绍了二叉搜索树以及avl树，这里介绍另外一种近似平衡的二叉树– 红黑树它的每个节点都有5个属性: color、key、left、right、p 一棵红黑树通常拥有以下性质 每个节点或是红色，或是黑色的 (rb) 根节点是黑色的 每个叶子节点也是黑色的 如果一个节点是红色的，则它的两个子节点都是黑色的 对于每个节点，从该节点到所有后代叶节点的简单路径上，均包含相同数目的黑色节点 上图 1 是红黑树，其余均不是 它的插入删除以及访问的时间复杂度为 O(lgN)定义，bh(x) (black height) 为黑高，即节点x到期叶子节点的黑色节点的个数 证明: 一个n个内部节点的红黑树，它的高度最多为 $2*log_2(n+1)$ 首先证明: 以任一节点的x为根的红黑树最少含有 $2^{bh(x)}-1$ 个节点 归纳法证明: 由性质5，可以看出: 若x的高度为0，即其为叶子节点(nil)，此时有 $n &gt;= 2^0 - 1 = 0$ 若x的高度为1，则至少有 $n = 2^0-1 + 2^0 -1 + 1 = 1$ 对于一个任意节点x，它的左右节点的黑高为bh(x)或者bh(x)-1.即它的最少黑高为bh(x)-1，则 以x为根的子树，至少含有 $$ (2^{(bh(x)-1)}-1)+ (2^{(bh(x)-1)}-1)+1 = 2^{bh(x)}-1 $$ 个节点数， 由性质4，可以看出 对于高度为h的红黑树，它的黑高至少为 $h/2$,所以 $$ n&gt;=2^{(h/2)}-1 $$ 解之可🉐: $$ h&lt;= 2*log_2(n+1) $$ 得证 调整节点与avl树，类似，红黑树的插入或者删除，可能破坏其平衡(性质)。因此需要进行旋转调整。 平衡的破坏我们设定每次插入的元素都是红色节点(这样子可以避免最坏情况的发生)，这样子不会破坏性质1、3、5. 对于性质2的破坏，我们很容易进行识别出来。对于性质4的破坏，我们要进行简单分析一下。 对于更新破坏红黑树特性的问题，有一些调整的方法: BST operation Color changes Restructure the tree via rotation (recolor、lint) 左旋 and 右旋 这些操作只是进行了指针的交换，话费常数时间。 Insert element (O(lgN))对于新插入的节点，我们设定它都是红色的，然后采用一些操作，对其平衡性进行调整主要的调整方法为: recolor rotation 一个例子先通过一个实例进行详细描述，后面在进行抽象，下面是一个红黑树插入元素15的过程。 先找到待插入的位置，插入元素15，并将其着色为 红色 15的祖父节点颜色是黑色，而它的父节点以及叔节点颜色是红色，因此，可以将祖父节点颜色下沉，即重新着色祖父节点为红色，叔节点以及父节点为黑色(case-1)。这时，冲突就变成了 10-18 颜色冲突 10-18 颜色冲突，且对于节点10来说，它并满足（case-1）的情况，无法进行重着色来满足条件4.此时，采用旋转操作，以节点18进行右旋（case-2），将10-18以及祖父节点在一条直线(看上去)。 4. 再以节点7为节点，进行左旋(case-3)，然后重新着色（次数左子树黑高降低一，因此需要重新着色）5. 将跟节点重新着色。 抽象对于以上可以分为三种状态(或6种，因为左右情况对称,下面已左面情况为例)。 是插入的节点，`f(x)` 是其父节点，`f(f(x))` 是其祖父节点 `uncle of x as u(x)` 是其叔叔节点（y）。123456789101112单线条是黑色节点，双线条是红色##### case-1 ![](https://raw.githubusercontent.com/hsjfans/git_resource/master/20190506202531.png)该情况是，`f(f(x))` 是黑色，`f(x)`是红色，`u(x)`是红色。此时，可以将其祖父节点(`f(f(x))`)颜色吓成，即变成 color[f(x)] = BLACKcolor[f(f(x))] = REDcolor[u(x)] = BLACK 1234567891011此时，可以解决节点x的颜色冲突。```cvoid re_color(RBTreeNode b){ b-&gt;parent-&gt;color = RED; b-&gt;parent-&gt;left-&gt;color = BLACK; b-&gt;parent-&gt;right-&gt;color = BLACK; return;} case-2 此时，节点y不是红色，无法通过着色来解决。x 是其父节点的右节点，视觉上看，节点C-A-B不再一条直线上，此时采用旋转，来使节点C-A-B在一条直线上 1234567a-&gt;right = cc-&gt;left = bb-&gt;parent = ca-&gt;parent= c-&gt;parentc-&gt;parent = a 1234567891011121314151617181920212223242526// right rotationvoid right_rotation(RBTree t, RBTreeNode a){ RBTreeNode b = a-&gt;parent; a-&gt;parent = b-&gt;parent; if (b-&gt;parent == NULL) { t-&gt;root = a; } else if (b-&gt;parent-&gt;left == b) { b-&gt;parent-&gt;left = a; } else { b-&gt;parent-&gt;right = a; } if (a-&gt;right != NULL) { a-&gt;right-&gt;parent = b; } b-&gt;left = a-&gt;right; b-&gt;parent = a; a-&gt;right = b;} case-3 节点y不是红色，无法通过着色来解决。x 是其父节点的左节点，视觉上看，节点C-A-B在一条直线上。此时，可以采用旋转加重着色进行调整。 1234567891011c-&gt;left = a-&gt;righta-&gt;right = ca-&gt;parent=c-&gt;parentc-&gt;parent=ac-&gt;left=ccolor[a] = BLACKcolor[c] = RED 123456789101112131415161718192021222324252627void left_rotation(RBTree t, RBTreeNode a){ RBTreeNode b = a-&gt;right; a-&gt;right = b-&gt;left; if (a-&gt;left != NULL) { b-&gt;left-&gt;parent = a; } b-&gt;parent = a-&gt;parent; if (a-&gt;parent == NULL) { t-&gt;root = b; } else if (a == b-&gt;parent-&gt;left) { a-&gt;parent-&gt;left = b; } else { a-&gt;parent-&gt;right = b; } b-&gt;left = a; a-&gt;parent = b;} complicate123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596void insert(RBTree t, Element e, compare_func cmp){ RBTreeNode root = t-&gt;root; RBTreeNode temp = t-&gt;nil; while (root != t-&gt;nil) { temp = root; if (cmp(e, root-&gt;val) &lt; 0) { root = root-&gt;left; } else { root = root-&gt;right; } } RBTreeNode n = make_node(e); n-&gt;parent = temp; if (temp == t-&gt;nil) { t-&gt;root = n; } else if (cmp(e, temp-&gt;val) &lt; 0) { temp-&gt;left = n; } else { temp-&gt;right = n; } n-&gt;left = t-&gt;nil; n-&gt;right = t-&gt;nil; n-&gt;color = RED; insert_fix_up(t, n); return;}void insert_fix_up(RBTree t, RBTreeNode n){ while (n-&gt;parent-&gt;color == RED) { // left child subtree if (n-&gt;parent == n-&gt;parent-&gt;parent-&gt;left) { RBTreeNode y = n-&gt;parent-&gt;parent-&gt;right; // case-1 if (y-&gt;color == RED) { re_color(n-&gt;parent); n = n-&gt;parent-&gt;parent; } // case 2 else if (n == n-&gt;parent-&gt;right) { n = n-&gt;parent; left_rotation(t, n); } // case 3 else { n-&gt;parent-&gt;color = BLACK; n-&gt;parent-&gt;parent-&gt;color = RED; right_rotation(t, n-&gt;parent-&gt;parent); } } // right subtree else { RBTreeNode y = n-&gt;parent-&gt;parent-&gt;left; // case-1 if (y-&gt;color == RED) { re_color(n-&gt;parent); n = n-&gt;parent-&gt;parent; } // case 2 else if (n == n-&gt;parent-&gt;left) { n = n-&gt;parent; right_rotation(t, n); } // case 3 else { n-&gt;parent-&gt;color = BLACK; n-&gt;parent-&gt;parent-&gt;color = RED; left_rotation(t, n-&gt;parent-&gt;parent); } } } t-&gt;root-&gt;color = BLACK;} Deletion (O(lgN))删除较插入操作更为复杂一些。 // todo Related skip_list avl_tree Treap RBTree and mysql Reference geeksforgeeks r_b_tree","link":"/2020/03/13/2020-03-13-RB-Tree/"},{"title":"三体Ⅱ- 黑暗森林","text":"看完印象深刻的不是著名的“宇宙社会学”，而是结局时那个曾经给地球发过警告的三体人的一句话： 我只是想和您讨论一种可能：也许爱的萌芽在宇宙的其他地方也存在，我们应该到处鼓励她的萌发和成长。 为此我们可以冒险。对，可以冒险。","link":"/2020/03/13/2020-03-13-%E4%B8%89%E4%BD%93%E2%85%A1--%E9%BB%91%E6%9A%97%E6%A3%AE%E6%9E%97/"},{"title":"机器学习入门导论","text":"机器学习或者是人工智能入门需要较深的数学基础，如 《矩阵分析》、《数值优化》还有概率论相关的知识。后面又会涉及到 图计算，各种神经网络的模型和层出不穷的论文。这需要有一种“衣带渐宽终不悔，为伊消得人憔悴”的精神。下面写出一些学习用的书单 （持续更新…） 《机器学习》（西瓜书）《矩阵分析》《数值优化》《prml》《统计学习方法》 … 当然这也离不开扎实的计算机基础，如图论，c/c++，python等 总之，人生当仰望星空，学习当脚踏实地～～～","link":"/2020/03/13/2020-03-13-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E5%AF%BC%E8%AE%BA/"},{"title":"62. 不同路径","text":"一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 示例 1:1234567输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 示例 2:12输入: m = 7, n = 3输出: 28 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/unique-paths Solution动态规划问，递推公式为 $$F(m,n)=\\begin{cases}1,\\quad m=1 or n=1\\F(m-1,n) + F(m,n-1), \\quad m&gt;1 and n &gt; 1\\end{cases}$$ Code12345678910111213141516171819class Solution {public: int uniquePaths(int m, int n) { int maps[m+1][n+1]; fill(maps[0],maps[0]+(m+1)*(n+1),0); for(int i=1;i&lt;=m;i++){ for(int j=1;j&lt;=n;j++){ if(i==1 || j==1) maps[i][j] = 1; else{ maps[i][j] = maps[i-1][j] + maps[i][j-1]; } } } return maps[m][n]; }};","link":"/2020/03/17/2020-03-17-62.-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"},{"title":"63. 不同路径 II","text":"一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 1 和 0 来表示。 说明：m 和 n 的值均不超过 100。 示例 1:123456789101112输入:[ [0,0,0], [0,1,0], [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/unique-paths-ii Solution与上一题差不多，不同的是增加了障碍物，只需要将障碍物处设置为 0 即可；递推式为:$$F(m,n)=\\begin{cases}0,\\quad obstacleGrid[m][n] = 1\\F(m,n-1),\\quad m=1 and obstacleGrid[m][n] = 0\\F(m-1,n),\\quad n=1 and obstacleGrid[m][n] = 0\\F(m-1,n) + F(m,n-1), \\quad m&gt;1 and n &gt; 1\\end{cases}$$ Code1234567891011121314151617181920class Solution {public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) { int m = obstacleGrid.size(),n = obstacleGrid[0].size(); long maps[m][n]; fill(maps[0],maps[0]+m*n,0); for(int i=0;i&lt;m;i++){ for(int j=0;j&lt;n;j++){ if(obstacleGrid[i][j]==1) maps[i][j] = 0; else{ if(i == 0 &amp;&amp; j ==0) maps[i][j] = 1; else if(i==0) maps[i][j] = maps[i][j-1]; else if(j==0) maps[i][j] = maps[i-1][j]; else maps[i][j] = maps[i-1][j] + maps[i][j-1]; } } } return maps[m-1][n-1]; }};","link":"/2020/03/17/2020-03-17-63.-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-II/"},{"title":"1143. 最长公共子序列","text":"给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。 若这两个字符串没有公共子序列，则返回 0。 示例 1:12345678910111213输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; 输出：3 解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。示例 2:输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;输出：3解释：最长公共子序列是 &quot;abc&quot;，它的长度为 3。示例 3:输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;输出：0解释：两个字符串没有公共子序列，返回 0。 提示:1231 &lt;= text1.length &lt;= 10001 &lt;= text2.length &lt;= 1000输入的字符串只含有小写英文字符。 SolutionLCS 问题递归式 $$c(m,n)=\\begin{cases}0 ,\\quad m=0 or n =0 \\c(m-1,n-1) + 1),\\quad text1[m]=text2[n] and m &gt;0,n&gt;0 \\ max(c(m-1,n),c(m,n-1)), \\quad m&gt;0 and n &gt; 0\\end{cases}$$ Code123456789101112131415class Solution {public: int longestCommonSubsequence(string text1, string text2) { int m = text1.size(), n = text2.size(); int c[m+1][n+1]; for(int i=0;i&lt;=m;i++){ for(int j=0;j&lt;=n;j++){ if(i==0||j==0) c[i][j] = 0; else if(text1[i-1] == text2[j-1]) c[i][j] = c[i-1][j-1] + 1; else c[i][j] = max(c[i-1][j],c[i][j-1]); } } return c[m][n]; }};","link":"/2020/03/19/2020-03-19-1143.-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"},{"title":"64. 最小路径和","text":"给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例:12345678输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-path-sum Solution动态规划，递归式也很简单 $$grid(m,n)=\\begin{cases}grid(m,n) ,\\quad m=0 and n =0 \\grid(m,n) + grid(m,n-1),\\quad m=0 \\grid(m,n) + grid(m-1,n),\\quad n=0 \\grid(m,n) + min(grid(m-1,n),grid(m,n-1)), \\quad m&gt;0 and n &gt; 0\\end{cases}$$ Code123456789101112131415class Solution {public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m = grid.size(),n = grid[0].size(); for(int i=0;i&lt;m;i++){ for(int j=0;j&lt;n;j++){ if(i==0 &amp;&amp; j==0) continue; else if(i==0) grid[i][j] += grid[i][j-1]; else if(j==0) grid[i][j] += grid[i-1][j]; else grid[i][j] = grid[i][j] + min(grid[i-1][j],grid[i][j-1]); } } return grid[m-1][n-1]; }};","link":"/2020/03/17/2020-03-17-64.-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"},{"title":"72. 编辑距离","text":"给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符删除一个字符替换一个字符##示例 1: 123456输入: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出: 3解释: horse -&gt; rorse (将 'h' 替换为 'r')rorse -&gt; rose (删除 'r')rose -&gt; ros (删除 'e') ##示例 2: 12345678输入: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出: 5解释: intention -&gt; inention (删除 't')inention -&gt; enention (将 'i' 替换为 'e')enention -&gt; exention (将 'n' 替换为 'x')exention -&gt; exection (将 'n' 替换为 'c')exection -&gt; execution (插入 'u') 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/edit-distance Solutiondp[i][j] 代表 word1[i] 到 word2[j] 的最小变换 word1[i] == word2[j] i和j 同时向前移动一位 即 dp[i][j] == dp[i-1][j-1] word1[i] $\\neq$ word2[j] 此时有三种方案 替换 即令 word1[i] = word2[j] ，有 dp[i][j] == dp[i-1][j-1] + 1 删除，即删掉元素 word1[i],此时有 dp[i][j] == dp[i-1][j] + 1 插入，即在 word1 i 处插入 元素 word2[j] ，此时有 dp[i][j] == dp[i][j-1] + 1 取以上三者最小值即可 dp[i][j] = min{dp[i-1][j-1] ,dp[i-1][j] ,dp[i][j-1] }+1 Code12345678910111213141516171819class Solution {public: int minDistance(string word1, string word2){ int m = word1.size(), n =word2.size(); int dp[m+1][n+1]; for(int i=0;i&lt;=m;i++) dp[i][0] = i; for(int i=0;i&lt;=n;i++) dp[0][i] = i; for(int i=1;i&lt;=m;i++){ for(int j=1;j&lt;=n;j++){ if(word1[i-1]== word2[j-1]) dp[i][j] = dp[i-1][j-1]; else { dp[i][j] = min(min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1]) + 1; } } } return dp[m][n];}};","link":"/2020/03/19/2020-03-19-72.-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"},{"title":"1048 Find Coins (25分)","text":"Eva loves to collect coins from all over the universe, including some other planets like Mars. One day she visited a universal shopping mall which could accept all kinds of coins as payments. However, there was a special requirement of the payment: for each bill, she could only use exactly two coins to pay the exact amount. Since she has as many as 10​5​​ coins with her, she definitely needs your help. You are supposed to tell her, for any given amount of money, whether or not she can find two coins to pay for it. Input Specification:Each input file contains one test case. For each case, the first line contains 2 positive numbers: N (≤$10^5$, the total number of coins) and M (≤$10^3$) , the amount of money Eva has to pay). The second line contains N face values of the coins, which are all positive numbers no more than 500. All the numbers in a line are separated by a space. Output Specification:For each test case, print in one line the two face values $V_1$ and $V_2$​​ (separated by a space) such that $V_1 + V_2 = m$ and $V_1 &lt;= V_2$. If such a solution is not unique, output the one with the smallest $V_1$. If there is no solution, output No Solution instead. SampleInput 1:128 151 2 8 7 2 4 11 15 Output 1:14 11 Input 2:127 141 8 7 2 4 11 15 Output 2:1No Solution Solution参见 leetcode 的 Two-Sum，入门级问题 Code1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;void pat_1048(){ int n,m; cin &gt;&gt; n &gt;&gt; m; int maps[m]; fill(maps,maps+m,0); int v1 = m,coin; for(int i=0;i&lt;n;i++){ cin &gt;&gt; coin; if(m &gt; coin){ if(maps[coin]==1){ v1 = min(coin,min(m-coin,v1)); }else maps[m-coin] = 1; } } if( v1 != m ) cout &lt;&lt; v1 &lt;&lt; &quot; &quot; &lt;&lt; m-v1; else cout &lt;&lt; &quot;No Solution&quot; &lt;&lt; endl; }int main(){ pat_1048(); return 0;}","link":"/2020/03/22/2020-03-22-1048-Find-Coins-(25%E5%88%86)/"},{"title":"1030 Travel Plan (30分)","text":"A traveler’s map gives the distances between cities along the highways, together with the cost of each highway. Now you are supposed to write a program to help a traveler to decide the shortest path between his/her starting city and the destination. If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique. Input Specification:Each input file contains one test case. Each case starts with a line containing 4 positive integers N, M, S, and D, where N (≤500) is the number of cities (and hence the cities are numbered from 0 to N−1); M is the number of highways; S and D are the starting and the destination cities, respectively. Then M lines follow, each provides the information of a highway, in the format: 1City1 City2 Distance Cost where the numbers are all integers no more than 500, and are separated by a space. Output Specification:For each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output. SampleInput:1234564 5 0 30 1 1 201 3 2 300 3 4 100 2 2 202 3 1 20 Output:10 2 3 3 40 Solution最短路径问题，修改 Dijkstra 算法，记录下其 权重、代价以及 前路径即可 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;using namespace std;void pat_1030(){ int n,m,s,d; int max = 0x7fffffff; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; d; // 距离,成本，路径以及是否访问过 int distance[n],costs[n],paths[n],visited[n]; int v[n][n],c[n][n]; fill(v[0],v[0]+n*n,0); fill(distance,distance+n,max); fill(costs,costs+n,max); fill(visited,visited+n,0); fill(paths,paths+n,s); int i,x,y,dis,cost; for(i=0;i&lt;m;i++){ cin &gt;&gt; x &gt;&gt; y &gt;&gt; dis &gt;&gt; cost; v[x][y] = dis; v[y][x] = dis; c[x][y] = cost; c[y][x] = cost; } // 最短路径问题 int visit =0,cur = s,min_id=s,min; visited[cur] = 1; costs[cur] = 0; distance[cur] = 0; while(visit&lt;n &amp;&amp; cur!=d){ min = max; for(int k=0;k&lt;n;k++){ // 存在路径 if(v[cur][k] &gt; 0 &amp;&amp; !visited[k]){ dis = v[cur][k] + distance[cur]; cost = c[cur][k] + costs[cur]; if(dis &lt; distance[k] ){ distance[k] = dis; paths[k] = cur; costs[k] = cost; } else if(dis == distance[k]){ if(cost &lt; costs[k]) { costs[k] = cost; paths[k] = cur; } } } if(!visited[k] &amp;&amp; distance[k] &lt; min ){ min = distance[k]; min_id = k; } } cur = min_id; visited[cur] = 1; visit++; } int target = d; string res = to_string(d)+&quot; &quot;; while(d!=paths[d]){ res = to_string(paths[d]) + &quot; &quot; + res; d = paths[d]; } cout &lt;&lt; res &lt;&lt; distance[target] &lt;&lt; &quot; &quot; &lt;&lt; costs[target];}int main(){ pat_1030(); return 0;}","link":"/2020/03/10/2020-03-10-1030-Travel-Plan-(30%E5%88%86)/"},{"title":"123. 买卖股票的最佳时机 III","text":"给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1:12输入: [3,3,5,0,0,3,1,4]输出: 6 解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。 示例 2:12输入: [1,2,3,4,5]输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3:12输入: [7,6,4,3,1] 输出: 0 解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。 Solution递归式为 $$res = max( \\sum_{j=0}^{n-1} (profits[j]+profits-reverse[j]) )$$ 其中 $profits[j]$ 代表为 正向(0,j.) 能够获取的最大利润；$profits-reverse[j]$ 代表(j,n-1)能获取的最大利润 Code123456789101112131415161718192021222324class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int n = prices.size(); if(n&lt;=1) return 0; int profits[n]; fill(profits,profits+n,0); int less = prices[0]; for(int i=1;i&lt;n;i++){ profits[i] = max(prices[i]-less,profits[i-1]); less = min(less,prices[i]); } int res = profits[n-1],last,ma = prices[n-1]; profits[n-1] = 0; for(int j=n-2;j&gt;=0;j--){ last = profits[j]; profits[j] = max(profits[j+1],ma - prices[j]); ma = max(ma,prices[j]); res = max(res,last + profits[j]); } return res; }};","link":"/2020/03/22/2020-03-22-123.-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-III/"},{"title":"208. 实现 Trie (前缀树)","text":"实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。 示例: 12345678Trie trie = new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;); // 返回 truetrie.search(&quot;app&quot;); // 返回 falsetrie.startsWith(&quot;app&quot;); // 返回 truetrie.insert(&quot;app&quot;); trie.search(&quot;app&quot;); // 返回 true 说明: 你可以假设所有的输入都是由小写字母 a-z 构成的。保证所有输入均为非空字符串。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/implement-trie-prefix-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Node{public: char c; map&lt;char, Node&gt; next; int end; Node(char c) { this-&gt;c = c; this-&gt;end = 0; } Node(){};};class Trie{public: Node root; /** Initialize your data structure here. */ Trie() { root = Node(); } /** Inserts a word into the trie. */ void insert(string word) { Node *p = &amp;root; for(char c:word){ if(p-&gt;next.find(c) == p-&gt;next.end()){ p-&gt;next[c] = Node(c); } p = &amp;(p-&gt;next[c]); } p-&gt;end = 1; } /** Returns if the word is in the trie. */ bool search(string word) { Node *p = &amp;root; for(char c:word){ if(p-&gt;next.find(c) == p-&gt;next.end()) return false; p = &amp;(p-&gt;next[c]); } return p-&gt;end == 1; } /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith(string prefix) { Node *p = &amp;root; for(char c:prefix){ if(p-&gt;next.find(c) == p-&gt;next.end()) return false; p = &amp;(p-&gt;next[c]); } return true; }};/** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj-&gt;insert(word); * bool param_2 = obj-&gt;search(word); * bool param_3 = obj-&gt;startsWith(prefix); */","link":"/2020/03/24/2020-03-24-208.-%E5%AE%9E%E7%8E%B0-Trie-(%E5%89%8D%E7%BC%80%E6%A0%91)/"},{"title":"679. 24 点游戏","text":"你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。 示例 1: 123输入: [4, 1, 8, 7]输出: True解释: (8-4) * (7-1) = 24 示例 2: 12输入: [1, 2, 1, 2]输出: False 注意: 除法运算符 / 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。每个运算符对两个数进行运算。特别是我们不能用 - 作为一元运算符。例如，[1, 1, 1, 1] 作为输入时，表达式 -1 - 1 - 1 - 1 是不允许的。你不能将数字连接在一起。例如，输入为 [1, 2, 1, 2] 时，不能写成 12 + 12 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/24-game著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 Solution穷举法，列出所有可能性，边进行边对比 Code1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: bool solve(vector&lt;double&gt; nums) { if (nums.size() == 0) return false; if (nums.size() == 1) return abs(nums[0] - 24) &lt; 1e-6; for (int i = 0; i &lt; nums.size(); i++) { for (int j = 0; j &lt; nums.size(); j++) { if (i != j) { vector&lt;double&gt; nums2; for (int k = 0; k &lt; nums.size(); k++) if (k != i &amp;&amp; k != j) { nums2.push_back(nums[k]); } for (int k = 0; k &lt; 4; k++) { if (k &lt; 2 &amp;&amp; j &gt; i) continue; if (k == 0) nums2.push_back(nums[i] + nums[j]); if (k == 1) nums2.push_back(nums[i] * nums[j]); if (k == 2) nums2.push_back(nums[i] - nums[j]); if (k == 3) { if (nums[j] != 0) { nums2.push_back(nums[i] / nums[j]); } else { continue; } } if (solve(nums2)) return true; nums2.erase(nums2.end()-1); } } } } return false; } bool judgePoint24(vector&lt;int&gt;&amp; nums) { vector&lt;double&gt; nums2; for(int i=0;i&lt;nums.size();i++) nums2.push_back((double)nums[i]); return solve(nums2); }};","link":"/2020/03/24/2020-03-24-679.-24-%E7%82%B9%E6%B8%B8%E6%88%8F/"},{"title":"98. 验证二叉搜索树","text":"给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。示例 1:12345输入: 2 / \\ 1 3输出: true 示例 2:1234567输入: 5 / \\ 1 4 / \\ 3 6输出: false 解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/validate-binary-search-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 Solution二叉搜索树的中序序列为 有序序列，因此只需要进行中序遍历即可 Code123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ // 中序为有序序列class Solution {public: bool isValidBST(TreeNode* root) { TreeNode *p = root; stack&lt;TreeNode *&gt; s; TreeNode *prev = NULL, *next = NULL; while(p || !s.empty()){ while(p){ s.push(p); p = p -&gt; left; } p = s.top(); s.pop(); prev = next; next = p; if(prev &amp;&amp; next &amp;&amp; (prev-&gt;val &gt;= next-&gt;val)){ return false; } p = p-&gt;right; } return true; }};","link":"/2020/03/24/2020-03-24-98.-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"title":"99. 恢复二叉搜索树","text":"二叉搜索树中的两个节点被错误地交换。 请在不改变其结构的情况下，恢复这棵树。 示例 1:123456789101112131415输入: [1,3,null,null,2] 1 / 3 \\ 2输出: [3,1,null,null,2] 3 / 1 \\ 2 示例 2:123456789101112131415输入: [3,1,4,null,null,2] 3 / \\1 4 / 2输出: [2,1,4,null,null,3] 2 / \\1 4 / 3 进阶:使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/recover-binary-search-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 O(n) 算法Solution获取中序遍历序列，然后再排序，再遍历一次重新写入到原二叉树中 Code12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: void loop(TreeNode *root,vector&lt;int&gt; &amp;nums){ if(root){ loop(root-&gt;left,nums); nums.push_back(root-&gt;val); loop(root-&gt;right,nums); } } void recover(TreeNode *root,vector&lt;int&gt; &amp;nums){ stack&lt;TreeNode*&gt; s; int idx = 0; while(root ||!s.empty()){ while(root){ s.push(root); root = root-&gt;left; } root = s.top(); s.pop(); root-&gt;val = nums[idx++]; root = root-&gt;right; } } void recoverTree(TreeNode* root) { vector&lt;int&gt; nums; TreeNode *p = root,*head = root; loop(p,nums); sort(nums.begin(),nums.end()); recover(head,nums); }}; O(1) 算法Solution遍历的同时，找到这两个问题节点，将其值交换即可 Code1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: void recoverTree(TreeNode* root) { TreeNode *p = root; stack&lt;TreeNode*&gt; s; TreeNode *first = NULL, *prev = NULL, *second = NULL; bool invalid = false; while(p ||!s.empty()){ while(p){ s.push(p); p = p-&gt;left; } p = s.top(); s.pop(); if(prev &amp;&amp; (prev-&gt;val &gt; p-&gt;val)){ if(first == NULL) first = prev; second = p; } prev = p; p = p-&gt;right; } int tmp = second-&gt;val; second-&gt;val = first-&gt;val; first-&gt;val = tmp; }};","link":"/2020/03/24/2020-03-24-99.-%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"title":"面试题 17.15. 最长单词","text":"给定一组单词words，编写一个程序，找出其中的最长单词，且该单词由这组单词中的其他单词组合而成。若有多个长度相同的结果，返回其中字典序最小的一项，若没有符合要求的单词则返回空字符串。 示例：123输入： [&quot;cat&quot;,&quot;banana&quot;,&quot;dog&quot;,&quot;nana&quot;,&quot;walk&quot;,&quot;walker&quot;,&quot;dogwalker&quot;]输出： &quot;dogwalker&quot;解释： &quot;dogwalker&quot;可由&quot;dog&quot;和&quot;walker&quot;组成。 提示： 120 &lt;= len(words) &lt;= 1001 &lt;= len(words[i]) &lt;= 100 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-word-lcci Solution hashmap 与 递归 对于一个字符串 ，由于不知道它由几部分组成，因此只能按位分割，逐段匹配。使用 hash 的作用是为了加快匹配速度 Code 1234567891011121314151617181920212223242526272829303132333435 class Solution {public: static bool cmp(string a,string b){ if(a.size()!=b.size()) return a.size() &gt; b.size(); else return a &lt; b; } bool isCombine(map&lt;string,int&gt; &amp;maps,string str,int less,bool origin){ if(str.size() &lt; less) return false; if(maps.count(str)&gt;0 &amp;&amp; !origin) return true; for(int i=less;i&lt;= str.size()-less;i++){ if(maps.count(str.substr(0,i)) &gt; 0 &amp;&amp; isCombine(maps,str.substr(i,str.size()-i),less,false)) return true; } return false; } string longestWord(vector&lt;string&gt;&amp; words) { if(words.size() &lt; 2) return &quot;&quot;; map&lt;string,int&gt; maps; int len = words.size(); for(int i=0;i&lt; len;i++ ) maps[words[i]] = 1; sort(words.begin(),words.end(),cmp); int less = words[len-1].size(); for(int i= 0;i&lt; len -1;i++){ string word = words[i]; if(word.size() &lt; less *2) return &quot;&quot;; if(isCombine(maps,word,less,true)){ return word; } } return &quot;&quot;; }};","link":"/2020/03/24/2020-03-24-%E9%9D%A2%E8%AF%95%E9%A2%98-17.15.-%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/"},{"title":"206. 反转链表","text":"反转一个单链表。 示例: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL Solution双指针 Code12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseList(ListNode* head) { ListNode *p1 = NULL, *p2 = head; ListNode *p; while(p2){ p = p2-&gt;next; p2-&gt;next = p1; p1 = p2; p2 = p; } return p1; }};","link":"/2020/03/25/2020-03-25-206.-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"title":"Weekly Contest 83","text":"830. 较大分组的位置在一个由小写字母构成的字符串 S 中，包含由一些连续的相同字符所构成的分组。 例如，在字符串 S = “abbxxxxzyy” 中，就含有 “a”, “bb”, “xxxx”, “z” 和 “yy” 这样的一些分组。 我们称所有包含大于或等于三个连续字符的分组为较大分组。找到每一个较大分组的起始和终止位置。 最终结果按照字典顺序输出。 示例 1: 123输入: &quot;abbxxxxzzy&quot;输出: [[3,6]]解释: &quot;xxxx&quot; 是一个起始于 3 且终止于 6 的较大分组。 示例 2: 123输入: &quot;abc&quot;输出: []解释: &quot;a&quot;,&quot;b&quot; 和 &quot;c&quot; 均不是符合要求的较大分组。 示例 3: 12输入: &quot;abcdddeeeeaabbbcd&quot;输出: [[3,5],[6,9],[12,14]] 说明: 1 &lt;= S.length &lt;= 1000 Solution 这道题比较简单，只需要向后找即可,当字符变化时，判断其长度是否符合要求 Code 1234567891011121314151617181920212223class Solution {public: vector&lt;vector&lt;int&gt;&gt; largeGroupPositions(string S) { vector&lt;vector&lt;int&gt;&gt; result; if(S.size()&lt;3) return result; int num = 1,prev = 0; for(int i=1;i&lt;S.size();i++){ if(S[prev] == S[i]){ num ++; } if(S[prev] != S[i] || i == S.size()-1){ if(num &gt;=3 ) { vector&lt;int&gt; re{prev,prev+num-1}; result.push_back(re); } prev = i; num = 1; } } return result; }}; 831. 隐藏个人信息 给你一条个人信息 string S，它可能是一个邮箱地址，也可能是一个电话号码。 我们将隐藏它的隐私信息，通过如下规则: 1. 电子邮箱 定义名称 是长度大于等于 2 （length ≥ 2），并且只包含小写字母 a-z 和大写字母 A-Z 的字符串。 电子邮箱地址由名称 开头，紧接着是符号 ‘@’，后面接着一个名称 ，再接着一个点号 ‘.’，然后是一个名称 。 电子邮箱地址确定为有效的，并且格式是 “name1@name2.name3“。 为了隐藏电子邮箱，所有的名称 必须被转换成小写的，并且第一个名称 的第一个字母和最后一个字母的中间的所有字母由 5 个 ‘*’ 代替。 2. 电话号码 电话号码是一串包括数字 0-9，以及 {‘+’, ‘-‘, ‘(‘, ‘)’, ‘ ‘} 这几个字符的字符串。你可以假设电话号码包含 10 到 13 个数字。 电话号码的最后 10 个数字组成本地号码，在这之前的数字组成国际号码。注意，国际号码是可选的。我们只暴露最后 4 个数字并隐藏所有其他数字。 本地号码是有格式的，并且如 “--1111” 这样显示，这里的 1 表示暴露的数字。 为了隐藏有国际号码的电话号码，像 “+111 111 111 1111”，我们以 “+--***-1111” 的格式来显示。在本地号码前面的 ‘+’ 号和第一个 ‘-‘ 号仅当电话号码中包含国际号码时存在。例如，一个 12 位的电话号码应当以 “+**-“ 开头进行显示。 注意：像 “(“，”)”，” “ 这样的不相干的字符以及不符合上述格式的额外的减号或者加号都应当被删除。 最后，将提供的信息正确隐藏后返回。 示例 1：12345输入: &quot;LeetCode@LeetCode.com&quot;输出: &quot;l*****e@leetcode.com&quot;解释： 所有的名称转换成小写, 第一个名称的第一个字符和最后一个字符中间由 5 个星号代替。因此，&quot;leetcode&quot; -&gt; &quot;l*****e&quot;。 示例 2：12345输入: &quot;AB@qq.com&quot;输出: &quot;a*****b@qq.com&quot;解释: 第一个名称&quot;ab&quot;的第一个字符和最后一个字符的中间必须有 5 个星号因此，&quot;ab&quot; -&gt; &quot;a*****b&quot;。 示例 3：1234输入: &quot;1(234)567-890&quot;输出: &quot;***-***-7890&quot;解释: 10 个数字的电话号码，那意味着所有的数字都是本地号码。 示例 4：1234输入: &quot;86-(10)12345678&quot;输出: &quot;+**-***-***-5678&quot;解释: 12 位数字，2 个数字是国际号码另外 10 个数字是本地号码 。 注意: S.length &lt;= 40。 邮箱的长度至少是 8。 电话号码的长度至少是 10。 Solution根据规则也即可 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution {public: char upToLow(char c){ if(c&gt;='A' &amp;&amp; c &lt;= 'Z') return (char)(c^0x20); else return c; } string hiddenEmail(string s){ string res; bool has = false; for(int i =0;i&lt;s.size();i++){ if(s[i] == '@'){ res = (char)upToLow(s[0]); res += &quot;*****&quot;; res = res + (char)upToLow(s[i-1]); res += &quot;@&quot;; has = true; } else if(has){ res = res + upToLow(s[i]) ; } } return res; } string hiddenPhone(string s){ int num = 0; string res; for(int i=s.size()-1;i&gt;=0;i--){ if(s[i] &gt;='0' &amp;&amp; s[i]&lt;='9'){ num ++; if(num &lt;= 4 ) res = s[i]+res; } } int k = (num-4)/3; int t = num - 3*k -4; for(int i=0;i&lt;k;i++){ res = &quot;***-&quot;+res; } if(t == 0 &amp;&amp; num &gt; 10) { res = &quot;+&quot;+res; }else if(t == 1) res = &quot;+*-&quot;+res; else if(t==2) res = &quot;+**-&quot;+res; return res; } string maskPII(string S) { if((S[0] &gt;='A' &amp;&amp; S[0] &lt;='Z') || (S[0]&gt;='a' &amp;&amp; S[0]&lt;='z')) return hiddenEmail(S); else return hiddenPhone(S); }}; 829. 连续整数求和给定一个正整数 N，试求有多少组连续正整数满足所有数字之和为 N? 示例 1: 123输入: 5输出: 2解释: 5 = 5 = 2 + 3，共有两组连续整数([5],[2,3])求和后为 5。 示例 2: 123输入: 9输出: 3解释: 9 = 9 = 4 + 5 = 2 + 3 + 4 示例 3: 123输入: 15输出: 4解释: 15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5 说明: 1 &lt;= N &lt;= 10 ^ 9 Solution这是一道数学题目，没啥技巧的 首先，连续数字可以由 2，3，4，5… k 个连续数字组成，但是 k 有要求 例如对于 输入 15 ， k 必须要$$ (15/k - (k-1)/2) … 15/k-1 、 15/k、 15/k +1 … 即 (15/k - (k-1)/2) &gt;=1 $$ 因此对于任意的整数 n，则有 $kk+k&lt;= 2n$ 而对于满足要求的 k 值， 当 $n/k == 0 &amp;&amp; k %2 !=0$ 时，肯定满足条件 当 $n/k!=0$时，计算 sum 值即可 Code12345678910111213141516171819class Solution {public: int consecutiveNumbersSum(int N) { int i=2,num = 1; int sum = 0,a; while(i*i + i &lt;= 2*N){ if(N%i == 0 &amp;&amp; i%2 != 0) num ++; else if(N%i != 0){ a = N/i; sum = i * (a - (i-1)/2) + (i-1)*i/2; if(sum == N) num++; } i++; } return num; }}; 828. 统计子串中的唯一字符我们定义了一个函数 countUniqueChars(s) 来统计字符串 s 中的唯一字符，并返回唯一字符的个数。 例如：s = “LEETCODE” ，则其中 “L”, “T”,”C”,”O”,”D” 都是唯一字符，因为它们只出现一次，所以 countUniqueChars(s) = 5 。 本题将会给你一个字符串 s ，我们需要返回 countUniqueChars(t) 的总和，其中 t 是 s 的子字符串。注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 s 的所有子字符串中的唯一字符）。 由于答案可能非常大，请将结果 mod 10 ^ 9 + 7 后再返回。 示例 1： 12345输入: &quot;ABC&quot;输出: 10解释: 所有可能的子串为：&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;AB&quot;,&quot;BC&quot; 和 &quot;ABC&quot;。 其中，每一个子串都由独特字符构成。 所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10 示例 2： 123输入: &quot;ABA&quot;输出: 8解释: 除了 countUniqueChars(&quot;ABA&quot;) = 1 之外，其余与示例 1 相同。 示例 3： 12输入：s = &quot;LEETCODE&quot;输出：92 提示： 0 &lt;= s.length &lt;= 10^4 s 只包含大写英文字符 Solution 暴力(用了 hash 和 dp 优化),穷举所有的字串，然后 就 GG了 123456789101112131415161718192021class Solution {public: int uniqueLetterString(string s) { int num = 0; for(int i=0;i&lt;s.size();i++){ int prev = 0,cur = 0, maps[26] = {0}; for(int j=i;j&lt;s.size();j++){ maps[s[j]-'A']++; if(maps[s[j]-'A'] == 1) cur++; else if(maps[s[j]-'A'] == 2) cur = prev-1; else cur = prev; num += cur; prev = cur; } } return num % 1000000007; }}; 再深入研究一下两个以上的重复字符就没有作用了，这是一个关键点 12345678910111213141516171819class Solution {public: int uniqueLetterString(string s) { map&lt;int,vector&lt;int&gt;&gt; maps; for(int i =0;i&lt;s.size();i++){ maps[s[i]-'A'].push_back(i); } int ans = 0,prev,next; for(auto &amp;p:maps){ for(int j=0;j&lt;p.second.size();j++){ prev = j==0?-1:p.second[j-1]; next = j== p.second.size()-1?s.size():p.second[j+1]; ans += (p.second[j]-prev)*(next - p.second[j]); } } return ans%1000000007; }}; 来源：力扣（LeetCode）著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","link":"/2020/03/25/2020-03-25-Weekly-Contest-83/"},{"title":"820. 单词的压缩编码","text":"给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。 例如，如果这个列表是 [“time”, “me”, “bell”]，我们就可以将其表示为 S = “time#bell#” 和 indexes = [0, 2, 5]。 对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 “#” 结束，来恢复我们之前的单词列表。 那么成功对给定单词列表进行编码的最小字符串长度是多少呢？ 示例：123输入: words = [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]输出: 10说明: S = &quot;time#bell#&quot; ， indexes = [0, 2, 5] 。 提示： 1 &lt;= words.length &lt;= 2000 1 &lt;= words[i].length &lt;= 7 每个单词都是小写字母 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/short-encoding-of-words著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 Solution采用字典树，字符串反向存储 12345678910 root / \\ e L | |m L | | i e | | t b Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Node{ public: char c; map&lt;char,Node&gt; next; int index; bool leaf; Node(char c){this-&gt;c = c;}; Node(){};};class Solution {public: // 插入 void insert(Node *root,string word){ int len = word.size(); Node *p = root; int index = 0; for(int i = len-1;i&gt;=0;i--){ if(p-&gt;next.count(word[i]) == 0){ Node node = Node(word[i]); node.index = len - i; p-&gt;next[word[i]] = node; } p-&gt;leaf = false; p = &amp;(p-&gt;next[word[i]]); } if(p-&gt;next.size() == 0 ) p-&gt;leaf = true; } // 层序遍历 int getSum(Node *root){ int sum = 0; queue&lt;Node *&gt; q; q.push(root); while(!q.empty()){ Node *node = q.front(); if(node-&gt;leaf){ sum += (node-&gt;index+1); } q.pop(); for(auto &amp;it:node-&gt;next){ q.push(&amp;(it.second)); } } return sum; } int minimumLengthEncoding(vector&lt;string&gt;&amp; words) { if(words.size()==1) return words[0].size()+1; Node *root = new Node(); int res = 0; for(int i=0;i&lt;words.size();i++){ insert(root,words[i]); } return getSum(root); }};","link":"/2020/03/28/2020-03-28-820.-%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/"},{"title":"1162. 地图分析","text":"你现在手里有一份大小为 N x N 的『地图』（网格） grid，上面的每个『区域』（单元格）都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，你知道距离陆地区域最远的海洋区域是是哪一个吗？请返回该海洋区域到离它最近的陆地区域的距离。 我们这里说的距离是『曼哈顿距离』（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个区域之间的距离是 |x0 - x1| + |y0 - y1| 。 如果我们的地图上只有陆地或者海洋，请返回 -1。 示例 1： 1234输入：[[1,0,1],[0,0,0],[1,0,1]]输出：2解释： 海洋区域 (1, 1) 和所有陆地区域之间的距离都达到最大，最大距离为 2。 示例 2： 1234输入：[[1,0,0],[0,0,0],[0,0,0]]输出：4解释： 海洋区域 (2, 2) 和所有陆地区域之间的距离都达到最大，最大距离为 4。 提示： 1 &lt;= grid.length == grid[0].length &lt;= 100 grid[i][j] 不是 0 就是 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/as-far-from-land-as-possible著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 Solution多源 BFS ,从陆地出发，进行 bfs 遍历，记录其层数即可 Code123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: int maxDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m = grid.size(), n = grid[0].size(); queue&lt;vector&lt;int&gt;&gt; q; int visited[100][100] = {0}; int num = 0; // 找到所有的 陆地 for(int i=0;i&lt;m;i++){ for(int j=0;j&lt;n;j++){ if(grid[i][j]){num++;q.push({i,j});visited[i][j] = 1;} } } if(num ==0 || num == m*n) return -1; vector&lt;int&gt; dot; int x,y, dx[4] = {1,-1,0,0},dy[4] = {0,0,1,-1}; int res = -1,size,i,j; while(!q.empty()){ size = q.size(); for(i=0;i&lt;size;i++){ dot = q.front(); q.pop(); for(j=0;j&lt;4;j++){ x = dx[j] + dot[0]; y = dy[j] + dot[1]; // 找到尚未访问过的海洋节点 if(x &gt;=0 &amp;&amp; x&lt; m &amp;&amp; y&gt;=0 &amp;&amp; y&lt; n &amp;&amp; !visited[x][y]){ q.push({x,y}); visited[x][y] = 1; } } } // 距离 + 1 res ++; } return res; }};","link":"/2020/03/29/2020-03-29-1162.-%E5%9C%B0%E5%9B%BE%E5%88%86%E6%9E%90/"},{"title":"1306. 跳跃游戏 III","text":"这里有一个非负整数数组 arr，你最开始位于该数组的起始下标 start 处。当你位于下标 i 处时，你可以跳到 i + arr[i] 或者 i - arr[i]。 请你判断自己是否能够跳到对应元素值为 0 的 任意 下标处。 注意，不管是什么情况下，你都无法跳到数组之外。 示例 1：123456输入：arr = [4,2,3,0,3,1,2], start = 5输出：true解释：到达值为 0 的下标 3 有以下可能方案： 下标 5 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3 下标 5 -&gt; 下标 6 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3 示例 2：12345输入：arr = [4,2,3,0,3,1,2], start = 0输出：true 解释：到达值为 0 的下标 3 有以下可能方案： 下标 0 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3 示例 3：123输入：arr = [3,0,2,1,2], start = 2输出：false解释：无法到达值为 0 的下标 1 处。 提示： 1 &lt;= arr.length &lt;= 5 * 10^4 0 &lt;= arr[i] &lt; arr.length 0 &lt;= start &lt; arr.length 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/jump-game-iii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 SolutionBFS Code123456789101112131415161718192021222324252627282930class Solution {public: bool canReach(vector&lt;int&gt;&amp; arr, int start) { int n = arr.size(), visited[n]; fill(visited,visited+n,0); queue&lt;int&gt; q; q.push(start); visited[start] = 1; int t,left,right; while(!q.empty()){ t = q.front(); q.pop(); if(arr[t] == 0) return true; left = t+arr[t]; right = t-arr[t]; if(left &gt;=0 &amp;&amp; left &lt; n &amp;&amp; !visited[left]){ q.push(left); visited[left] = 1; } if(right &gt;=0 &amp;&amp; right &lt; n &amp;&amp; !visited[right]){ q.push(right); visited[right] = 1; } } return false; }};","link":"/2020/04/04/2020-04-04-1306.-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-III/"},{"title":"1334. 阈值距离内邻居最少的城市","text":"有 n 个城市，按从 0 到 n-1 编号。给你一个边数组 edges，其中 edges[i] = [fromi, toi, weighti] 代表 fromi 和 toi 两个城市之间的双向加权边，距离阈值是一个整数 distanceThreshold。 返回能通过某些路径到达其他城市数目最少、且路径距离 最大 为 distanceThreshold 的城市。如果有多个这样的城市，则返回编号最大的城市。 注意，连接城市 i 和 j 的路径的距离等于沿该路径的所有边的权重之和。 示例 1：123456789输入：n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4输出：3解释：城市分布图如上。每个城市阈值距离 distanceThreshold = 4 内的邻居城市分别是：城市 0 -&gt; [城市 1, 城市 2] 城市 1 -&gt; [城市 0, 城市 2, 城市 3] 城市 2 -&gt; [城市 0, 城市 1, 城市 3] 城市 3 -&gt; [城市 1, 城市 2] 城市 0 和 3 在阈值距离 4 以内都有 2 个邻居城市，但是我们必须返回城市 3，因为它的编号最大。 示例 2：12345678910输入：n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2输出：0解释：城市分布图如上。 每个城市阈值距离 distanceThreshold = 2 内的邻居城市分别是：城市 0 -&gt; [城市 1] 城市 1 -&gt; [城市 0, 城市 4] 城市 2 -&gt; [城市 3, 城市 4] 城市 3 -&gt; [城市 2, 城市 4]城市 4 -&gt; [城市 1, 城市 2, 城市 3] 城市 0 在阈值距离 4 以内只有 1 个邻居城市。 提示： 2 &lt;= n &lt;= 100 1 &lt;= edges.length &lt;= n * (n - 1) / 2 edges[i].length == 3 0 &lt;= fromi &lt; toi &lt; n 1 &lt;= weighti, distanceThreshold &lt;= 10^4 所有 (fromi, toi) 都是不同的。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 SolutionDijkstra 算法，多次使用 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution {public: int findTheCity(int n, vector&lt;vector&lt;int&gt; &gt;&amp; edges, int distanceThreshold) { int res = -1, city = 0; int curCity = 0; int visited[n],t,w,cur,num,p,min_id; // fill(v[0],v[0]+n*n,0); vector&lt;vector&lt;int&gt; &gt; v(n,vector&lt;int&gt;(n,0)); for(int i=0;i&lt;edges.size();i++){ v[edges[i][0]][edges[i][1]] = edges[i][2]; v[edges[i][1]][edges[i][0]] = edges[i][2]; } // dijkstra for(int i=0;i&lt;n;i++){ curCity = 0; vector&lt;int&gt; dis(n,0x7fffffff); fill(visited,visited+n,0); cur = i; visited[cur] = 1; dis[cur] = 0; num = 0; while(num &lt; n){ p = 0x7fffffff; min_id = -1; for(int j=0;j&lt;n;j++){ if(!visited[j] &amp;&amp; v[cur][j] &gt; 0){ w = dis[cur] + v[cur][j]; dis[j] = min(w,dis[j]); // if(dis[j] &lt; distanceThreshold) // curCity ++; } if(!visited[j] &amp;&amp; dis[j] &lt; p){ p = dis[j]; min_id = j; } } if(min_id != -1){ num ++; cur = min_id; visited[cur] = 1; }else break; } for(int j=0;j&lt;n;j++){ if(j!=i &amp;&amp; dis[j] &lt;= distanceThreshold) curCity++; } if(res == -1 || curCity &lt;= city) {city= curCity, res = i;} } return res; }};","link":"/2020/04/04/2020-04-04-1334.-%E9%98%88%E5%80%BC%E8%B7%9D%E7%A6%BB%E5%86%85%E9%82%BB%E5%B1%85%E6%9C%80%E5%B0%91%E7%9A%84%E5%9F%8E%E5%B8%82/"},{"title":"207. 课程表","text":"你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1] 给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？ 示例 1:123输入: 2, [[1,0]] 输出: true解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。 示例 2:123输入: 2, [[1,0],[0,1]]输出: false解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。 提示： 输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。 你可以假定输入的先决条件中没有重复的边。 1 &lt;= numCourses &lt;= 10^5 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/course-schedule著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 Solution 拓扑排序 DFS 判断有环 Code 拓扑排序12345678910111213141516171819202122232425262728293031323334353637 class Solution {public: bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) { int d[numCourses]; fill(d,d+numCourses,0); vector&lt;int&gt; v[numCourses]; int x,y; for(int i=0;i&lt;prerequisites.size();i++){ x = prerequisites[i][0], y = prerequisites[i][1]; d[y] ++; v[x].push_back(y); } int point = -1,k = numCourses,ds = 0; while(k &gt; 0){ point = -1; // 找到 拓扑排序的起点 for(int i = 0;i&lt;numCourses;i++){ if(d[i] == 0){ point = i; d[i] = -1; ds ++; break; } } if(point == -1 &amp;&amp; k &gt; 1 ) return false; else if(point == -1) return true; // 去掉 顶点 point for(int i=0;i &lt; v[point].size();i++){ y = v[point][i]; d[y]--; } v[point].clear(); k--; } return ds == numCourses; }}; DFS 判断是否有环 123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: bool hasCycle(vector&lt;vector&lt;int&gt;&gt;&amp; v, int idx,vector&lt;int&gt;&amp; visited,vector&lt;int&gt;&amp; localvisited){ // 缓存 if(visited[idx]) return false; localvisited[idx] = 1; visited[idx] = 1; for(int i = 0; i&lt; v[idx].size(); i++){ if(localvisited[v[idx][i]]) return true; else if(hasCycle(v,v[idx][i],visited,localvisited)) return true; } localvisited[idx] = 0; return false; } bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) { // 拓扑排序 // 采用邻接表表示有向图 vector&lt;vector&lt;int&gt;&gt; v; for(int i=0;i&lt;numCourses;i++){ v.push_back({}); } for(int i =0 ; i&lt;prerequisites.size(); i++){ v[prerequisites[i][0]].push_back(prerequisites[i][1]); } // 是否访问过 vector&lt;int&gt; visited(numCourses,0); vector&lt;int&gt; localvisited(numCourses,0); for(int i=0;i&lt;numCourses;i++){ if(hasCycle(v,i,visited,localvisited)) return false; } return true; }}","link":"/2020/04/04/2020-04-04-207.-%E8%AF%BE%E7%A8%8B%E8%A1%A8/"},{"title":"面试题 04.01. 节点间通路","text":"节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。 示例1:12输入：n = 3, graph = [[0, 1], [0, 2], [1, 2], [1, 2]], start = 0, target = 2输出：true 示例2: 12输入：n = 5, graph = [[0, 1], [0, 2], [0, 4], [0, 4], [0, 1], [1, 3], [1, 4], [1, 3], [2, 3], [3, 4]], start = 0, target = 4输出 true 提示： 节点数量n在[0, 1e5]范围内。 节点编号大于等于 0 小于 n。 图中可能存在自环和平行边。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/route-between-nodes-lcci著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 Solution DFS BFS Code DFS12345678910111213141516171819202122232425262728293031class Solution {public: bool findWhetherExistsPath(int n, vector&lt;vector&lt;int&gt;&gt;&amp; graph, int start, int target) { vector&lt;int&gt; visited(n,0); vector&lt;int&gt; v[n]; for(int i=0;i&lt;graph.size();i++){ v[graph[i][0]].push_back(graph[i][1]); } stack&lt;int&gt; s; s.push(start); visited[start] = 1; int k, flag; while(!s.empty()){ k = s.top(); flag = 0; if(k == target) return true; for(int j=0;j&lt;v[k].size();j++){ if(visited[v[k][j]] == 0){ s.push(v[k][j]); flag = 1; visited[v[k][j]] = 1; break; } } if(!flag) s.pop(); } return false; }}; BFS12345678910111213141516171819202122232425262728class Solution {public: bool findWhetherExistsPath(int n, vector&lt;vector&lt;int&gt;&gt;&amp; graph, int start, int target) { vector&lt;int&gt; visited(n,0); vector&lt;int&gt; v[n]; for(int i=0;i&lt;graph.size();i++){ v[graph[i][0]].push_back(graph[i][1]); } queue&lt;int&gt; q; q.push(start); visited[start] = 1; int k; while(!q.empty()){ k = q.front(); if(k == target) return true; q.pop(); for(auto t : v[k]){ if(visited[t]==0){ visited[t] = 1; q.push(t); } } } return false; }};","link":"/2020/04/04/2020-04-04-%E9%9D%A2%E8%AF%95%E9%A2%98-04.01.-%E8%8A%82%E7%82%B9%E9%97%B4%E9%80%9A%E8%B7%AF/"},{"title":"322. 零钱兑换","text":"给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例 1:123输入: coins = [1, 2, 5], amount = 11输出: 3 解释: 11 = 5 + 5 + 1 示例 2:12输入: coins = [2], amount = 3输出: -1 说明:你可以认为每种硬币的数量是无限的。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/coin-change著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 Solution动态规划 Code123456789101112131415161718class Solution {public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { int dp[amount+1]; fill(dp,dp+amount+1,0); int c; for(int i=1;i&lt;=amount;i++){ c = -1; for(int j=0;j&lt;coins.size();j++){ if(i &gt;= coins[j]){ if((c==-1 || (c &gt; dp[i-coins[j]])) &amp;&amp; dp[i-coins[j]] &gt;= 0) c = dp[i-coins[j]]; } } dp[i] = c!=-1 ? c+1:-1; } return dp[amount] &gt;= 0 ?dp[amount]:-1; }};","link":"/2020/04/07/2020-04-07-322.-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"},{"title":"The world this week Politics","text":"Trump and America1. Trunmp mooted guidelines to reopen the economyDonald Trump said that America was past the peak of covid-19 outbreak, as he mooted guidelines to reopen the economy. However, when a journalist asked Mr Trump what he had done all February to prepare for covid, he called her “disgraceful”; 2. The funding to the WHO will be suspendedAccusing it of pushing “China’s misinformation” on the coronavirus, Mr Trump said he would suspend American funding to the World Health Organisation. 3. Bernie Sanders bowed out the 2020 persidential compaignMr Bernie is endorsing Mr Biden now so they can unite the Democratic Party in trying the defeat Mr Trump in November’s election","link":"/2020/04/25/2020-04-25-The-world-this-week-Politics/"},{"title":"Is China Winning ?","text":"The geopolitical consequences of covid-19 will be long-lasting and unfortunate","link":"/2020/04/26/2020-04-26-Is-China-Winning-0/"},{"title":"每日一题","text":"高清大图","link":"/2020/04/30/2020-04-30-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"title":"劝学篇第一","text":"近日，无学习之动力，无学习之毅力，品荀子名篇以自励，望学不可以已 劝学 荀子 君子曰：学不可以已。 青、取之于蓝，而青于蓝；冰、水为之，而寒于水。木直中绳，輮以为轮，其曲中规，虽有槁暴，不复挺者，輮使之然也。故木受绳则直，金就砺则利，君子博学而日参省乎己，则知明而行无过矣。故不登高山，不知天之高也；不临深溪，不知地之厚也；不闻先王之遗言，不知学问之大也。干、越、夷、貉之子，生而同声，长而异俗，教使之然也。诗曰：“嗟尔君子，无恒安息。靖共尔位，好是正直。神之听之，介尔景福。”神莫大于化道，福莫长于无祸。 吾尝终日而思矣，不如须臾之所学也。吾尝跂而望矣，不如登高之博见也。登高而招，臂非加长也，而见者远；顺风而呼，声非加疾也，而闻者彰。假舆马者，非利足也，而致千里；假舟楫者，非能水也，而绝江河。君子生非异也，善假于物也。 南方有鸟焉，名曰蒙鸠，以羽为巢，而编之以发，系之苇苕，风至苕折，卵破子死。巢非不完也，所系者然也。西方有木焉，名曰射干，茎长四寸，生于高山之上，而临百仞之渊，木茎非能长也，所立者然也。蓬生麻中，不扶而直；白沙在涅，与之俱黑。兰槐之根是为芷，其渐之滫，君子不近，庶人不服。其质非不美也，所渐者然也。故君子居必择乡，游必就士，所以防邪辟而近中正也。 物类之起，必有所始。荣辱之来，必象其德。肉腐出虫，鱼枯生蠹。怠慢忘身，祸灾乃作。强自取柱，柔自取束。邪秽在身，怨之所构。施薪若一，火就燥也，平地若一，水就湿也。草木畴生，禽兽群焉，物各从其类也。是故质的张，而弓矢至焉；林木茂，而斧斤至焉；树成荫，而众鸟息焉。醯酸，而蚋聚焉。故言有招祸也，行有招辱也，君子慎其所立乎！ 积土成山，风雨兴焉；积水成渊，蛟龙生焉；积善成德，而神明自得，圣心备焉。故不积蹞步，无以致千里；不积小流，无以成江海。骐骥一跃，不能十步；驽马十驾，功在不舍。锲而舍之，朽木不折；锲而不舍，金石可镂。螾无爪牙之利，筋骨之强，上食埃土，下饮黄泉，用心一也。蟹八跪而二螯，非蛇蟺之穴，无可寄托者，用心躁也。是故无冥冥之志者，无昭昭之明；无惛惛之事者，无赫赫之功。行衢道者不至，事两君者不容。目不能两视而明，耳不能两听而聪。螣蛇无足而飞，梧鼠五技而穷。诗曰：“尸鸠在桑，其子七兮。淑人君子，其仪一兮。其仪一兮，心如结兮。”故君子结于一也。 昔者瓠巴鼓瑟，而流鱼出听；伯牙鼓琴，而六马仰秣。故声无小而不闻，行无隐而不形。玉在山而草木润，渊生珠而崖不枯。为善不积邪，安有不闻者乎！ 学恶乎始？恶乎终？曰：其数则始乎诵经，终乎读礼；其义则始乎为士，终乎为圣人。真积力久则入。学至乎没而后止也。故学数有终，若其义则不可须臾舍也。为之人也，舍之禽兽也。故书者、政事之纪也；诗者、中声之所止也；礼者、法之大兮，类之纲纪也。故学至乎礼而止矣。夫是之谓道德之极。礼之敬文也，乐之中和也，诗书之博也，春秋之微也，在天地之间者毕矣。 君子之学也，入乎耳，着乎心，布乎四体，形乎动静。端而言，蝡而动，一可以为法则。小人之学也，入乎耳，出乎口；口耳之间，则四寸耳，曷足以美七尺之躯哉！古之学者为己，今之学者为人。君子之学也，以美其身；小人之学也，以为禽犊。故不问而告谓之傲，问一而告二谓之囋。傲、非也，囋、非也；君子如向矣。 学莫便乎近其人。礼乐法而不说，诗书故而不切，春秋约而不速。方其人之习君子之说，则尊以遍矣，周于世矣。故曰：学莫便乎近其人。 学之经莫速乎好其人，隆礼次之。上不能好其人，下不能隆礼，安特将学杂识志，顺诗书而已耳。则末世穷年，不免为陋儒而已。将原先王，本仁义，则礼正其经纬蹊径也。若挈裘领，诎五指而顿之，顺者不可胜数也。不道礼宪，以诗书为之，譬之犹以指测河也，以戈舂黍也，以锥餐壶也，不可以得之矣。故隆礼，虽未明，法士也；不隆礼，虽察辩，散儒也。 问楛者，勿告也；告楛者，勿问也；说楛者，勿听也。有争气者，勿与辩也。故必由其道至，然后接之；非其道则避之。故礼恭，而后可与言道之方；辞顺，而后可与言道之理；色从而后可与言道之致。故未可与言而言，谓之傲；可与言而不言，谓之隐；不观气色而言，谓瞽。故君子不傲、不隐、不瞽，谨顺其身。诗曰：“匪交匪舒，天子所予。”此之谓也。 百发失一，不足谓善射；千里蹞步不至，不足谓善御；伦类不通，仁义不一，不足谓善学。学也者，固学一之也。一出焉，一入焉，涂巷之人也；其善者少，不善者多，桀纣盗跖也；全之尽之，然后学者也。 君子知夫不全不粹之不足以为美也，故诵数以贯之，思索以通之，为其人以处之，除其害者以持养之。使目非是无欲见也，使口非是无欲言也，使心非是无欲虑也。及至其致好之也，目好之五色，耳好之五声，口好之五味，心利之有天下。是故权利不能倾也，群众不能移也，天下不能荡也。生乎由是，死乎由是，夫是之谓德操。德操然后能定，能定然后能应。能定能应，夫是之谓成人。天见其明，地见其光，君子贵其全也。","link":"/2020/05/01/2020-05-01-%E5%8A%9D%E5%AD%A6%E7%AF%87%E7%AC%AC%E4%B8%80/"},{"title":"1092 To Buy or Not to Buy (20分)","text":"Eva would like to make a string of beads with her favorite colors so she went to a small shop to buy some beads. There were many colorful strings of beads. However the owner of the shop would only sell the strings in whole pieces. Hence Eva must check whether a string in the shop contains all the beads she needs. She now comes to you for help: if the answer is Yes, please tell her the number of extra beads she has to buy; or if the answer is No, please tell her the number of beads missing from the string. For the sake of simplicity, let’s use the characters in the ranges [0-9], [a-z], and [A-Z] to represent the colors. For example, the 3rd string in Figure 1 is the one that Eva would like to make. Then the 1st string is okay since it contains all the necessary beads with 8 extra ones; yet the 2nd one is not since there is no black bead and one less red bead. Figure 1 Input Specification:Each input file contains one test case. Each case gives in two lines the strings of no more than 1000 beads which belong to the shop owner and Eva, respectively. Output Specification:For each test case, print your answer in one line. If the answer is Yes, then also output the number of extra beads Eva has to buy; or if the answer is No, then also output the number of beads missing from the string. There must be exactly 1 space between the answer and the number. Sample Input 1:12ppRYYGrrYBR2258YrR8RrY Sample Output 1:1Yes 8 Sample Input 2:12ppRYYGrrYB225YrR8RrY Sample Output 2:1No 2 Solution题目比较简单，只要分别统计各字符的数量，然后判断是否符合需求即可。 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;map&lt;char,int&gt; getCount(string s1){ map&lt;char,int&gt; count; for(char c : s1){ count[c]++; } return count;}void pat_1092(){ string s1,s2; cin &gt;&gt; s1 &gt;&gt; s2; map&lt;char,int&gt; count1 = getCount(s1); map&lt;char,int&gt; count2 = getCount(s2); int res = 0; for(auto &amp;p : count2){ if(count1[p.first] &lt; p.second){ res += (p.second - count1[p.first]); } } if(res &gt; 0) printf(&quot;No %d\\n&quot;,res); else printf(&quot;Yes %d\\n&quot;,(int)(s1.size() - s2.size()));; }int main(){ pat_1092(); return 0;}","link":"/2020/05/02/2020-05-02-1092-To-Buy-or-Not-to-Buy-(20%E5%88%86)/"},{"title":"1316. 不同的循环子字符串","text":"给你一个字符串 text ，请你返回满足下述条件的 不同 非空子字符串的数目： 可以写成某个字符串与其自身相连接的形式（即，可以写为 a + a，其中 a 是某个字符串）。例如，abcabc 就是 abc 和它自身连接形成的。 示例 1：123输入：text = &quot;abcabcabc&quot;输出：3解释：3 个子字符串分别为 &quot;abcabc&quot;，&quot;bcabca&quot; 和 &quot;cabcab&quot; 。 示例 2： 123输入：text = &quot;leetcodeleetcode&quot;输出：2解释：2 个子字符串为 &quot;ee&quot; 和 &quot;leetcodeleetcode&quot; 。 提示： 1 &lt;= text.length &lt;= 2000 text 只包含小写英文字母。 Solution 暴力(复杂度 O(n^3) 超时) 暴力枚举所有字串，然后核对是否符合条件，使用 hash 表来排重 1234567891011121314151617181920212223242526class Solution {public: string check(string a){ int n = a.size(); if(n % 2 !=0 ) return &quot;&quot;; else return a.substr(0,n/2) == a.substr(n/2,n/2) ? a : &quot;&quot;; } int distinctEchoSubstrings(string text) { int n= text.size(); int ans = 0; string res; map&lt;string,bool&gt; maps; for(int i=0;i&lt;n;i++){ for(int j=i+1;j&lt;n;j++){ res = check(text.substr(i,j-i+1)); if(res.size() &gt; 0 &amp;&amp; !maps[res]){ maps[res] = true; ans ++; } } } return ans; }}; 由于字符串的比较最坏是 O(N) 因此时间复杂度过高，导致 ac 失败 暴力优化 （O(n^2) 1234567891011121314151617181920212223242526272829303132333435363738394041using LL = long long;class Solution {private: constexpr static int mod = (int)1e9 + 7; public: int gethash(const vector&lt;int&gt;&amp; pre, const vector&lt;int&gt;&amp; mul, int l, int r) { return (pre[r + 1] - (LL)pre[l] * mul[r - l + 1] % mod + mod) % mod; } int distinctEchoSubstrings(string text) { int n = text.size(); int base = 31; vector&lt;int&gt; pre(n + 1), mul(n + 1); pre[0] = 0; mul[0] = 1; for (int i = 1; i &lt;= n; ++i) { pre[i] = ((LL)pre[i - 1] * base + text[i - 1]) % mod; mul[i] = (LL)mul[i - 1] * base % mod; } unordered_set&lt;int&gt; seen[n]; int ans = 0; for (int i = 0; i &lt; n; ++i) { for (int j = i + 1; j &lt; n; ++j) { int l = j - i; if (j + l &lt;= n) { int hash_left = gethash(pre, mul, i, j - 1); if (!seen[l - 1].count(hash_left) &amp;&amp; hash_left == gethash(pre, mul, j, j + l - 1)) { ++ans; seen[l - 1].insert(hash_left); } } } } return ans; }};","link":"/2020/05/05/2020-05-05-1316.-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"一道背包问题的变种","text":"题目描述一个数组中有若干正整数，将此数组划分为两个子数组，使得两个子数组各元素之和a,b的差最小，对于非法输入应该输出ERROR。 输入描述:数组中的元素 输出描述:降序输出两个子数组的元素和 示例1输入 1210 20 30 10 1010 20 abc 10 10 输出 1240 40ERROR Solution链接：https://www.nowcoder.com/questionTerminal/aea0458d54d74f3ca14012cbdf249918?f=discussion来源：牛客网 背包问题 有 a + b = sum; a &gt;= b;则 b &lt;= sum/2 因此可以转化为 问题对于给定的序列 nums, 能够构成 1—-sum/2 问题 然后取得最大的能够构成的 b 即可 就是不知道输入为啥👨‍🏫出错 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std; // dp 0-1 背包问题void package(vector&lt;int&gt; &amp;nums){ int n = nums.size() , sum = 0; for(int num : nums) sum += num; int target = sum/2; // 不能重复时 vector&lt;bool&gt; dp(target + 1, 0); dp[0] = true; for(int num : nums){ for(int i = target; i &gt;= num ; i--){ dp[i] = dp[i] || dp[i-num]; } } int b = 0; for(int i= target; i &gt;= 0; i--){ if(dp[i]) {b = i; break;} } printf(&quot;%d %d\\n&quot;,b,sum-b);} int main(){ string str ; while (getline(cin,str)) { bool ok = true; for (int i = 0; i &lt; str.size(); i++) { if (str[i] != ' ' &amp;&amp; !(str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9')) { ok = false; break; } } if (!ok) { cout &lt;&lt; &quot;ERROR&quot; &lt;&lt; endl; continue; } vector&lt;int&gt; nums; int prev = 0; for (int i = 0; i &lt; str.size(); i++) { char c = str[i]; if (c == ' ' ) { nums.push_back(stoi(str.substr(prev,i-prev))); prev = i + 1; } } nums.push_back(stoi(str.substr(prev,str.size()-prev))); package(nums); } return 0;","link":"/2020/05/06/2020-05-06-%E4%B8%80%E9%81%93%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%98%E7%A7%8D/"},{"title":"677. 键值映射","text":"实现一个 MapSum 类里的两个方法，insert 和 sum。 对于方法 insert，你将得到一对（字符串，整数）的键值对。字符串表示键，整数表示值。如果键已经存在，那么原来的键值对将被替代成新的键值对。 对于方法 sum，你将得到一个表示前缀的字符串，你需要返回所有以该前缀开头的键的值的总和。 示例 1:1234输入: insert(&quot;apple&quot;, 3), 输出: Null输入: sum(&quot;ap&quot;), 输出: 3输入: insert(&quot;app&quot;, 2), 输出: Null输入: sum(&quot;ap&quot;), 输出: 5 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/map-sum-pairs著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 Solution字典树结构 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//字典树节点class Node{ public: char data; int val; bool leaf; map&lt;char,Node&gt; next; Node(char c){ data = c; leaf = false; } Node(){};};class MapSum {public: Node root; /** Initialize your data structure here. */ MapSum() { root = Node(); } void insert(string key, int val) { Node *trie = &amp;root; int i =0,n = key.size(); char c; while(i &lt; n){ c = key[i]; if(!trie-&gt;next.count(c)){ trie-&gt;next[c] = Node(c); } trie = &amp;trie-&gt;next[c]; i++; } trie-&gt;val = val; trie-&gt;leaf = true; } // 递归求和 int trave(Node *trie){ int ans = 0; if(trie-&gt;leaf) {ans += trie-&gt;val;} for(auto &amp;p:trie-&gt;next){ Node *t = &amp;(p.second); ans += trave(t); } return ans; } int sum(string prefix) { Node *trie = &amp;root; int ans = 0; int i =0, n = prefix.size(); char c; while( i &lt; n){ c = prefix[i]; if(!trie-&gt;next.count(c)) return 0; trie = &amp;trie-&gt;next[c]; i++; } return trave(trie); }};/** * Your MapSum object will be instantiated and called as such: * MapSum* obj = new MapSum(); * obj-&gt;insert(key,val); * int param_2 = obj-&gt;sum(prefix); */","link":"/2020/05/07/2020-05-07-677.-%E9%94%AE%E5%80%BC%E6%98%A0%E5%B0%84/"},{"title":"51. N皇后","text":"n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 上图为 8 皇后问题的一种解法。 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 示例:输入: 4 1234567891011输出: [ [&quot;.Q..&quot;, // 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]] 解释: 4 皇后问题存在两个不同的解法。 提示： 皇后，是国际象棋中的棋子，意味着国王的妻子。皇后只做一件事，那就是“吃子”。当她遇见可以吃的棋子时，就迅速冲上去吃掉棋子。当然，她横、竖、斜都可走一或七步，可进可退。（引用自 百度百科 - 皇后 ） 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/n-queens著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 Solution暴力枚举，首先 对于 n*n 的 n 皇后问题，肯定不会出现同一列和同一行存在两个棋子的机会，因此 每个棋子肯定为独占一行或者一列。可以一行一行的进行填充，知道不会出现冲突，其时间复杂度为 O(n!) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution {public: vector&lt;vector&lt;string&gt;&gt; ans; void traceback(vector&lt;string&gt; &amp;checked,int x,int n){ if( x == n ) { ans.push_back(checked); return; } for(int i=0;i&lt;n;i++){ if(!check(checked,n,x,i)){ continue; } checked[x][i] = 'Q'; traceback(checked,x+1,n); checked[x][i] = '.'; } } bool check(vector&lt;string&gt; &amp;checked,int n,int x, int y){ // 核查其作用域上是否有棋子，有的话就返回false for(int i=0;i&lt;n;i++){ // 纵向 if(checked[i][y] == 'Q') return false; } // 斜线 、、、 for(int i=x-1,j=y-1;i&gt;=0 &amp;&amp; j &gt;=0;i--,j--){ if(checked[i][j] == 'Q') return false; } // 斜线 、、、 for(int i=x-1,j=y+1;i&gt;=0 &amp;&amp; j &lt; n;i--,j++){ if(checked[i][j] == 'Q') return false; } return true; } vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) { // -1空 0 代表不能放置 1 代表已经放置的 vector&lt;string&gt; checked(n,string(n,'.')); traceback(checked,0,n); return ans; }};","link":"/2020/05/08/2020-05-08-51.-N%E7%9A%87%E5%90%8E/"},{"title":"Next Step","text":"考研结束，基本达到预期目标吧，接下来准备开始新一步的规划： 矩阵分析 最值优化（凸优化） 机器学习 英语 lc刷到80% more…","link":"/2020/05/18/2020-05-18-Next-Step/"},{"title":"Theory behind GAN","text":"GenerationTarget: find data distribution $$P_{data}(x)$$.x 是一个图片 ( a high-dimensional vector) Before GANTarget：使用一个分布 $P_G(x,\\theta)$ 去拟合分布$P_{data}(x)$（固定的），使两者越接近越好. 例如$P_G(x,\\theta)$可以是 gaussian mixture model,此时 $\\theta$为 means and variances of this model Given a data distribution $P_{data}(x)$ (We can sample from it) $P_{data}(x)$ 未知，但是可以 sample from it. (就是从已有的database中sample出来一些) We have a data distribution $P_G(x;\\theta)$ parameterized by $\\theta$ We want to find $\\theta$ such that $P_G$ close to $P_{data}$ Sample {$x^1,x^2…,x^m$} from $P_{data}(x)$ and compute $P_G(x^i;\\theta)$ Find $\\theta^*$ maximizing the Object Function Object Function：Maximum Likelihood Estimation (最大似然估计) $$\\begin{aligned}F(\\theta) &amp;= \\prod_{x=1}^{m} P_G(x^i;\\theta)\\tag{1}\\end{aligned}$$ 要使 $F(\\theta)$ 达到最大，即求 $\\theta^*$ 使$F(\\theta)$取得最值 $$\\begin{aligned} \\theta^* &amp;= \\arg\\mathop{\\max}\\limits_{\\theta}F(\\theta) \\tag{2} \\ &amp;= \\arg\\mathop{\\max}\\limits_{\\theta}\\sum_{x=1}^mlog(P_G(x^i;\\theta)) \\ &amp;\\approx \\color{red}\\arg\\mathop{\\max}\\limits_{\\theta}E_x\\sim_{P_{data}(x)}(log(P_G(x;\\theta)))\\ &amp;= \\color{red}\\arg\\mathop{\\max}\\limits_{\\theta} (\\int_x P_{data}(x)log(P_G(x;\\theta))dx - \\int_x P_{data}(x)log(P_{data}(x))dx) \\ &amp;= \\arg\\mathop{\\max}\\limits_{\\theta}\\int_xP_{data}(x)log(P_G(x;\\theta)/P_{data}(x))dx \\ &amp;= \\arg\\mathop{\\min}\\limits_{\\theta} KL Div(P_{data}||P_G) \\end{aligned}$$ 即： Maximum Likelihood Estimation $\\approx$ KL Divergence 因此 对于 Generator 的目的就是 $G^* = \\arg\\mathop{\\min}\\limits_{G}Div(P_G,P_{data})$,即使 $P_G 和 P_{data}$ 之间的散度最小。 这里存在一个问题: How to define general $P_G(x)$ ? 对于 $P_G(x)$分布(更加 general distribution),它可能无法进行计算(如 Nerual Network),即 $logP_G(x;\\theta)$无法计算. Using GANGAN 是如何处理这个问题的呢？ (Generator)GAN 采用了一个 NN 来拟合 $P_G(x)$，即 Generator 是一个 network, 使用它来定义分布 $P_G$ To learn the generator’s distribution $P_G$,we define a prior on input noise variables $P_z(z)$, then represent a mapping to data space as $G(z;\\theta_g)$,where G is a differentiable function represented by a multilayer perceptron with parameters $\\theta_g$. prior distribution $P_z(z) 一般可以选取任意分布，如 Gussian Mixture Distribution$ 根据上面可知，它的 Object Function (loss) 是某种 Divergence, 即 $Div(P_G,P_{data})$,而且目的为是这种散度最小，即 $G^* = \\arg\\mathop{\\min}\\limits_G Div({P_G,P_{data}})$.关键就是如何计算这种 Divergence？ How to Compute Divergence (Discriminator) ?对于 $P_G$或者$P_{data}$ 因为是未知的，我们无法计算，但是可以 Sample from them. We alse define a second multilayer perceptron $D(x;\\theta_d)$ that outputs a single scalar. D(x) represents the probability that x came from the data rather that $P_g$. We train D to maximize the probability of assigning the correct label to both training examples and samples from G. Object Function For DWhen train D, Gis fixed: $$\\begin{aligned} V(G,D) &amp;= E_x \\sim_{P_{data}(x)}[log(D(x))] + E_z \\sim_{P_z(z)}[log(1-D(G(z)))] \\ &amp; = E_x \\sim_{P_{data}(x)}[log(D(x))] + E_x \\sim_{P_G(x)}[log(1-D(x))] \\tag{3} \\end{aligned} $$ 即 $$D^* = \\arg\\mathop{\\max}\\limits_DV(D,G) \\tag{4}$$ 式(3)如何解释呢？ 当 x 从 $P_data(x)$ sample 出来的时，那就使 scalar(D(x)) 越大越好（因为它是真实的） 当 x 从 $P_G(x)$ sample 出来时，saclar(D(x))越小越好，即1-D(x) 越大越好（因为它是Generator出来的的） 上面我们讲到，generator的目的使 $P_G$ 和 $P_{data}$ 的某种 Divergence 越小越好,其实对于式(3)它就等同于某种 Divergence 证明 V(G,D) 等同于 JS-Divergence fixed G, 求解 $D^*$$$ \\begin{aligned} D^* &amp;= \\arg\\mathop{\\max}\\limits_DV(D,G) \\ &amp;= \\arg\\mathop{\\max}\\limits_D[\\int_xP_{data}(x)log(D(x))dx + \\int_xP_G(x)log(1-D(x))dx ]\\\\ &amp;= \\arg\\mathop{\\max}\\limits_D\\int_x[P_{data}(x)log(D(x)) + P_G(x)log(1-D(x))]dx \\tag{5} \\end{aligned}$$ Given x, $D^*$使 $P_{data}(x)log(D(x)) + P_G(x)log(1-D(x))$ maximum简化为 $L(D) = alogD + blog(1-D)$ Assumed: $a = P_{data}(x)$ and $b = P_G(x)$ $$\\begin{aligned} &amp;L(D) = alogD + blog(1-D) \\ &amp;\\frac{dL(D)}{dD} = a/D + b/(1-D)(-1) = 0\\ &amp; D^ = a/(a+b) \\tag{6} \\end{aligned}$$ For any (a,b) $\\in R^2$, function $y\\to alog(y) + blog(1-y)$ achieves its maximum in [0,1] at $\\frac{a}{a+b}$ 将 $D^* = a/(a+b)$ 带入到式（3）中，有: $$\\begin{aligned} V(G,D) &amp;= E_x \\sim_{P_{data}(x)}[log(\\frac{P_{data}(x)}{(P_{data}(x)+P_G(x))})] + E_x \\sim_{P_G(x)}[log(\\frac{P_G(x)}{(P_{data}(x)+P_G(x))})] \\ &amp;= \\int_x[P_{data}(x)log(\\frac{P_{data}(x)}{(P_{data}(x)+P_G(x))}) + P_G(x)log(\\frac{P_G(x)}{(P_{data}(x)+P_G(x))})]dx \\ &amp;= \\int_x[P_{data}(x)log(\\frac{P_{data}(x)/2}{(P_{data}(x)+P_G(x))/2}) + P_G(x)log(\\frac{P_G(x)/2}{(P_{data}(x)+P_G(x))/2})]dx \\ &amp;= -\\int_x[P_{data}(x)log2 + P_G(x)log2]dx + \\int_x[P_{data}(x)log(\\frac{P_{data}(x)}{(P_{data}(x)+P_G(x))/2}) + P_G(x)log(\\frac{P_G(x)}{(P_{data}(x)+P_G(x))/2})]dx \\ &amp;= -log4 + KLDiv(P_{data}(x)||(P_{data}(x)+P_G(x))/2) + KLDiv(P_G(x)||(P_{data}(x)+P_G(x))/2) \\ &amp;= -log4 + 2*\\color{red}JSDiv(P_{data}||P_G)\\end{aligned}$$ 计算 $G^* = \\mathop{\\arg\\min}\\limits_GDiv(P_{data},P_G)$上式就等同于: $$\\begin{aligned} G^* &amp;= \\arg\\mathop{\\min}\\limits_GDiv(P_{data},P_G) \\ &amp;= \\arg\\mathop{\\min}\\limits_G\\mathop{\\max}\\limits_DV(G,D) \\ &amp;= \\arg\\mathop{\\min}\\limits_GC(G) \\end{aligned}$$ 其中 $C(G)= \\arg\\mathop{\\max}\\limits_DV(G,D)$ Algorithm Initialize generator and discriminator In each training iteration: Fix G, update D Fix D, update G Procerss实际上： $$\\begin{aligned} V(G,D) &amp;= E_x \\sim_{P_{data}(x)}[log(D(x))] + E_x \\sim_{P_G(x)}[log(1-D(x))] \\ &amp;\\approx \\frac{1}{m}\\sum_{i=1}^{m}logD(x^i) + \\frac{1}{m}\\sum_{i=1}^{m}log(1-D(\\hat{x}^i)) \\end{aligned}$$ initialize $\\theta_d$ for D and $\\theta_g$ for G In each training iteration Training D, repeat K times sample m examples{$x^1,x^2,…x^m$} from database $P_{data}(x)$ sample m examples{$z^1,z^2,…z^m$} from prior distribution $P_z(z)$ get generated data {$\\hat{x}^1,\\hat{x}^2,…\\hat{x}^m$} via $G(z^i)$ fixed $\\theta_g$,update $\\theta_d$ to maximize:$$\\begin{aligned} \\hat{V} &amp;= \\frac{1}{m}\\sum_{i=1}^{m}logD(x^i) + \\frac{1}{m}\\sum_{i=1}^{m}log(1-D(\\hat{x}^i)) \\ \\theta_d &amp;\\gets \\theta_d + \\eta\\bigtriangledown\\hat{V}(\\theta_d)\\end{aligned}$$ Training G, only once sample m examples{$z^1,z^2,…z^m$} from prior distribution $P_z(z)$ fixed $\\theta_d$,update $\\theta_g$ to minimize:$$\\begin{aligned} \\hat{V} &amp;= \\frac{1}{m}\\sum_{i=1}^{m}logD(x^i) + \\frac{1}{m}\\sum_{i=1}^{m}log(1-D(G(z^i))) \\ &amp;\\approx\\frac{1}{m}\\sum_{i=1}^{m}log(1-D(G(z^i))) \\ \\theta_g &amp;\\gets \\theta_g - \\eta\\bigtriangledown\\hat{V}(\\theta_g)\\end{aligned}$$ 实际上，在 Training G 时，采用的是： $$\\begin{aligned} \\hat{V} &amp;= -\\frac{1}{m}\\sum_{i=1}^{m}log(D(G(z^i))) \\ \\theta_g &amp;\\gets \\theta_g - \\eta\\bigtriangledown\\hat{V}(\\theta_g)\\end{aligned}$$","link":"/2020/06/15/2020-06-15-Theory-behind-GAN/"},{"title":"pascals-triangle","text":"力扣 思路 💥每一行的第一个元素和最后一个元素均为1，中间元素有： 假设上一行元素为 prev 数组， 本行为 next数组， 则有： $$next[i] = prev[i-1] + prev[i]$$ 则，使用该递推公式即可。 Code 🐘123456789101112131415161718192021class Solution {public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) { vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; prev = {1}, next; ans.push_back(prev); int i = 2; while(i &lt;= numRows){ // 重新初始化，扩充元素 next.resize(i,1); for(int j = 1; j &lt; i -1; j++){ next[j] = prev[j-1] + prev[j]; } prev = next; ans.push_back(next); i++; } return ans; }}; 复杂度分析 🥇 时间复杂度 空间复杂度 O(N^2) O(N)","link":"/2022/02/19/pascals-triangle/"}],"tags":[{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"algorithms","slug":"algorithms","link":"/tags/algorithms/"},{"name":"程序员面试宝典","slug":"程序员面试宝典","link":"/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"},{"name":"sort","slug":"sort","link":"/tags/sort/"},{"name":"usage","slug":"usage","link":"/tags/usage/"},{"name":"hpc","slug":"hpc","link":"/tags/hpc/"},{"name":"parallel computers","slug":"parallel-computers","link":"/tags/parallel-computers/"},{"name":"introduction","slug":"introduction","link":"/tags/introduction/"},{"name":"machine learning","slug":"machine-learning","link":"/tags/machine-learning/"},{"name":"classification","slug":"classification","link":"/tags/classification/"},{"name":"probability","slug":"probability","link":"/tags/probability/"},{"name":"deep learning","slug":"deep-learning","link":"/tags/deep-learning/"},{"name":"perceptron","slug":"perceptron","link":"/tags/perceptron/"},{"name":"regression","slug":"regression","link":"/tags/regression/"},{"name":"linear regression","slug":"linear-regression","link":"/tags/linear-regression/"},{"name":"最优化理论","slug":"最优化理论","link":"/tags/%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA/"},{"name":"SVM","slug":"SVM","link":"/tags/SVM/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"pat","slug":"pat","link":"/tags/pat/"},{"name":"graph","slug":"graph","link":"/tags/graph/"},{"name":"dynamic","slug":"dynamic","link":"/tags/dynamic/"},{"name":"dynamic-programming","slug":"dynamic-programming","link":"/tags/dynamic-programming/"},{"name":"tree","slug":"tree","link":"/tags/tree/"},{"name":"datastructure","slug":"datastructure","link":"/tags/datastructure/"},{"name":"感悟","slug":"感悟","link":"/tags/%E6%84%9F%E6%82%9F/"},{"name":"读书","slug":"读书","link":"/tags/%E8%AF%BB%E4%B9%A6/"},{"name":"科幻","slug":"科幻","link":"/tags/%E7%A7%91%E5%B9%BB/"},{"name":"生活","slug":"生活","link":"/tags/%E7%94%9F%E6%B4%BB/"},{"name":"ml","slug":"ml","link":"/tags/ml/"},{"name":"math","slug":"math","link":"/tags/math/"},{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"dfs","slug":"dfs","link":"/tags/dfs/"},{"name":"一刷leetcode","slug":"一刷leetcode","link":"/tags/%E4%B8%80%E5%88%B7leetcode/"},{"name":"bfs","slug":"bfs","link":"/tags/bfs/"},{"name":"The Economist APRIL 18TH–24TH 2020","slug":"The-Economist-APRIL-18TH–24TH-2020","link":"/tags/The-Economist-APRIL-18TH%E2%80%9324TH-2020/"},{"name":"newcode","slug":"newcode","link":"/tags/newcode/"},{"name":"machine-learning","slug":"machine-learning","link":"/tags/machine-learning/"},{"name":"gan","slug":"gan","link":"/tags/gan/"},{"name":"李宏毅","slug":"李宏毅","link":"/tags/%E6%9D%8E%E5%AE%8F%E6%AF%85/"},{"name":"deep-learning","slug":"deep-learning","link":"/tags/deep-learning/"},{"name":"DP","slug":"DP","link":"/tags/DP/"}],"categories":[{"name":"Daily Check","slug":"Daily-Check","link":"/categories/Daily-Check/"},{"name":"说明书","slug":"说明书","link":"/categories/%E8%AF%B4%E6%98%8E%E4%B9%A6/"},{"name":"parallel computers","slug":"parallel-computers","link":"/categories/parallel-computers/"},{"name":"machine learning","slug":"machine-learning","link":"/categories/machine-learning/"},{"name":"deep learning","slug":"machine-learning/deep-learning","link":"/categories/machine-learning/deep-learning/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Generative Adversial Network","slug":"Generative-Adversial-Network","link":"/categories/Generative-Adversial-Network/"},{"name":"PAT","slug":"PAT","link":"/categories/PAT/"},{"name":"读书","slug":"读书","link":"/categories/%E8%AF%BB%E4%B9%A6/"},{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"}]}