{"pages":[{"title":"about","text":"ğŸ¤¡ å‰è¨€ é‡‘åº¸æ­¦ä¾ æ–°åºé‡Œå†™åˆ° â€œå°è¯´æ˜¯å†™ç»™äººçœ‹çš„â€ã€‚åšå®¢ä¹Ÿæ˜¯ä¹Ÿç»™äººçœ‹çš„ï¼Œè¦æ±‚ çº¯ç²¹ã€æ˜“æ‡‚ï¼Œèƒ½å¤Ÿå¯è¿ªä¸äººæ˜¯æœ€å¥½çš„ã€‚å¤äººäº‘ï¼šâ€è¾¾åˆ™å…¼æµå¤©ä¸‹ï¼Œç©·åˆ™ç‹¬å–„å…¶èº«â€œï¼Œå¯¹æˆ‘æœ¬äººè€Œè¨€ï¼Œèƒ½å¤Ÿä½¿è¯»è€…æœ‰äº›è®¸æ”¶è·ç®—æ˜¯æ„å¤–ä¹‹å–œï¼Œåªæ±‚ä¸è¯¯äººå­å¼Ÿï¼Œè´»ç¬‘å¤§æ–¹ã€‚æœ¬ç«™åä¸ºæ±‚ç´¢ï¼Œå–è‡ªäºå±ˆåŸã€Šç¦»éªšã€‹ä¸­çš„ â€œè·¯æ¼«æ¼«å…¶ä¿®è¿œå…®ï¼Œå¾å°†ä¸Šä¸‹è€Œæ±‚ç´¢â€ã€‚ç‹å›½ç»´åœ¨ã€Šäººé—´è¯è¯ã€‹ä¸­å†™åˆ° â€œå¤ä»Šä¹‹æˆå¤§äº‹ä¸šã€å¤§å­¦é—®è€…ï¼Œå¿…ç»è¿‡ä¸‰ç§ä¹‹å¢ƒç•Œï¼šâ€˜æ˜¨å¤œè¥¿é£å‡‹ç¢§æ ‘ã€‚ç‹¬ä¸Šé«˜æ¥¼ï¼Œæœ›å°½å¤©æ¶¯è·¯â€™ã€‚æ­¤ç¬¬ä¸€å¢ƒä¹Ÿã€‚â€˜è¡£å¸¦æ¸å®½ç»ˆä¸æ‚”ï¼Œä¸ºä¼Šæ¶ˆå¾—äººæ†”æ‚´ã€‚â€™æ­¤ç¬¬äºŒå¢ƒä¹Ÿã€‚â€˜ä¼—é‡Œå¯»ä»–åƒç™¾åº¦ï¼Œè“¦ç„¶å›é¦–ï¼Œé‚£äººå´åœ¨ï¼Œç¯ç«é˜‘çŠå¤„â€™ã€‚æ­¤ç¬¬ä¸‰å¢ƒä¹Ÿã€‚â€ ï¼Œå¸Œæœ›æˆ‘èƒ½å¤Ÿè·µè¡Œä¹‹ï½ï½ï½ ğŸ‘¨â€ğŸ’» åšä¸»æ˜¯è°ä¸€ä¸ªæœªè„±ç¦»ä½çº§è¶£å‘³ä¹‹äººï¼Œä¸€ä¸ªåŠªåŠ›æ±‚ç´¢ä¹‹äººã€‚","link":"/about/index.html"}],"posts":[{"title":"about","text":"","link":"/2021/07/06/about/"},{"title":"find-majority-element-lcci","text":"æ•°ç»„ä¸­å æ¯”è¶…è¿‡ä¸€åŠçš„å…ƒç´ ç§°ä¹‹ä¸ºä¸»è¦å…ƒç´ ã€‚ç»™ä½ ä¸€ä¸ª æ•´æ•° æ•°ç»„ï¼Œæ‰¾å‡ºå…¶ä¸­çš„ä¸»è¦å…ƒç´ ã€‚è‹¥æ²¡æœ‰ï¼Œè¿”å› -1 ã€‚è¯·è®¾è®¡æ—¶é—´å¤æ‚åº¦ä¸º O(N) ã€ç©ºé—´å¤æ‚åº¦ä¸º O(1) çš„è§£å†³æ–¹æ¡ˆã€‚ ç¤ºä¾‹ 1ï¼š 12è¾“å…¥ï¼š[1,2,5,9,5,9,5,5,5]è¾“å‡ºï¼š5 ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼š[3,2]è¾“å‡ºï¼š-1 ç¤ºä¾‹ 3ï¼š 12è¾“å…¥ï¼š[2,2,1,1,1,2,2]è¾“å‡ºï¼š2 æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/find-majority-element-lcciè‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ æ ¸å¿ƒæ€æƒ³å‡è®¾å­˜åœ¨å…ƒç´ açš„æ•°é‡è¶…è¿‡ä¸€åŠ,åˆ™å°†æ‰€æœ‰ä¸åŒçš„å…ƒç´ ç›¸äº’æŠµæ¶ˆï¼Œå‰©ä½™çš„é‚£ä¸€ä¸ªè‚¯å®šæ˜¯a.å¦‚ï¼š 12[2,2,1,1,1,2,2]-&gt; [2] å½“ä¸å­˜åœ¨è¿™æ ·çš„å…ƒç´ æ—¶ï¼Œä¹Ÿå¯èƒ½æœ€åå‰©ä½™çš„å…ƒç´ ä¸ç¬¦åˆæ¡ä»¶ï¼Œè¿™æ—¶å€™å°±éœ€è¦ç»Ÿè®¡å‰©ä½™å…ƒç´ çš„ä¸ªæ•°ï¼Œç„¶ååˆ¤æ–­æ˜¯å¦è¶…è¿‡æ€»æ•°çš„ä¸€åŠå³å¯ã€‚å¦‚ï¼š 12[1,2,3]-&gt; [3] Code123456789101112131415161718192021222324class Solution {public: int majorityElement(vector&lt;int&gt;&amp; nums) { int num = nums[0], count = 1, n = nums.size(); for(int i =1; i&lt;n; i++){ if(count == 0){ num = nums[i]; count = 1; }else{ if(nums[i] != num){ count --; }else count++; } } if(count == 0) return -1; else{ count = 0; for(int nu: nums){ if(nu == num) count++; } return count*2 &gt;= n ? num:-1; } }};","link":"/2021/07/09/find-majority-element-lcci/"},{"title":"group-anagrams-lcci [è®¡æ•°ç»Ÿè®¡]","text":"ç¼–å†™ä¸€ç§æ–¹æ³•ï¼Œå¯¹å­—ç¬¦ä¸²æ•°ç»„è¿›è¡Œæ’åºï¼Œå°†æ‰€æœ‰å˜ä½è¯ç»„åˆåœ¨ä¸€èµ·ã€‚å˜ä½è¯æ˜¯æŒ‡å­—æ¯ç›¸åŒï¼Œä½†æ’åˆ—ä¸åŒçš„å­—ç¬¦ä¸²ã€‚ æ³¨æ„ï¼šæœ¬é¢˜ç›¸å¯¹åŸé¢˜ç¨ä½œä¿®æ”¹ ç¤ºä¾‹: 123456789è¾“å…¥: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],è¾“å‡º:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] è¯´æ˜ï¼š æ‰€æœ‰è¾“å…¥å‡ä¸ºå°å†™å­—æ¯ã€‚ ä¸è€ƒè™‘ç­”æ¡ˆè¾“å‡ºçš„é¡ºåºã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/group-anagrams-lcciè‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ é¢˜è§£ç”±äºåªæœ‰å°å†™å­—æ¯ï¼Œåªéœ€è¦ç”³è¯·ä¸€ä¸ªé•¿åº¦ä¸º26çš„æ•°ç»„ç»Ÿè®¡æ¯ä¸€ä¸ªå­—ç¬¦ä¸²çš„å­—æ¯æ•°é‡å³å¯ï¼ˆç±»ä¼¼äºhashcodeçš„æ„é€ æ€æƒ³ï¼‰ã€‚è¿™æ ·æ‰€æœ‰çš„å˜ä½è¯å¯ä»¥æ˜ å°„åˆ°ç›¸åŒçš„æ•°ç»„ï¼Œä½¿ç”¨mapï¼Œå°†æ•°ç»„ï¼ˆæˆ–è€…è½¬ä¸ºå­—ç¬¦ä¸²ï¼‰ä½œä¸ºkeyï¼Œvalue å³æ˜¯å¯¹åº”çš„å­—ç¬¦æ•°ç»„ã€‚ Code12345678910111213141516171819202122232425262728293031class Solution {public: string hashcode(vector&lt;int&gt; chs){ string ans = &quot;&quot;; for(int ch: chs){ ans.append(to_string(ch) + &quot;_&quot;); } return ans; } vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) { // hash ç¼–ç  // eat tea tan ate nat bat unordered_map&lt;string,vector&lt;string&gt;&gt; containers; for(string str: strs){ vector&lt;int&gt; counts(26,0); for(char c: str){ counts[c-'a'] ++; } containers[hashcode(counts)].emplace_back(str); } vector&lt;vector&lt;string&gt;&gt; res; for(auto &amp;p: containers){ res.push_back(p.second); } return res; }};","link":"/2021/07/18/group-anagrams-lcci/"},{"title":"minimize-maximum-pair-sum-in-array","text":"ä¸€ä¸ªæ•°å¯¹ (a,b) çš„ æ•°å¯¹å’Œ ç­‰äº a + b ã€‚æœ€å¤§æ•°å¯¹å’Œ æ˜¯ä¸€ä¸ªæ•°å¯¹æ•°ç»„ä¸­æœ€å¤§çš„ æ•°å¯¹å’Œ ã€‚ æ¯”æ–¹è¯´ï¼Œå¦‚æœæˆ‘ä»¬æœ‰æ•°å¯¹ (1,5) ï¼Œ(2,3) å’Œ (4,4)ï¼Œæœ€å¤§æ•°å¯¹å’Œ ä¸º max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8 ã€‚ç»™ä½ ä¸€ä¸ªé•¿åº¦ä¸º å¶æ•° n çš„æ•°ç»„ nums ï¼Œè¯·ä½ å°† nums ä¸­çš„å…ƒç´ åˆ†æˆ n / 2 ä¸ªæ•°å¯¹ï¼Œä½¿å¾—ï¼š nums ä¸­æ¯ä¸ªå…ƒç´  æ°å¥½ åœ¨ ä¸€ä¸ª æ•°å¯¹ä¸­ï¼Œä¸”æœ€å¤§æ•°å¯¹å’Œ çš„å€¼ æœ€å° ã€‚è¯·ä½ åœ¨æœ€ä¼˜æ•°å¯¹åˆ’åˆ†çš„æ–¹æ¡ˆä¸‹ï¼Œè¿”å›æœ€å°çš„ æœ€å¤§æ•°å¯¹å’Œ ã€‚ ç¤ºä¾‹ 1ï¼š 12345è¾“å…¥ï¼šnums = [3,5,2,3]è¾“å‡ºï¼š7è§£é‡Šï¼šæ•°ç»„ä¸­çš„å…ƒç´ å¯ä»¥åˆ†ä¸ºæ•°å¯¹ (3,3) å’Œ (5,2) ã€‚æœ€å¤§æ•°å¯¹å’Œä¸º max(3+3, 5+2) = max(6, 7) = 7 ã€‚ ç¤ºä¾‹ 2ï¼š 12345è¾“å…¥ï¼šnums = [3,5,4,2,4,6]è¾“å‡ºï¼š8è§£é‡Šï¼šæ•°ç»„ä¸­çš„å…ƒç´ å¯ä»¥åˆ†ä¸ºæ•°å¯¹ (3,5)ï¼Œ(4,4) å’Œ (6,2) ã€‚æœ€å¤§æ•°å¯¹å’Œä¸º max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8 ã€‚ æç¤ºï¼š n == nums.length2 &lt;= n &lt;= 105n æ˜¯ å¶æ•° ã€‚1 &lt;= nums[i] &lt;= 105 æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-arrayè‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ Solutionè´ªå¿ƒç®—æ³•ï¼Œå‡è®¾åºåˆ— [a1,a2,a3,a4,a5,a6],ä¸” a1 &lt;= a2 &lt;= a3 &lt;= .. &lt;= a6, åˆ™å¿…æœ‰æœ€å°çš„ æœ€å¤§æ•°å¯¹å’Œåªèƒ½æ˜¯(a1,a6),(a2,a5),(a3,a4)æ•°å¯¹ä¹‹å’Œçš„æœ€å¤§å€¼ã€‚ è¯æ˜ç®€å•è¯æ˜ä¸€ä¸‹ï¼Œå‡è®¾å­˜åœ¨å››ä¸ªæ•° a &lt; b &lt; c &lt; d, åˆ™ç¬¦åˆæ¡ä»¶çš„æ•°ä¸º max(a+d,b+c)ã€‚åè¯æ³•: è‹¥ d ä¸ä¸ aæ­é…,ä¸å…¶å®ƒä»»æ„æ­é…ï¼Œéƒ½å­˜åœ¨ç»“æœä¸º d + ?. Code12345678910111213class Solution {public: int minPairSum(vector&lt;int&gt;&amp; nums) { sort(nums.begin(),nums.end()); int ans = 0, n = nums.size() - 1, i = 0; while(i &lt; n){ ans = max(ans,nums[i]+nums[n]); i++; n--; } return ans; }};","link":"/2021/07/20/minimize-maximum-pair-sum-in-array/"},{"title":"template","text":"å¸¸è§çš„ä¸€äº›latexã€hexo bug æˆ–è€…å…¶å®ƒçš„ä½¿ç”¨è¯´æ˜ä¹¦. 1. latexlatex syntax 1.1 è¡Œå†…æ ·å¼ inline synatx$\\hat{x}_{k}=\\hat{x}_{k}^{-}+K_{t}\\left(y_{k}\\right)$ 1.2 equation \\begin{align} & \\arg\\min_{w,b} \\frac{1}{2m}\\sum_{i=1}^m (\\hat{y_i} - y_i)^2 \\\\ & s.t \\quad \\hat{y_i}(w^x_i + b) >= 0\\\\ \\end{align} 1.3 çŸ©é˜µ $$\\begin{bmatrix} {a_{11}}&{a_{12}}&{\\cdots}&{a_{1n}}\\\\ {a_{21}}&{a_{22}}&{\\cdots}&{a_{2n}}\\\\ {\\vdots}&{\\vdots}&{\\ddots}&{\\vdots}\\\\ {a_{m1}}&{a_{m2}}&{\\cdots}&{a_{mn}}\\\\ \\end{bmatrix}$$ 1.4 åˆ†æ¯$$P(A_i \\mid B) = \\frac{P(B\\mid A)P(A_i)}{\\sum_{j=1}^{n}P(A_j)P(B \\mid A_j)}$$ 1.5 å¸¸è§çš„å¸Œè…Šå­—ç¬¦ å¸Œè…Šå­—ç¬¦ latex å¤§å†™ latexï½œ $\\alpha$ \\alpha $\\lambda$ \\lambda $\\Lambda$ \\Lambda $\\delta$ \\delta $\\Delta$ \\Delta $\\beta$ \\beta $\\sigma$ \\sigma $\\Sigma$ \\Sigma $\\theta$ \\theta $\\Theta$ \\Theta $\\epsilon$ \\epsilon To be continue","link":"/2021/07/06/template/"},{"title":"time-based-key-value-store","text":"åˆ›å»ºä¸€ä¸ªåŸºäºæ—¶é—´çš„é”®å€¼å­˜å‚¨ç±» TimeMapï¼Œå®ƒæ”¯æŒä¸‹é¢ä¸¤ä¸ªæ“ä½œï¼š set(string key, string value, int timestamp) å­˜å‚¨é”® keyã€å€¼ valueï¼Œä»¥åŠç»™å®šçš„æ—¶é—´æˆ³ timestampã€‚ get(string key, int timestamp) è¿”å›å…ˆå‰è°ƒç”¨ set(key, value, timestamp_prev) æ‰€å­˜å‚¨çš„å€¼ï¼Œå…¶ä¸­ timestamp_prev &lt;= timestampã€‚å¦‚æœæœ‰å¤šä¸ªè¿™æ ·çš„å€¼ï¼Œåˆ™è¿”å›å¯¹åº”æœ€å¤§çš„ timestamp_prev çš„é‚£ä¸ªå€¼ã€‚å¦‚æœæ²¡æœ‰å€¼ï¼Œåˆ™è¿”å›ç©ºå­—ç¬¦ä¸²ï¼ˆâ€â€ï¼‰ã€‚ ç¤ºä¾‹ 1ï¼š12345678910è¾“å…¥ï¼šinputs = [&quot;TimeMap&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;], inputs = [[],[&quot;foo&quot;,&quot;bar&quot;,1],[&quot;foo&quot;,1],[&quot;foo&quot;,3],[&quot;foo&quot;,&quot;bar2&quot;,4],[&quot;foo&quot;,4],[&quot;foo&quot;,5]]è¾“å‡ºï¼š[null,null,&quot;bar&quot;,&quot;bar&quot;,null,&quot;bar2&quot;,&quot;bar2&quot;]è§£é‡Šï¼š TimeMap kv; kv.set(&quot;foo&quot;, &quot;bar&quot;, 1); // å­˜å‚¨é”® &quot;foo&quot; å’Œå€¼ &quot;bar&quot; ä»¥åŠæ—¶é—´æˆ³ timestamp = 1 kv.get(&quot;foo&quot;, 1); // è¾“å‡º &quot;bar&quot; kv.get(&quot;foo&quot;, 3); // è¾“å‡º &quot;bar&quot; å› ä¸ºåœ¨æ—¶é—´æˆ³ 3 å’Œæ—¶é—´æˆ³ 2 å¤„æ²¡æœ‰å¯¹åº” &quot;foo&quot; çš„å€¼ï¼Œæ‰€ä»¥å”¯ä¸€çš„å€¼ä½äºæ—¶é—´æˆ³ 1 å¤„ï¼ˆå³ &quot;bar&quot;ï¼‰ kv.set(&quot;foo&quot;, &quot;bar2&quot;, 4); kv.get(&quot;foo&quot;, 4); // è¾“å‡º &quot;bar2&quot; kv.get(&quot;foo&quot;, 5); // è¾“å‡º &quot;bar2&quot; ç¤ºä¾‹ 2ï¼š12è¾“å…¥ï¼šinputs = [&quot;TimeMap&quot;,&quot;set&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;,&quot;get&quot;,&quot;get&quot;,&quot;get&quot;], inputs = [[],[&quot;love&quot;,&quot;high&quot;,10],[&quot;love&quot;,&quot;low&quot;,20],[&quot;love&quot;,5],[&quot;love&quot;,10],[&quot;love&quot;,15],[&quot;love&quot;,20],[&quot;love&quot;,25]]è¾“å‡ºï¼š[null,null,null,&quot;&quot;,&quot;high&quot;,&quot;high&quot;,&quot;low&quot;,&quot;low&quot;] æç¤ºï¼š æ‰€æœ‰çš„é”®/å€¼å­—ç¬¦ä¸²éƒ½æ˜¯å°å†™çš„ã€‚ æ‰€æœ‰çš„é”®/å€¼å­—ç¬¦ä¸²é•¿åº¦éƒ½åœ¨ [1, 100] èŒƒå›´å†…ã€‚ æ‰€æœ‰ TimeMap.set æ“ä½œä¸­çš„æ—¶é—´æˆ³ timestamps éƒ½æ˜¯ä¸¥æ ¼é€’å¢çš„ã€‚ 1 &lt;= timestamp &lt;= 10^7 TimeMap.set å’Œ TimeMap.get å‡½æ•°åœ¨æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹ä¸­å°†ï¼ˆç»„åˆï¼‰è°ƒç”¨æ€»è®¡ 120000 æ¬¡ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/time-based-key-value-storeè‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ Code123456789101112131415161718192021222324252627282930313233class TimeMap {public: using P = pair&lt;int,string&gt;; unordered_map&lt;string,vector&lt;P&gt;&gt; container; /** Initialize your data structure here. */ TimeMap() { // unordered_map&lt;string,priority_queue&lt;Point&gt;&gt; container; } void set(string key, string value, int timestamp) { container[key].emplace_back(P(timestamp,value)); } string get(string key, int timestamp) { auto &amp;pairs = container[key]; auto it = upper_bound(pairs.begin(),pairs.end(),P(timestamp,string({127}))); if(it != pairs.begin()){ return (it -1)-&gt;second; } return &quot;&quot;; }};/** * Your TimeMap object will be instantiated and called as such: * TimeMap* obj = new TimeMap(); * obj-&gt;set(key,value,timestamp); * string param_2 = obj-&gt;get(key,timestamp); */ More Info1. Pair&lt;int,string&gt;2. Vector&lt;Pair&lt;int,string&gt;&gt;","link":"/2021/07/10/time-based-key-value-store/"},{"title":"applications_of_parallel_computers","text":"cs267 æ˜¯cmuçš„ä¸€é—¨å…³äºå¹¶è¡Œç®—æ³•çš„å…¬å¼€è¯¾ä¸‹é¢æ˜¯å®ƒçš„ä¸€ä¸ªè¯¦ç»†çš„è¯¾ç¨‹è¡¨ CS267 Master Schedule Sp21 å¹¶è¡Œç®—æ³•","link":"/2021/09/03/applications-of-parallel-computers/"},{"title":"æ„ŸçŸ¥æœº","text":"æ„ŸçŸ¥æœº(Perceptron), æ˜¯ä¸€ç§äºŒåˆ†ç±»çš„çº¿æ€§åˆ†ç±»å™¨ã€‚ å…¶è¾“å…¥æ˜¯ä¸€ä¸ªå¾…åˆ†ç±»çš„å®ä¾‹ï¼Œè¾“å‡ºä¸ºè¯¥å®ä¾‹å¯¹åº”çš„ç±»å‹ã€‚ æ ¹æ®æ¨¡å‹ã€ç­–ç•¥å’Œç®—æ³•ä¸‰éƒ¨æ›²ï¼Œæ¥è¯´ï¼š 1. æ¨¡å‹ç”±äºæ˜¯ä¸€ä¸ªåˆ†ç±»å™¨ï¼Œå…¶å‡½æ•°æ¨¡å‹ä¸ºï¼š $$ {\\begin{aligned} &z = w^Tx + b \\\\ &f(x) = sign(z) = \\begin{cases} 1, & \\text{if z > 0} \\\\ -1, & \\text{if z < 0} \\end{cases} \\end{aligned}} $$ 2. ç­–ç•¥åˆ†ç±»é—®é¢˜çš„è¯¯å·®å‡½æ•°ï¼Œå¯ä»¥é‡‡ç”¨è¯¯åˆ†ç±»ä¸ªæ•°ä¹‹å’Œ $$Loss(w,b) = \\sum_i I(y_i,f(x_i)) \\\\ I(y_i,f(x_i)) = \\begin{cases} 1, &\\text{if $y_i\\neq f(x_i)$ } \\\\ 0, &\\text{if $y_i = f(x_i)$} \\\\ \\end{cases}$$ ä½†æ˜¯ï¼Œè¯¥å‡½æ•°æ— æ³•ä½¿ç”¨æ¢¯åº¦ä¸‹é™æ³•æ¥è¿›è¡Œæ±‚è§£ã€‚å¯ä»¥è€ƒè™‘ä¸€ä¸‹ï¼Œæ¯ä¸ªç‚¹åˆ°è¯¥åˆ†ç±»å™¨è¶…å¹³ç‚¹çš„è·ç¦»ã€‚ 2.1 æŸå¤±å‡½æ•°å‡è®¾å­˜åœ¨ä¸€ä¸ªè¶…å¹³é¢ S: $w^Tx + b = 0$ ï¼Œå°†ç‰¹å¾åˆ’åˆ†ä¸ºæ­£ã€è´Ÿä¸¤ä¸ªè¶…å¹³é¢ã€‚è¶…å¹³é¢ Sï¼Œå…¶ä¸­ wæ˜¯æ³•å‘é‡ï¼Œbä¸ºæˆªè·ï¼Œå¦‚ä¸‹å›¾ç»¿çº¿ æ­¤æ—¶ï¼Œæˆ‘ä»¬é‡‡ç”¨è¯¯åˆ†ç±»ç‚¹åˆ°è¶…å¹³é¢çš„è·ç¦»ä¹‹å’Œæ¥ä½œä¸ºæŸå¤±å‡½æ•°ã€‚å‘é‡ç©ºé—´çš„ä»»æ„ä¸€ç‚¹ x åˆ°è¶…å¹³é¢Sçš„è·ç¦»ä¸º $ dis = \\frac{1}{||w||}|w^Tx_i + b| \\\\$ ç”±äºï¼Œ å¯¹äºè¯¯åˆ†ç±»çš„ç‚¹æœ‰ï¼š $$ \\begin{cases} w^Tx + b < 0,&\\text{if $y = 1$} \\\\ w^Tx + b > 0,&\\text{if $y = -1$} \\\\ \\end{cases} \\\\ -y(w^Tx + b) > 0 , x\\subset M \\\\ $$ å› æ­¤æŸå¤±å‡½æ•°ä¸ºï¼š $L(w,b) = \\sum_i^M -y_i(w^Tx_i + b) \\qquad (3) \\\\$ > è¿™é‡Œçœç•¥æ‰äº† ||w|| æˆ–è€…è¯´æ˜¯åŠ äº†çº¦æŸæ¡ä»¶ ||w|| = 1, æ€è€ƒä¸ºä»€ä¹ˆå¯ä»¥ï¼Ÿ > ç­”æ¡ˆè§é™„å½• B-1 æ˜æ˜¾æ˜¯ä¸€ä¸ªæ— çº¦æŸçš„çº¿æ€§ä¼˜åŒ–é—®é¢˜ï¼Œè½¬åŒ–ä¸ºä¼˜åŒ–é—®é¢˜ä¸ºï¼š $\\arg\\min_{w,b} L(w,b) \\\\ s.t \\rightarrow x\\in M \\qquad (4)$ M æ˜¯æ‰€æœ‰è¯¯åˆ†ç±»çš„é›†åˆï¼Œå³ï¼š $$ M = {x| y(w^Tx + b )","link":"/2021/03/28/%E6%84%9F%E7%9F%A5%E6%9C%BA/"},{"title":"æœ´ç´ è´å¶æ–¯","text":"æœ´ç´ è´å¶æ–¯ï¼ˆnaive bayesï¼‰æ˜¯åŸºäºè´å¶æ–¯ç†è®ºçš„åˆ†ç±»å™¨ï¼Œå®ƒä»¥å˜é‡çš„å„ä¸ªç‰¹å¾ä¹‹é—´ç›¸äº’ç‹¬ç«‹ä¸ºå‰æï¼Œåˆ©ç”¨æ¡ä»¶æ¦‚ç‡æ¥æœ€å¤§åŒ–åéªŒæ¦‚ç‡æˆ–è€…æœ€å°åŒ–æœŸæœ›é£é™©ï¼Œæ¥å®ç°åˆ¤åˆ«å…¶ç±»åˆ«ã€‚ 1. åŸºç¡€ç†è®ºæ ¹æ®æ¡ä»¶æ¦‚ç‡æˆ–è€…è´å¶æ–¯ç†è®ºæœ‰ï¼š $$P(Y = c_k/ X = x) = \\frac{P(Y = c_k, X = x)}{P(X = x)} = \\frac{ P(X = x/ Y = c_k)P(Y = c_k)}{\\sum_k^K P(X = x/ Y = c_k)P(Y = c_k) } \\$$ å…¶ä¸­ Y ä¸ºç±»åˆ«é›†åˆ {${c_1,c_2,â€¦c_k}$};X ä¸ºè¾“å…¥ç©ºé—´çš„ n ç»´å‘é‡é›†åˆ {${x_i,x_2,â€¦x_n}$} ã€‚ ç›®æ ‡ä¸ºå¯¹äºç»™å®šçš„ä¸€ä¸ªè¾“å…¥å‘é‡ï¼Œé€šè¿‡æ¨¡å‹èƒ½å¤Ÿè·å–å…¶ç±»åˆ«ï¼ˆè¿™é‡Œå–ç»™å®šxæƒ…å†µä¸‹ï¼Œå–æ¦‚ç‡æœ€å¤§çš„ç±»åˆ«ä½œä¸ºæœ€ç»ˆç±»åˆ«ï¼‰ï¼Œå³ $$Given,x \\in X \\y = f(x) = \\arg\\max_{ck}P(Y = c_k/X = x), k =1,2,3â€¦K$$æ±‚è§£æ¦‚ç‡ $P(Y = c_k/X = x)$ï¼Œå¯ä»¥æœ‰è´å¶æ–¯ç†è®ºå¯çŸ¥ï¼Œå…ˆæ±‚è§£$P(Y = c_k, X = x), P(X = x)$ã€‚ 1.1 æ±‚è§£$P(Y = c_k,X = x)$è¿™é‡Œå‡è®¾äº†ï¼Œå¯¹äºå˜é‡$$x = [x^{(1)},â€¦,x^{(m)}]$$çš„ä¸åŒç‰¹å¾ä¹‹é—´ç›¸äº’ç‹¬ç«‹ï¼Œå› æ­¤: $$\\begin{aligned}P(Y=c_k,X=x) &amp;= P(Y=c_k,X^{(1)} \\ &amp;= x^{(1)},â€¦,X^{(m)} = x^{(m)} ) \\ &amp;= \\prod_{i}^m P(Y=c_k,X^{(i)} = x^{(i)}) \\ &amp;= P(Y = c_k) \\prod_{i}^m P(X^{(i)}= x^{(i)}/ Y = c_k )\\end{aligned}$$ 1.2 æ±‚è§£ $P(X = x)$æœ‰è´å¶æ–¯å¯çŸ¥ï¼š$$\\begin{aligned}P(X = x) &amp;= \\sum_k^K P(X = x/ Y = c_k)P(Y = c_k) \\&amp;= \\sum_k^K P(Y=c_k) \\prod_i^m P(X^{(i)} = x^{(i)}/ Y = c_k )\\end{aligned}$$ ä½†æ˜¯ $P(Y = c_k ) , , P(X^{(i)} = x^{(i)}/ Y = c_k )$ å¦‚ä½•ç¡®å®šå‘¢ï¼Ÿ 2. æœ€å¤§åŒ–åéªŒæ¦‚ç‡æˆ–è€…æœ€å°åŒ–æœŸæœ›é£é™©åéªŒæ¦‚ç‡æœ€å¤§åŒ–å³ï¼š$\\max P(Y=c_k/X=x)$ å‡è®¾è¯¯å·®æŸå¤±å‡½æ•°ï¼š$$\\begin{aligned}L(Y, f(X)) = \\begin{cases} 0 &amp;, Y = f(X) \\ 1 &amp;, Y \\neq f(X)\\\\end{cases}\\end{aligned}$$åˆ™æ¨¡å‹ç›®æ ‡ä¸ºæœ€å°åŒ–æœŸæœ›é£é™©å³ï¼š $$\\begin{aligned}R_{exp}(f) &amp;= E[L(Y,f(X)]\\&amp;= E_X\\sum_k^KP(c_k/X) L(c_k,f(X)) \\&amp;= E_X\\sum_k^{K}L(y,c_k)P(c_k/X=x) \\&amp;= E_X\\sum_k^{K}P(y \\neq c_k/X=x) \\qquad (1)\\end{aligned}$$ æœ€å°åŒ–å¼å­(1)ï¼Œåªéœ€è¦å¯¹ X=x é€ä¸ªæœ€å°åŒ–å³å¯ã€‚ $$\\begin{aligned}f(x) &amp;= \\arg\\min P(y\\neq c_k/X=x) \\&amp;= \\arg\\min (1 - P(y = c_k/X= x)) \\&amp;= \\arg \\max P(y=c_k/X=x)\\end{aligned}$$ å› æ­¤ï¼Œä¸¤è€…æ˜¯ç­‰ä»·çš„ 3. è´å¶æ–¯çš„å‚æ•°ä¼°è®¡å‰é¢æåˆ°é—®é¢˜ï¼šä½†æ˜¯ $P(Y = c_k ) , , P(X^{(i)} = x^{(i)}/ Y = c_k )$ å¦‚ä½•ç¡®å®šå‘¢ï¼Ÿå¯¹äºç¦»æ•£å˜é‡ï¼Œä¸€ä¸ªç›´è§‚çš„æ¦‚å¿µæ˜¯ä½¿ç”¨å…¶ç»Ÿè®¡å­¦æ–¹æ³•æ¥è¿‘ä¼¼ä¼°è®¡æ¦‚ç‡ã€‚å¯¹äºè¿ç»­å˜é‡ï¼Œé‡‡ç”¨ä¸€ä¸ªæ¦‚ç‡åˆ†å¸ƒæ‹Ÿåˆå…¶å˜é‡åˆ†å¸ƒï¼Œå¦‚é«˜æ–¯åˆ†å¸ƒ 3.1 ç¦»æ•£å‹å˜é‡ä¼°è®¡ä»¤ $\\theta = P(Y = c_k)$ å‚ä¸æå¤§ä¼¼ç„¶æ¦‚ç‡æ¥ä¼°è®¡ $\\theta$, è®¾å˜é‡ä¸ªæ•°ä¸ºn,å…¶ä¸­ç±»åˆ«ä¸º$c_k$çš„æœ‰tä¸ªï¼Œåˆ™æœ‰ï¼š $$\\begin{aligned}&amp;L(\\theta) = (\\theta)^{t}(1 - \\theta)^{(n-t)} \\&amp;LnL(\\theta) = tLn(\\theta) + (n-t)Ln(1-\\theta) \\&amp;\\frac{dLnL(\\theta)}{d\\theta} = \\frac{t}{\\theta} + \\frac{-(n-t)}{1 - \\theta} = 0 \\&amp;\\hat\\theta = \\frac{t}{n}\\end{aligned}$$å³ï¼š $P(Y=c_k) = \\frac{t}{n}$åŒç†å¯çŸ¥ï¼š$P(X^{(i)} = x^{(i)}/ Y = c_k ) = \\frac{t_{ni}}{n_k}$, å…¶ä¸­ $n_k$ ä¸ºç±»åˆ«ä¸º $c_k$çš„æ•°é‡ï¼Œ$t_{ni}$ä¸ºåœ¨ç±»åˆ«ä¸º$c_k$çš„æ•°æ®ä¸­ï¼Œ$X^{(i)} = x^{(i)}$çš„æ•°é‡ç”±äºï¼Œå¯¹äºä»»æ„ç±»åˆ« $P(X = x)$ çš„å€¼æ˜¯ç›¸åŒçš„ï¼Œå› æ­¤å¯ä»¥çœç•¥â€¦ 3.2 è¿ç»­æ€§å˜é‡ä¼°è®¡å¦‚æœXçš„å„ä¸ªç‰¹å¾æ˜¯è¿ç»­çš„ï¼Œè¿™æ˜¯å¯ä»¥é‡‡ç”¨æŸç§å…·ä½“çš„åˆ†å¸ƒå‡½æ•°æ¥æ‹ŸåˆXå„ä¸ªç‰¹å¾çš„åˆ†å¸ƒï¼Œæ¯”å¦‚é‡‡ç”¨ Normal Distribution ç­‰ç­‰ã€‚é€šå¸¸åœ¨ç¡®å®šåˆ†å¸ƒå‡½æ•°ç±»å‹ä¹‹å‰ï¼Œå…ˆå¯¹æ•°æ®è¿›è¡Œå¯è§†åŒ–å¤„ç†ï¼Œè§‚å¯Ÿå…¶æ•°å­—ç‰¹å¾ç­‰ï¼Œåœ¨ç¡®å®šé‡‡ç”¨å“ªç§åˆ†å¸ƒå‡½æ•°æ¥æ‹Ÿåˆã€‚ ä»¥é«˜æ–¯åˆ†å¸ƒä¸ºä¾‹ï¼Œæ­¤æ—¶ $X_i \\sim (\\mu\\sigma)$ï¼š $$\\begin{aligned}&amp;\\mu_i = Ex_i = \\bar{x} \\&amp;\\sigma_i^2 = E((X_i-\\mu_i)^2)\\end{aligned}$$ è¿™é‡Œå…¶å®è¦ä½¿ç”¨æœ€å¤§ä¼¼ç„¶æ¥ä¼°è®¡ä¸€ä¸‹å˜é‡ $\\mu$å’Œ $\\sigma$ $$L(\\mu,\\sigma) = \\prod_i^mf(x_i)\\LnL = \\sum_i^m\\ln{f(x_i)}$$å¯¹ä¸Šå¼åˆ†åˆ«å¯¹ $\\mu$å’Œ $\\sigma$æ±‚åå¯¼æ•°ï¼Œå¹¶ä»¤å…¶ä¸º0å³å¯ æ›´ç®€åŒ–ï¼Œç”±äºå˜é‡çš„å„ä¸ªç»´åº¦éƒ½æ˜¯ç‹¬ç«‹çš„ï¼Œå› æ­¤å¯ä»¥è”åˆåˆ†å¸ƒä¸ºå„ä¸ªåˆ†å¸ƒå‡½æ•°çš„ä¹˜ç§¯ï¼Œå¦‚æœéƒ½æ˜¯ç¬¦åˆé«˜æ–¯åˆ†å¸ƒï¼Œå³æœ‰ï¼š $$\\begin{aligned}f(x_1,x_2â€¦x_m) &amp;= \\prod_i^mf(x_i) \\&amp;= \\prod_i^m \\frac{1}{(2\\pi\\sigma_i^2)^{1/2}} \\exp{\\frac{-(x_i - \\mu_i)^2}{2\\sigma_i^2}} \\&amp;= \\frac{1}{(2\\pi)^m||\\Sigma||}^{1/2} \\exp{-\\frac{1}{2}(X - \\mu)^T\\Sigma^{-1}(X - \\mu)} \\\\end{aligned}$$ åªéœ€è¦è®¡ç®— X çš„æ–¹å·®å’Œå‡å€¼å³å¯ã€‚ å¦å¤–ï¼Œå¦‚æœ X å¾—æ¥æºäºä¸€ä¸ªå…¬å…±å¾—èµ„æºï¼Œå¯ä»¥å‡è®¾å„ä¸ªç‰¹å¾å¾—æ–¹å·®å‡ç›¸åŒ if we have reason to believe that noise in the observed _Xi _comes from a common source, then we might further assume that all of the Ïƒ_ik _are identical, regardless of the attribute _i _or class _k _(see the homework exercise on this issue). è´å¶æ–¯æ¨¡å‹å­˜åœ¨çš„é—®é¢˜ æ— åå·®çš„è´å¶æ–¯æ¨¡å‹æ˜¯ä¸ç°å®çš„ï¼Ÿ æ€è€ƒä¸€ä¸‹ï¼Œå¦‚æœå˜é‡çš„ç‰¹å¾ä¸€ä¸ªç¦»æ•£å‹çš„ï¼Œä¸€ä¸ªæ˜¯è¿ç»­æ€§çš„ï¼Œå¦‚ä½•è®¾è®¡å’Œæ±‚è§£æ¨¡å‹å‘¢ï¼Ÿé€»è¾‘å›å½’æ¨¡å‹ 2. ä»æœ´ç´ è´å¶æ–¯åˆ°é€»è¾‘å›å½’é¦–å…ˆåœ¨äº†è§£é€»è¾‘å›å½’æ¨¡å‹çš„ä¹‹å‰ï¼Œæˆ‘ä»¬ä»¥äºŒåˆ†ç±»ä¸ºä¾‹ï¼Œä½¿ç”¨æœ´ç´ è´å¶æ–¯çš„æ–¹æ³•æ¥åˆ¤åˆ«åˆ†ç±»ã€‚ $$\\begin{aligned}P(Y = c_1/X = x) &amp;= \\frac{P(Y = c_1)P(X =x/ Y =c_1)}{P(X = x)} \\&amp;=\\frac{P(Y = c_1) P(X =x/Y=c_1)}{\\sum_i^2 P(Y = c_1) P(X =x/Y=c_1)} \\&amp;=\\frac{1}{1 + \\frac{P(Y=c_2)P(X =x/Y=c_2)}{P(Y =c_1)P(X =x/Y=c_1)}} , (3) \\\\end{aligned}$$ ç”±äº $P(X = x/ Y= c_1 ) = f(x) = \\frac{1}{(2\\pi)^m||\\Sigma||}^{1/2} \\exp{-\\frac{1}{2}(x - \\mu)^T\\Sigma^{-1}(x - \\mu)}$ å¸¦å…¥åˆ°å¼ï¼ˆ3ï¼‰ ä¸­ï¼Œå¯å¾—ï¼š $P(Y=c_1/X= x) = \\frac{1}{1 + \\exp(-z)} = \\sigma(z)$ è¿™å°±æ˜¯ Sigmoid Function $z = ln(\\frac{P(c1)P(x/c1)}{P(c2)P(x/c2)}) = ln\\frac{P(c1)}{P(c2)} + ln\\frac{P(x/c1)}{P(x/c2)}$ å…¶ä¸­ $P(Y=c_k) = \\frac{t}{n}$ï¼Œå¯çŸ¥ $ln\\frac{P(c1)}{P(c2)}$ æ˜¯å¸¸æ•° è¿™é‡Œå‡è®¾ $\\Sigma_1 = \\Sigma_2 = \\Sigma$ $$ln\\frac{P(x/c1)}{P(x/c2)} = \\frac{1}{2}(x-\\mu_1)^T\\Sigma^{-1}(x-\\mu_1) - \\frac{1}{2}(x-\\mu_2)^T\\Sigma^{-1}(x-\\mu_2) \\= (\\mu_1-\\mu_2)^T\\Sigma^{-1}x - \\frac{1}{2}( \\mu_1^T\\Sigma^{-1}\\mu_1 - \\mu_2^T\\Sigma^{-1}\\mu_2 )$$ ä»¤ $b = ln\\frac{P(c1)}{P(c2)} + - \\frac{1}{2}( \\mu_1^T\\Sigma^{-1}\\mu_1 - \\mu_2^T\\Sigma^{-1}\\mu_2 )$, $w^T = (\\mu_1-\\mu_2)^T\\Sigma^{-1}$ åˆ™æœ‰ $z = w^Tx + b$ è¿™é‡Œå…¶å®æ˜¯æœ‰ä¸€ä¸ªå·®å¼‚ï¼Œå› ä¸º w å’Œ b ä¹‹é—´æ˜¯æœ‰æŸç§ä¾èµ–å…³ç³»çš„ï¼Œä½†æ˜¯å¦‚æœåªçœ‹ä½œæ˜¯ w å’Œ bå˜é‡ï¼Œåˆ™wå’Œbä¹‹é—´ç›¸äº’ç‹¬ç«‹ï¼Œè¿™æ ·å­å¤§å¤§å‡å°‘äº†è®­ç»ƒçš„å‚æ•°ï¼Œè¿™ä¹Ÿå°±æ˜¯é€»è¾‘å›å½’ã€‚ 3. ä»å›å½’æ¨¡å‹åˆ°é€»è¾‘å›å½’ è¿˜æ˜¯ä»¥äºŒåˆ†ç±»ä¸ºä¾‹ å›å½’æ¨¡å‹ä¸º $y(x) = W^Tx + b$ ï¼Œ è¿™é‡Œæˆ‘ä»¬æƒ³è¦æ‰¾åˆ°ä¸€ç§æ¨¡å‹ä½¿ï¼š$P_{w,b}(c/x)$ $$\\begin{cases} output , c1 ,, P_{w,b}(c/x) &gt;= 0.5 \\ otherwise ,, output ,c2\\end{cases}$$ è¿™é‡Œæˆ‘ä»¬è€ƒè™‘æ˜¯æœ‰ sigmoid funcion $\\sigma(z) = \\frac{1}{1 + \\exp{(-z)}}$å…¶å–å€¼èŒƒå›´ä¸º (0 , 1 )ï¼Œè‡ªå˜é‡å–å€¼ä¸º$( -\\inftyï¼Œ+\\infty)$, $z = w^Tx + b$å…¶å›¾å½¢å¦‚ä¸‹ï¼š å…¶å®å°±æ˜¯ä½¿ç”¨ sigmoid function æ¥æ›¿ä»£ p(y/x)çš„æ¦‚ç‡ï¼Œå› æ­¤è¿™ç§æ¨¡å‹ä¸å‰æ–‡çœ‹åˆ°æ¨¡å‹ä¸åŒã€‚å‰æ–‡ï¼ˆè´å¶æ–¯ï¼‰æ˜¯ä½¿ç”¨é—´æ¥è®¡ç®—ï¼Œå³ç”± P(y) å’Œ P(x/y) æ¥é—´æ¥æ±‚çš„ p(y/c)çš„æ¦‚ç‡ï¼Œè¿™ç§æ¨¡å‹å«åšç”Ÿæˆæ¨¡å‹ï¼ˆGenerative modelï¼‰ã€‚è€Œé€»è¾‘å›å½’ï¼Œæ˜¯ç›´æ¥é‡‡ç”¨ä¸€ä¸ªå‡½æ•°æ¥æ¨¡æ‹Ÿ p(y/x)çš„åˆ†å¸ƒï¼Œæˆä¸ºåˆ¤åˆ«æ¨¡å‹(discriminative model) 3.1 ç­–ç•¥é€»è¾‘å›å½’çš„æŸå¤±å‡½æ•°å¯ä»¥åˆ†ä¸ºä¸¤ç§ï¼Œä¸€ç§ä¸º maximum likelihood estimation ï¼Œå¦å¤–ä¸€ç§ä¸º the least squares , ä¸€èˆ¬é‡‡ç”¨æœ€å¤§ä¼¼ç„¶æ¦‚ç‡ã€‚ æƒ³ä¸€ä¸‹ä¸ºä»€ä¹ˆï¼Ÿ å…¶æŸå¤±å‡½æ•°ä¸ºï¼šå‡è®¾ $z_1,z_2 â€¦ z_m ä¸º c_1, z_{m+1}â€¦ z_n ä¸º c_2$åˆ™$$L(w,b) = \\prod_i^{m} \\sigma(z_i) \\prod_{i = m+1}^n (1- \\sigma(z_i))\\\\ln{L} = \\sum_i^m \\ln{(\\sigma(z_i))} + \\sum_{m+1}^{n} \\ln{(\\sigma(z_i))} \\= E_{x\\sim c_1} \\ln{\\sigma(z)} + E_{x\\sim c_2} \\ln{\\sigma(z)}\\= \\sum_i^n\\hat{y_i}\\ln{\\sigma(z_i)} + (1 - \\hat{y_i} )ln{(1 - \\sigma(z_i))}$$ å¯¹äºæ¯ä¸€ä¸ªç»™å®šçš„x, ä½¿ $f = \\sigma(z_i)ln{\\sigma(z_i)} + (1 - \\sigma(z_i) )ln{(1 - \\sigma(z_i))}$ æœ€å¤§ã€‚è¿™é‡Œç›´æ¥å¯¹w,b æ±‚åå¯¼æ•°ï¼Œä½¿ç”¨éšæœºæ¢¯åº¦ä¸‹é™æ³•å³å¯ã€‚ $$\\frac{df}{dw} = \\frac{df}{dz} \\frac{dz}{dw} \\ \\frac{d\\sigma}{dz} = \\frac{\\exp{(-z)}}{(1 + \\exp{(-z)})^2} = \\sigma(1 - \\sigma) \\\\frac{dz}{dw} = x\\\\frac{df}{dw} = (y(1-\\sigma) - (1-y)\\sigma)x = (y - \\sigma)x \\\\frac{df}{db} = (y(1-\\sigma) - (1-y)\\sigma)x = y - \\sigma$$ 4. æ€è€ƒä¸€ä¸‹ æœ´ç´ è´å¶æ–¯æ³•å’Œé€»è¾‘å›å½’åšåˆ†ç±»é—®é¢˜çš„æ—¶å€™ï¼Œæœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿå„è‡ªæœ‰ä»€ä¹ˆä¼˜åŠ¿ï¼Ÿ é€»è¾‘å›å½’çš„æŸå¤±å‡½æ•°ä½¿ç”¨ cross entropy å’Œ square error ç”¨ä»€ä¹ˆä¼˜åŠ£ï¼Ÿ å‚è€ƒ ã€Šç»Ÿè®¡å­¦ä¹ æ–¹æ³•ã€‹ æèˆªï¼Œ chapter 4 Machine Learning , Tom M. Mitchell , chapter 3 Classification æå®æ¯…","link":"/2020/09/22/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%92%8C%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"},{"title":"å¤šå±‚æ„ŸçŸ¥æœºä¸BPç®—æ³•","text":"å‰é¢è®²è§£ æ„ŸçŸ¥æœº , è¯´æ˜å…¶æœ‰ä¸€ä¸ªå¾ˆå¤§çš„ä¸è¶³ä¹‹å¤„ï¼Œå³å®ƒæ— æ³•æ±‚è§£éçº¿æ€§é—®é¢˜æˆ–è€…å¼‚æˆ–é—®é¢˜ã€‚åé¢å°±å‘å±•å‡ºäº†å¤šå±‚æ„ŸçŸ¥æœºï¼ˆdeep feebforward network or multilayer perceptronï¼‰ï¼Œä»¥åŠæ±‚è§£ä½¿ç”¨çš„BPç®—æ³•ã€‚è¿™ä¹Ÿæ˜¯æ·±åº¦å­¦ä¹ çš„åŸºç¡€ã€‚ http://speech.ee.ntu.edu.tw/~tlkagk/courses/ML_2016/Lecture/DL%20(v2).pdf 1. å¤šå±‚æ„ŸçŸ¥æœº 1.1 Neuronæˆ‘ä»¬å°†é€»è¾‘å›å½’æŠ½è±¡æˆä¸€ä¸ªneural networkçš„ä¸€ä¸ªâ€œNeuronâ€ï¼Œè€Œå¤šå±‚æ„ŸçŸ¥æœºå³æ˜¯å°†è¿™äº›ç¥ç»å…ƒè¿æ¥åœ¨ä¸€èµ·ã€‚å¯¹äºæ·±åº¦å­¦ä¹ ç½‘ç»œæ¥è¯´ï¼Œå®ƒä¹Ÿæ˜¯æœ‰ä¸€ä¸ªä¸ªç¥ç»å…ƒç»„æˆï¼Œä½†æ˜¯å®ƒå¯ä»¥æœ‰å„ä¸ªä¸åŒçš„ç½‘ç»œç»“æ„ï¼ˆç½‘ç»œå †å ï¼‰ã€‚ 1.2 Multilayer Perceptronå¤šå±‚æ„ŸçŸ¥æœº,å…¶ä¸­ä¸€ä¸ªå°ç™½è‰²é•¿æ–¹å½¢ï¼ˆfï¼‰ä¸ºä¸€ä¸ªä¸€ä¸ªâ€Neuronâ€ï¼Œæ¯ä¸€å±‚å¯ä»¥æœ‰å¤šä¸ª Neruon, è€Œå¤šå±‚æ„ŸçŸ¥æœºå¯ä»¥æœ‰å¾ˆå¤šå±‚ã€‚å…¶ä¸­ç°è‰²éƒ¨åˆ†ä¸ºéšå«å±‚ï¼ˆHidden Layerï¼‰ï¼Œç»¿è‰²ä¸ºè¾“å…¥å±‚(Input Layer),é»„è‰²éƒ¨åˆ†ä¸ºè¾“å‡ºå±‚ (Output Layer) ã€‚è“è‰²çº¿å¯ä»¥çœ‹ä½œæ˜¯ä¸€ä¸ªæƒé‡ï¼ˆw), è€Œ f ä»£è¡¨æ¿€æ´»å‡½æ•°ï¼ˆactivate functionï¼‰ã€‚ ç›®å‰æ¿€æ´»å‡½æ•°æœ‰å¾ˆå¤šç§ï¼Œå¸¸ç”¨çš„æœ‰ Sigmoidã€Relu ã€Tanhã€Leaky Reluã€Softmax ç­‰ã€‚ å¤šå±‚æ„ŸçŸ¥æœºæ˜¯ä¸€ç§ç›‘ç£æ¨¡å‹ï¼Œå®ƒå¯ä»¥è§£å†³åˆ†ç±»å’Œå›å½’é—®é¢˜ï¼ˆè¾“å‡ºå±‚çš„ç»“æ„æœ‰æ‰€ä¸åŒï¼‰ã€‚ä¸€èˆ¬åœ¨è§£å†³åˆ†ç±»é—®é¢˜æ—¶ï¼Œå®ƒä¼šåœ¨è¾“å‡ºå±‚å‰å¢åŠ ä¸€å±‚ softmax å¤„ç†ï¼Œæ¥æ¨¡æ‹Ÿå„ä¸ªåˆ†ç±»çš„æ¦‚ç‡ã€‚ä¸‹é¢ä¸€åˆ†ç±»é—®é¢˜ä¸ºä¾‹å­ï¼Œæ¥äº†è§£å®ƒçš„æ•´ä¸ªè¿ä½œè¿‡ç¨‹ã€‚ 1.2.1 æ•°æ®æµåŠ¨ æ•°æ®æ˜¯å¦‚ä½•åœ¨æ„ŸçŸ¥æœºå†…æµåŠ¨çš„ï¼Ÿ æœ¬è´¨ä¸Šï¼Œå¤šå±‚æ„ŸçŸ¥æœºæ˜¯ä¸€ä¸ªä¸ªçŸ©é˜µçš„ä¹˜æ³•è¿ç®—ï¼Œå®ƒçš„æ•°æ®æµæ˜¯ä»å‰å‘åæµåŠ¨çš„ï¼Œå³ Feedforward å¦‚ï¼Œè¾“å…¥ä¸º $x = [x_1, x_2,â€¦,x_m]$, å…¶ä¸­$x \\in R^n$, å³å•ä¸ªxå­˜åœ¨mä¸ªç‰¹å¾ã€‚å¯¹äºéšå«å±‚ç¬¬å…ƒç´ æœ‰ï¼š $w_{ji}^L$ä»£è¡¨ç¬¬Lå±‚çš„jä¸ªzå€¼ä¸ç¬¬L-1å±‚çš„ç¬¬iä¸ªè¾“å…¥ä¹‹é—´çš„æƒé‡ $b_j^L$ä»£è¡¨ç¬¬Lå±‚çš„åç§»é‡ $a_i^L$ä»£è¡¨ç¬¬Lå±‚è¾“å‡ºçš„ç¬¬içš„å…ƒç´ ï¼ŒåŒæ—¶æ˜¯ç¬¬L+1çš„è¾“å…¥çš„ç¬¬iä¸ªå…ƒç´  fä¸ºæ¿€æ´»å‡½æ•° $z_{j}^L = \\sum_i w_{ji}^La_i^{L-1} + b_j^L$ $a_j^L = \\sigma(z_j^L)$ å¯¹äºè¾“å…¥å±‚æœ‰ï¼š $a_i^0 = x_i$ å¯¹äºè¾“å‡ºå±‚æœ‰ï¼ˆè¿™é‡Œä¸è€ƒè™‘softmaxï¼‰ï¼š $y_i = a_i^L$ æ•°æ®æµé€šä¸ºï¼š $$ \\begin{aligned} z^L &= \\begin{bmatrix} w_{00}^L & w_{01}^L& ... &w_{0i}^L\\\\ w_{10}^L & w_{11}^L& ... &w_{1i}^L\\\\ ... & ...& ... & ...\\\\ w_{j0}^L & w_{j1}^L& ... &w_{ji}^L\\\\ \\end{bmatrix} \\begin{bmatrix} a_0^{L-1}\\\\ a_1^{L-1}\\\\ ...\\\\ a_i^{L-1}\\\\ \\end{bmatrix} + \\begin{bmatrix} b_0^{L}\\\\ b_1^{L}\\\\ ...\\\\ b_j^{L}\\\\ \\end{bmatrix} \\\\ & = w^La^{L-1} + b^L \\\\ a^L &= f(z^L) = f(w^L a^{L-1} + b^L ) \\end{aligned}\\tag{2} $$ å…¶ä¸­ $w^L$ ä¸º jxi å¾— matrix, jä¸ºç¬¬Lå±‚çš„è¾“å‡ºDimensionsï¼Œiä¸ºç¬¬``Lå±‚çš„è¾“å…¥çš„Dimensionsã€‚æ ¹æ®å…¬å¼1, 2,å¯ä»¥æ¨å‡ºè¾“å‡ºä¸º: $$ \\begin{aligned} y &= a^L \\\\ &= f(w^La^{L-1} + b^L ) = f(w^Lf(w^{L-1}a^{L-2}+ b^{L-1})+ b^L ) \\\\ &= ... \\\\ &= f(w^Lf(w^{L-1}f(...f(...f(w^1a^0 + b^0) + b^{l} ) + b^{L-1}) + b^L ) \\\\ \\end{aligned}\\tag{3} $$ 1.2.2 æŸå¤±å‡½æ•°ç”±äºå¤šå±‚æ„ŸçŸ¥æœºå¯ä»¥å¤„ç†åˆ†ç±»å’Œå›å½’é—®é¢˜ï¼Œæ‰€æœ‰å…¶æŸå¤±å‡½æ•°ä¹Ÿåˆ†ä¸ºä¸¤ç±»ï¼Œä¸‹é¢ä»¥åˆ†ç±»é—®é¢˜ä¸ºä¾‹ã€‚å¯ä»¥çœ‹ä½œæ˜¯å¤šåˆ†ç±»é—®é¢˜ï¼Œè¿™æ˜¯å¯ä»¥é‡‡å–æœ€å¤§ä¼¼ç„¶æ¦‚ç‡æ¥ä½œä¸ºå…¶æŸå¤±å‡½æ•°ï¼ˆäº¤å‰ç†µï¼‰ã€‚åšåˆ†ç±»é—®é¢˜æ—¶ï¼Œéœ€è¦åœ¨è¾“å‡ºå±‚ä¹‹å‰å¢åŠ ä¸€ä¸ª softmax å±‚ã€‚ Tips è¿™é‡Œçœ‹å‡ºå¤šå±‚æ„ŸçŸ¥æœºå…¶å®æ˜¯ä¸€ä¸ª discriminative model ã€‚ å‡è®¾å…±æœ‰mä¸ªç±»åˆ« $(c_1,â€¦c_m)$ï¼Œ$\\theta$ ä¸ºæ‰€æœ‰çš„å‚æ•°ï¼Œåˆ™ Loss Function ä¸ºï¼š $$ \\begin{aligned} L(\\theta) &= \\sum_i^m {\\sum_{x^j\\in c_i}\\ln(y_i^j) + \\sum_{x^j\\notin c_i}\\ln(1 - y_i^j) } \\\\ & = \\sum_i^m { E_{x^j\\sim c_i} \\ln{y_i^j} + E_{x^j\\sim \\bar{c_i}} \\ln{(1 - y_i^j) }} \\\\ &= \\sum_i^m\\sum_j^{n_{c_i}} \\{\\hat{y}_{i}^j\\ln{y_i^j} + (1- \\hat{y}_{i}^j) \\ln{(1 - y_i^j)} \\} \\\\ &= \\sum_i^n \\sum_j^m \\hat{y}_j\\ln{y_j} + (1-\\hat{y}_j )\\ln{(1 - y_j)} \\end{aligned} \\tag{4} $$ æˆ–è€…ä½¿ç”¨ $$ \\begin{aligned} L(\\theta) &= \\sum_i^m {\\sum_{x^j \\in c_i}\\ln(y_i^j)} \\\\ & = \\sum_i^m {E_{x^j\\sim c_i} \\ln{y_i^j} } \\\\ &= \\sum_i^m\\sum_j^{n_{c_i}} \\hat{y}_{i}^j \\ln{y_i^j} \\\\ &= \\sum_i^n \\sum_j^m \\hat{y}_j\\ln{y_j} \\end{aligned} \\tag{5} $$ å…¶ä¸­ $\\hat{y} = \\begin{bmatrix} 0,0,.,1,.,0 \\end{bmatrix}^T$ ,one-shot vector çš„æ ·å¼ Tips: å¦‚æœæ˜¯å›å½’æ¨¡å‹çš„è¯ï¼Œæ— éœ€æ·»åŠ  softmax å±‚ï¼Œè€Œä¸”å¯ä»¥ä½¿ç”¨ mean square errors ä½œä¸ºæŸå¤±å‡½æ•° Thinking å¼4å’Œå¼5åœ¨ä½¿ç”¨è¿‡ç¨‹ä¸­ï¼Œæœ‰ä»€ä¹ˆåŒºåˆ«å‘¢ï¼Ÿé‚£ä¸ªæ•ˆæœæ›´å¥½å‘¢ï¼Ÿ äº†è§£äº†æŸå¤±å‡½æ•°ä¹‹åï¼Œé‚£ä¹ˆå¦‚ä½•æ¥å¯»æ‰¾æŸå¤±å‡½æ•°çš„æå¤§å€¼å‘¢ï¼Ÿæˆ–è€…æ˜¯å¦‚ä½•è§£å†³è¿™ä¸ªä¼˜åŒ–é—®é¢˜å‘¢ï¼Ÿè¿™é‡Œå°±å¼•å‡ºäº†BackPropagation, å³BPç®—æ³• 2. BPç®—æ³•ç”±å¼å­ï¼ˆ5ï¼‰ å¯çŸ¥, ä½¿ç”¨SGDæ¥è§£è¯¥ä¼˜åŒ–é—®é¢˜ï¼Œåœ¨ç»™å®šxçš„æƒ…å†µä¸‹, ä»¤ c ä¸ºæŸå¤±å‡½æ•°ã€‚é¦–å…ˆå¯¹éšå«å±‚æŸä¸ªå‚æ•°æ±‚åå¯¼æ•°ï¼Œå¦‚ $w_{ji}^L$ $$\\frac{dc}{dw_{ji}^L} = \\frac{dc}{da_j^L}\\frac{da_j^L}{dw_{ji}^L} \\tag{6}$$ å…¶ä¸­ $\\frac{da_j^L}{dw_{ji}^L}$ $$\\frac{da_j^L}{dw_{ji}^L} = \\frac{da_j^L}{dz_j^L}\\frac{dz_j^L}{dw_{ji}^L} = fâ€™(z_j^L)\\frac{dz_j^L}{dw_{ji}^L} = fâ€™(z_j^L)a_i^{L-1} \\tag{7}$$ å…¶ä¸­$\\frac{dc}{da_j^L}$ $$\\begin{aligned}\\delta_j^L &amp;= \\frac{dc}{da_j^L} \\&amp;= \\sum_k^K \\frac{dc}{dz_k^{L+1}}\\frac{dz_k^{L+1}}{da_j^L}\\&amp; = \\sum_k^K\\frac{dc}{dz_k^{L+1}}w_{kj}^{L+1} \\&amp;= \\sum_k^K\\frac{dc}{da_k^{L+1}}\\frac{da_k^{L+1}}{dz_k^{L+1}}w_{kj}^{L+1} \\&amp;= \\sum_k^K \\delta_k^{L+1}fâ€™(z_k^{L+1})w_{kj}^{L+1}\\end{aligned}\\tag{8}$$ ä»¤ $\\delta^L = \\begin{bmatrix} \\delta_1^L, â€¦, \\delta_J^L \\end{bmatrix}^T$, $\\sigma ^L = \\begin{bmatrix} fâ€™(z_1^L), â€¦, fâ€™(z_J^L) \\end{bmatrix}^T$, $w^L = \\begin{bmatrix} w_1^L,â€¦,w_J^L\\end{bmatrix}$ åˆ™ $$\\begin{aligned}\\delta_j^L &amp;= \\sum_k^K \\delta_k^{L+1}fâ€™(z_k^{L+1})w_{kj}^{L+1} \\&amp;= \\langle{(\\delta^{L+1} \\odot \\sigma^L),w_j^{L+1}} \\rangle\\end{aligned} \\tag{9}$$ ç”±äº$\\delta^L = \\begin{bmatrix} \\delta_1^L, â€¦, \\delta_J^L \\end{bmatrix}^T$, æ•…ï¼š $$\\delta^L =\\begin{bmatrix} \\delta_1^L, â€¦, \\delta_J^L \\end{bmatrix}^T = (w^{L+1})^T (\\delta^{L+1} \\odot \\sigma^L) \\tag{10}$$ å› æ­¤æ‰¾åˆ°äº†$\\delta^L$å’Œ$\\delta^{L+1}$ ä¹‹é—´çš„å…³ç³»ï¼Œä¸€æ—¦å¾—åˆ°äº†$\\delta^{L+1}$å°±å¯ä»¥æ±‚å‡º$\\delta^L$ã€‚ä»¤ $\\frac{dc}{dw_j^L} =\\begin{bmatrix}\\frac{dc}{dw_{j1}^L},â€¦,\\frac{dc}{dw_{jI}^L}\\end{bmatrix}^T$åˆå› ä¸ºï¼š$\\frac{dc}{dw_{ji}^L} = fâ€™(z_j^L)a_i^{L-1}\\delta_j^L$æ•…æœ‰ $$\\frac{dc}{dw_{j}^L} = \\sigma^L \\odot a^{L-1} \\odot \\delta^L \\tag{11}$$åœ¨è¾“å‡ºå±‚æœ‰ï¼š$\\frac{dc}{dy}$ï¼Œ è¿™ä¸ªè¦æ ¹æ®å…·ä½“çš„æŸå¤±å‡½æ•°æ¥ç¡®å®š $\\frac{dy_i}{da_i^L}$ è¿™ä¸ªå¦‚æœæ²¡æœ‰ softmax å±‚æˆ–è€…è¯´æ˜¯å›å½’é—®é¢˜çš„è¯ï¼Œå€¼å› ä¸º1 Tips å¦‚æœæ˜¯softmaxçš„è¯ï¼Œåº”è¯¥æ€ä¹ˆåšï¼Ÿ å› æ­¤ï¼Œå¯¹æœ€åä¸€ä¸ªéšå«å±‚çš„è¾“å‡ºæœ‰ $$\\begin{aligned} \\delta &amp;= \\frac{dc}{da} = \\frac{dc}{dy}\\frac{dy}{da}\\end{aligned} \\tag{12}$$ ç„¶åä¸€æ¬¡å‘å‰æ±‚è§£ï¼Œå³å¯æ±‚å‡ºå¯¹æ‰€æœ‰å‚æ•°çš„å€’æ•°ã€‚ å¯¹ $b_j^L$æ±‚å¯¼æ•°æ—¶ï¼š $\\frac{dc}{db_{j}^L} = \\frac{dc}{da_j^L}\\frac{da_j^L}{db_j^L} = \\delta_j^Lfâ€™(z_j^L) \\\\frac{da_j^L}{db_{j}^L} = \\frac{da_j^L}{dz_j^L}\\frac{dz_j^L}{db_{j}^L} = fâ€™(z_j^L)$å› æ­¤ $$\\frac{dc}{db^L} = \\delta^L \\odot \\sigma^L$$","link":"/2020/09/23/%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA%E4%B8%8EBP%E7%AE%97%E6%B3%95/"},{"title":"çº¿æ€§å›å½’","text":"1. çº¿æ€§å›å½’æ¨¡å‹ç»™å®šæ•°æ®é›† $D = { (x_1,y_1),(x_2,y_2) â€¦,(x_n,y_n)}$, å…¶ä¸­ $x_i = (x_i^1, x_i^2, â€¦ x_i^m)$ã€‚ çº¿æ€§å›å½’æ˜¯è¯•å›¾ä½¿ç”¨ä¸€ä¸ªçº¿æ€§æ¨¡å‹æ¥å°½å¯èƒ½çš„é¢„æµ‹å®é™…æ•°å€¼çš„è¾“å‡ºæ ‡è®°ã€‚ å‡è®¾ï¼Œä½¿ç”¨å‡½æ•°: $$ \\begin{aligned} y = w^Tx + b \\\\ w = \\begin{bmatrix} w^1 \\\\ ...\\\\ w^m \\end{bmatrix} \\end{aligned} $$ b æ˜¯ä¸€ä¸ª scalar ã€‚ä½¿ç”¨å‡æ–¹è¯¯å·®ä½œä¸ºå›å½’æ¨¡å‹çš„æ€§èƒ½åº¦é‡ï¼Œåˆ™å¯ä»¥è½¬åŒ–ä¸ºä¸€ä¸ªæ— çº¦æŸçš„ä¼˜åŒ–é—®é¢˜ï¼š $\\min_{w,b} L(w,b) = \\frac{1}{2n}\\sum_i^n(y_i - \\hat{y}_i)^2$ è§£å†³è¿™ä¸ªä¼˜åŒ–é—®é¢˜ï¼Œå¯ä»¥æ±‚å¯¼å¹¶ä»¤å…¶åå¯¼æ•°ä¸º0ï¼Œå³å¯ã€‚ä¸‹é¢æ˜¯åˆ†åˆ«å¯¹ w , b æ±‚å¯¼çš„ç»“æœ $$\\begin{aligned} \\frac{dL}{dw} &amp;= \\frac{1}{2n}\\sum_i^n 2(y_i-\\hat{y}_i)\\frac{dy_i}{dw} \\&amp;= \\frac{1}{n}\\sum_i^n(y_i-\\hat{y}_i)x_i \\qquad (1)\\\\frac{dL}{db} &amp;= \\frac{1}{n}\\sum_i^n(y_i - \\hat{y}_i) \\qquad (2)\\end{aligned}$$ é€šå¸¸ä¼šæŠŠ(1),(2) å¼å†™æˆçŸ©é˜µçš„å½¢å¼ï¼Œå³: $$\\begin{aligned}\\frac{dL}{dw}&amp;= \\frac{1}{n}X^T(Xw - \\hat{Y}) \\qquad (3) \\\\frac{dL}{db}&amp;= \\frac{1}{n}I(Xw -\\hat{Y}) \\qquad (4) \\\\end{aligned}$$ å…¶ä¸­ $X=\\begin{bmatrix}x_1 \\ x_2 \\ â€¦ \\ x_n \\end{bmatrix}$, $\\hat{Y}=\\begin{bmatrix}\\hat{y}_1 \\ \\hat{y}_2 \\ â€¦ \\ \\hat{y}_n\\end{bmatrix}$, $I=\\begin{bmatrix}1,1 â€¦ 1\\end{bmatrix}$ ä»¤å¼ï¼ˆ3ï¼‰ç­‰äº0ï¼Œ å¯ä»¥å¾—åˆ° $w^{\\star} = (X^TX)^{-1}X^T\\hat{Y}$, æ­¤æ—¶ $A = X^TX$ å¿…é¡»æ˜¯éå¥‡å¼‚çŸ©é˜µã€‚ä½†æ˜¯å®é™…æƒ…å†µä¸‹ï¼Œå¯èƒ½å­˜åœ¨Aå¹¶ä¸æ˜¯æ»¡ç§©çš„ï¼Œæ¯”å¦‚ç‰¹å¾çš„ç»´åº¦å¤§äºæ ·æœ¬æ•°ã€‚ å› æ­¤ï¼Œæ­¤æ—¶å¯èƒ½ä¼šæ¥è§¦å¤šä¸ªwï¼Œèƒ½å¤Ÿä½¿å‡æ–¹è¯¯å·®æœ€å°åŒ–ã€‚é€‰æ‹©å“ªä¸€ä¸ªä½œä¸ºæœ€ä¼˜çš„wï¼Œç”±ç®—æ³•çš„å½’çº³åå¥½æ¥å†³å®šï¼Œæ¯”å¦‚å¼•å…¥æ­£åˆ™åŒ–é¡¹ã€‚ 2. å¯¹æ•°ä¼¼ç„¶ä¼°è®¡ä½¿ç”¨çº¿æ€§å›å½’åšåˆ†ç±»é—®é¢˜ï¼Œä»¥äºŒåˆ†ç±»é—®é¢˜ä¸ºä¾‹ã€‚ å¯ä»¥å°†å…¶ç»“æœyæ˜ å°„åˆ°[0,1]åŒºé—´ï¼Œç„¶åè§„å®šå…¶å€¼å¤§äº0.5ä½œä¸ºæ­£ä¾‹ï¼Œå¦åˆ™ä½œä¸ºåä¾‹ã€‚ å¦‚ä½•é€‰æ‹©æ˜ å°„å‡½æ•° f å‘¢ï¼Œè¿™é‡Œå¯ä»¥é‡‡ç”¨ sigmoid å‡½æ•°ï¼š$$\\begin{aligned} f &amp;= \\sigma(z) = \\frac{1}{1 + \\exp{-z}} \\ z &amp;= w^Tx + b \\\\end{aligned}$$å…¶æ›²çº¿ä¸ºï¼šsigmoid æ›²çº¿æ­¤æ—¶ï¼Œå°†fçœ‹ä½œæ˜¯æ¦‚ç‡åˆ†å¸ƒï¼Œå¯ä»¥é‡‡ç”¨æœ€å¤§ä¼¼ç„¶æ¦‚ç‡ä½œä¸ºæ€§èƒ½åº¦é‡ï¼ˆå®ƒç­‰ä»·äºæœ€å°åŒ–äº¤å‰ç†µï¼‰ç­‰ä»·äºä¼˜åŒ–é—®é¢˜ï¼š $$\\min_{w,b} L(w,b) = -\\sum_i^n(\\hat{y}_i\\log(f(x_i)) + (1-\\hat{y}_i)\\log(1 - f(x_i)))$$ åˆ†åˆ«å¯¹ w,bæ±‚åå¯¼æ•°å¯å¾—ï¼š $$ \\begin{aligned} \\frac{dL}{dw} &= -\\sum_i^n(\\frac{\\hat{y}_i}{f}\\frac{df}{dw} - \\frac{1-\\hat{y}_i}{1-f}\\frac{df}{dw}) \\\\ &= -\\sum_i^n(\\frac{\\hat{y}_i}{f}f(1-f)x_i - \\frac{1-\\hat{y}_i}{1-f}f(1-f)x_i )) \\\\ &= -\\sum_i^n(\\hat{y}_i - f)x_i \\qquad (5) \\\\ \\frac{dL}{db} &= -\\sum_i^n(\\hat{y}_i - f) \\qquad (6) \\end{aligned} $$ åˆ†åˆ«å¯¹ä¸ºw,bæ±‚åå¯¼æ•°å…¶ä¸­$f = f(x_i)$ã€‚ å¯ä»¥å‘ç°ä¸çº¿æ€§å›å½’çš„åå¯¼æ•°æœ‰ä¸€æ ·çš„æ ¼å¼ã€‚ 3. LDA çº¿æ€§åˆ¤åˆ«åˆ†æLDAï¼ˆLinear Discriminant Analysis), åˆç§°ä¸º fisher åˆ¤åˆ«åˆ†æ ã€‚å®ƒçš„ä¸»è¦æ€æƒ³æ˜¯ï¼Œå°†ç»™å®šçš„æ ·æœ¬ï¼ŒæŠ•å½±åˆ°ä¸€æ¡ç›´çº¿ä¸Šï¼Œå¹¶ä¸”ä¿è¯ç±»å†…çš„æŠ•å½±ç‚¹è¶Šæ¥è¿‘è¶Šå¥½ï¼Œä½†æ˜¯ç±»é—´çš„æŠ•å½±ç‚¹è¶Šåˆ†æ•£è¶Šå¥½ã€‚ç±»å†…æŠ•å½±ç‚¹ï¼Œè¶Šæ¥è¿‘è¶Šå¥½ï¼Œå¯ä»¥é‡‡ç”¨æ–¹å·®ï¼ˆåæ–¹å·®ä¸¾è¯ï¼‰æŒ‡æ ‡æ¥è¡¡é‡ï¼Œå³ä½¿å…¶åŒç±»æ ·æœ¬ä¹‹é—´çš„ååå·®å°½å¯èƒ½çš„å°ã€‚å¯¹äºç±»é—´çš„æŠ•å½±ç‚¹ï¼Œè¶Šåˆ†æ•£è¶Šå¥½ã€‚è¿™é‡Œå¯ä»¥é‡‡ç”¨ä¸åŒç±»åˆ«ä¹‹é—´çš„å‡å€¼ç›¸å·®å°½å¯èƒ½çš„å¤§ã€‚æ€»ç»“èµ·æ¥çš„å…¬å¼ä¸º: $$\\max_{w} J(w) = \\frac{||w^T\\mu_0 - w^T\\mu_1||}{w^T\\Sigma_0w + w^T\\Sigma_1w}$$ LDAçš„åº¦é‡å‡½æ•°w ä»£è¡¨è¢«æŠ•å½±çš„ç›´çº¿ã€‚ ä»¤$S_w = \\Sigma_0 + \\Sigma_1$,$S_b = (\\mu_0 - \\mu_1)(\\mu_0 - \\mu_1)^T$åˆ™$J(w) = \\frac{w^TS_bw}{w^TS_ww}$ã€‚ç”±äºwä»£è¡¨è¢«æŠ•å½±çš„ç›´çº¿ï¼Œåªä¸å…¶æ–¹å‘æœ‰å…³ï¼Œä¸å¦¨è®¾ç½®$w^TS_ww = 1$, åˆ™è½¬åŒ–ä¸ºä»¥ä¸‹æœ‰çº¦æŸçš„ä¼˜åŒ–é—®é¢˜ $$\\begin{aligned}&amp;\\min_{w}\\quad -w^TS_bw \\&amp;s.t \\quad w^TS_ww = 1\\end{aligned}$$ å¯ä»¥ä½¿ç”¨æ‹‰æ ¼æœ—æ—¥ä¹˜æ³•å…¬å¼ï¼Œå¯å¾—: $$\\begin{aligned}L(w) &amp;= -w^TS_bw + \\lambda(w^TS_ww - 1) \\\\frac{dL}{dw} &amp;= -2S_bw + 2\\lambda S_ww = 0 \\&amp; S_w^{-1}S_bw = \\lambda w\\end{aligned}$$ æ˜“çŸ¥ï¼Œ$\\lambda$ ä¸ºçŸ©é˜µ $S_w^{-1}S_w$çš„ç‰¹å¾å€¼å’Œç‰¹å¾å‘é‡ã€‚ æ±‚è§£$S_w^{-1}$æ—¶ï¼Œè¦è€ƒè™‘å…¶ç¨³å®šæ€§ï¼Œé€šå¸¸é‡‡ç”¨å…¶SVDåˆ†è§£ã€‚å³$S_w^{-1} = V\\Sigma^{-1}U^T$ã€‚","link":"/2020/12/26/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"},{"title":"æ‹‰æ ¼æœ—æ—¥ä¹˜æ³•å’ŒKKTæ¡ä»¶","text":"åƒç§‹æ‘„äºé»„å±± æœ€è¿‘çœ‹äº† ã€Šæœ€ä¼˜åŒ–ç†è®ºä¸æ–¹æ³•ã€‹, å­¦ä¹ äº†å¸¸è§çš„ä¼˜åŒ–é—®é¢˜ä»¥åŠè§£å†³æ–¹æ³•ã€‚åŒæ—¶ï¼Œä¹‹å‰å­¦ä¹  SVM æ—¶ï¼Œå¯¹æ‹‰æ ¼æœ—æ—¥ä¹˜æ³•ä»¥åŠ KKT æ¡ä»¶æœ‰ä¸€äº›ç–‘é—®ï¼Œè¿™é‡Œåšä¸€ä¸‹å­¦ä¹ ç¬”è®°ï¼Œä¾¿äºåé¢å¤ä¹ å’Œç†è§£ï¼ Notion: åŒæ—¶å‚è€ƒäº†ç½‘ä¸Šæ‰¾åˆ°çš„ä¸€ä¸ªPPTï¼ˆè§é™„ä»¶ï¼‰ï¼Œè§‰å¾—å†™çš„ç›¸å½“æ£’ï¼ ä¸»è¦è®¾è®¡å››ç§ä¼˜åŒ–é—®é¢˜ï¼š æ— çº¦æŸä¼˜åŒ– ç­‰å¼çº¦æŸä¼˜åŒ– ä¸ç­‰å¼çº¦æŸä¼˜åŒ– ç­‰å¼å’Œä¸ç­‰å¼çº¦æŸä¼˜åŒ– è®¨è®ºçš„å¯¹è±¡æ˜¯ä¼˜åŒ–é—®é¢˜çš„æ ‡å‡†å½¢å¼: $$ \\begin{aligned} &\\min_{x\\in X } \\quad f(x) \\\\ &s.t \\quad \\begin{cases} g_i(x) = 0 \\quad i = 1,2...\\\\ h_j(x)","link":"/2021/08/18/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E6%B3%95%E5%92%8CKKT%E6%9D%A1%E4%BB%B6/"},{"title":"Soft-SVM","text":"ç”±äºéšæœºå™ªå£°æˆ–è€…è¯¯å·®ç­‰é—®é¢˜ï¼Œå› æ­¤å…è®¸ä¸€äº›ç‚¹ä¸ç¬¦åˆä¸ç­‰å¼çº¦æŸæ¡ä»¶ã€‚ç†æƒ³æ¡ä»¶ä¸‹(hard-svm), ä¼˜åŒ–é—®é¢˜å¦‚ä¸‹: $$\\begin{aligned}&amp;\\min_{w,b} \\frac{w^Tw}{2} \\s.t.\\quad &amp; y_i(w^Tx_i + b) - 1 &gt;= 0 \\quad i = 1,2,â€¦,n \\\\end{aligned}\\tag{1}$$ æˆ‘ä»¬å…è®¸å…¶å­˜åœ¨ä¸€å®šçš„è¿è§„é‡ï¼Œè¿™é‡Œå¼•å…¥æ¾å¼›å˜é‡ $\\eta &gt;= 0$, ä¼˜åŒ–é—®é¢˜å˜ä¸º: $$\\begin{aligned}&amp; \\min_{w,b} \\frac{w^Tw}{2} + C\\sum_i^n \\eta_i \\s.t. \\quad &amp; y_i(w^Tx_i + b) - 1 + \\eta_i &gt;= 0\\&amp; \\eta_i &gt;= 0\\ \\tag{2} \\end{aligned}$$ å…¶ä¸­ C &gt; 0 ,æˆä¸ºæƒ©ç½šå‚æ•°ï¼Œå½“Cæ¯”è¾ƒå¤§æ—¶å¯¹è¯¯åˆ†ç±»çš„æƒ©ç½šè¾ƒå¤§ï¼ŒCè¾ƒå°æ—¶å¯¹è¯¯åˆ†ç±»çš„æƒ©ç½šè¾ƒå°ï¼Œå…¶å€¼é€šå¸¸ç”±åº”ç”¨å†³å®šã€‚ä¼˜åŒ–é—®é¢˜ (2) å…¶å®ä¹Ÿæ˜¯ä¸ªå‡¸äºŒæ¬¡è§„åˆ’é—®é¢˜ï¼Œå…¶æ±‚è§£ä¸Hard-SVMä¸€æ · 1. Lagrange Multiplierå¯¹åº”çš„æ‹‰æ ¼æœ—æ—¥ä¹˜æ³•å…¬å¼ä¸º $$\\begin{aligned}L(w,b,\\eta,\\delta) &amp;= \\frac{w^Tw}{2} + C\\sum_i^n \\eta_i - \\sum_i^n \\alpha_i( y_i(w^Tx_i + b) - 1 + \\eta_i) - \\sum_i^n \\delta_i\\eta_i \\\\alpha_i &amp;&gt;= 0 \\quad \\delta_i &gt;=0 \\\\end{aligned} \\tag{3}$$ $\\theta_p(w,b) = \\max_{\\eta,\\delta}L(w,b,\\eta,\\delta)$ åˆ™ä¼˜åŒ–é—®é¢˜ï¼ˆ2ï¼‰å¯ä»¥å†™ä½œï¼š $$\\begin{aligned}&amp; \\min_{w,b} \\theta_p(w,b) = \\min_{w,b} \\max_{\\eta,\\delta} L(w,b,\\eta,\\delta) \\s.t.\\quad &amp; \\alpha_i &gt;= 0 \\quad \\delta_i &gt;=0 \\ &amp; y_i(w^Tx_i + b) - 1 + \\eta_i &gt;= 0\\&amp; \\eta_i &gt;= 0\\\\end{aligned} \\tag{4}$$ å…¶å¯¹å¶é—®é¢˜ä¸ºï¼š $$\\begin{aligned}&amp;\\max_{\\eta,\\delta} \\min_{w,b} L(w,b,\\eta,\\delta)\\s.t. \\quad &amp; \\eta_i &gt;=0 \\quad \\delta_i &gt;=0 \\ &amp; y_i(w^Tx_i + b) - 1 + \\eta_i &gt;= 0\\&amp; \\eta_i &gt;= 0\\\\end{aligned}\\tag{5}$$ è¯æ˜è§Hard-SVMæ±‚è§£è¿‡ç¨‹ æ±‚è§£ $\\min_{w,b} L(w,b,\\eta,\\del)$, åˆ†åˆ«å¯¹wå’Œbæ±‚å¯¼ï¼Œå¹¶ä»¤å…¶åå¯¼æ•°ä¸º0 $$\\begin{aligned}\\frac{dL}{dw} &amp;= w - \\sum_i^n\\alpha_iy_ix_i = 0\\\\frac{dL}{db} &amp;= -\\sum_i^n\\alpha_iy_i = 0\\\\end{aligned}\\tag{6}$$ å°†(6)å¸¦å…¥åˆ° L ä¸­ï¼Œå¾—åˆ° G","link":"/2020/10/10/SVM(2)_%20Soft-SVM/"},{"title":"Hard-SVM","text":"æ”¯æŒå‘é‡æœºï¼ˆSupport Vector Machineï¼‰ï¼Œ æ˜¯ä¸€ç§è§£å†³åˆ†ç±»å’Œå›å½’çš„ç»å…¸æœºå™¨å­¦ä¹ æ¨¡å‹ã€‚ä»¥è§£å†³åˆ†ç±»é—®é¢˜ä¸ºä¾‹ï¼Œå®ƒçš„æ ¸å¿ƒæ€æƒ³æ˜¯ï¼Œæœ€å¤§åŒ–è¾“å…¥å‘é‡åˆ°è¶…å¹³é¢çš„é—´éš”ã€‚ ä¹‹å‰åœ¨ æ„ŸçŸ¥æœº é‡Œé¢æˆ‘ä»¬å·²ç»äº†è§£åˆ°å…¶æ€æƒ³ä¸ºæ‰¾åˆ°ä¸€ä¸ªè¶…å¹³é¢ï¼Œæ¥åˆ’åˆ†ç‰¹å¾ç©ºé—´ä¸ºæ­£è´Ÿç©ºé—´ï¼Œä»è€Œå®ç°åˆ†ç±»çš„ç›®çš„ï¼ˆå¦‚ä¸‹å›¾ï¼‰ã€‚ä½†æ˜¯ï¼Œè¿™æ ·çš„è¶…å¹³é¢ä¸åªä¸€ä¸ªï¼Œæ€ä¹ˆæ¥ä»ä¸­æ‰¾åˆ°ä¸€ä¸ªæœ€ä¼˜çš„è¶…å¹³é¢å‘¢ï¼Ÿ å¦‚ä½•è¯„ä»·è¶…å¹³é¢çš„ä¼˜åŠ£å‘¢ï¼Ÿè¿™å°±æ˜¯SVMè§£å†³åˆ†ç±»é—®é¢˜çš„æ€æƒ³ã€‚ 1. Hard-SVM1.1 æ¨¡å‹SVMçš„æ€æƒ³ï¼Œé€šä¿—æ¥è®²æ˜¯ï¼Œæœ€å¤§åŒ– Margin(x), Margin(x)ä»£è¡¨ä¸ºï¼Œæ‰€æœ‰ç‚¹åˆ°è¶…å¹³é¢è·ç¦»ä¸­çš„æœ€å°è·ï¼Œ å³ $\\min{Distance(x_i)}$ i = 1,2,3â€¦,nåŒ–ä¸ºæœ€ä¼˜åŒ–çš„æ ‡å‡†å‹ä¸ºï¼š $$\\max_{w,b}Margin(x) = \\max_{w,b} \\min_{x_i}Distance(x_i) \\= \\max_{w,b}\\min_{x_i} \\frac{|w^Tx_i + b|}{||w||} \\s.t. \\quad y_i(w^Tx_i + b) &gt; 0$$ ç”±äº y = 1 or -1ï¼Œ ä¸”åˆ†ç±»æ­£ç¡®æ—¶ $yï¼ˆw^x + bï¼‰&gt; 0$, å› æ­¤ $ï½œw^T + bï½œ = y(w^T + b)$è¿™é‡Œå‡è®¾ï¼Œ$y(w^Tx +b ) &gt;= \\sigma &gt; 0$, æ­¤æ—¶é—®é¢˜æ”¹å†™ä¸ºï¼š$\\max_{w,b} \\frac{\\sigma}{||w||} \\s.t. \\quad y_i(w^Tx_i + b) &gt;= \\sigma$ ç”±äºæˆ‘ä»¬å¯ä»¥ç­‰æ¯”ä¾‹çš„ä¿®æ”¹ wå’Œbæ˜¯çš„ï¼Œ$\\sigma$ å˜ä¸º 1ï¼Œ è¿™æ ·åšå¹¶ä¸æ”¹å˜é—®é¢˜çš„è§£ã€‚åŒæ—¶ï¼Œ$\\frac{1}{||w||}$ç­‰åŒäº$\\frac{w^Tw}{2}$ï¼Œæ­¤æ—¶é—®é¢˜ä¿®æ”¹ä¸ºï¼š $$ \\begin{aligned} &\\min_{w,b}\\frac{w^Tw}{2} \\\\ s.t. \\quad &y_i(w^Tx_i + b) -1 >= 0 \\end{aligned} \\tag{2} $$ ç”±äºè¯¥é—®é¢˜æ˜¯å…¸å‹çš„äºŒæ¬¡ä¼˜åŒ–é—®é¢˜ï¼Œå¯ä»¥é‡‡ç”¨ä¼˜åŒ–å·¥å…·åŒ…æ¥è§£å†³ï¼Œä¹Ÿå¯ä»¥è½¬åŒ–ä¸ºå¯¹å¶é—®é¢˜è§£å†³ã€‚ 2. ç­–ç•¥å¦‚ä½•æ±‚è§£å¼ï¼ˆ1ï¼‰ä¸­çš„äºŒæ¬¡ä¼˜åŒ–é—®é¢˜ï¼Œè¿™é‡Œå¯ä»¥é‡‡ç”¨æ‹‰æ ¼æœ—æ—¥ä¹˜æ³•æ¥è§£å†³ã€‚é‡‡ç”¨æ‹‰æ ¼æœ—æ—¥ä¹˜æ³•æœ‰ä¸€ä¸ªå‰æï¼Œå³è¯¥é—®é¢˜æ»¡è¶³ KKT æ¡ä»¶ 2.1 Dual Problemä¼˜åŒ–é—®é¢˜çš„æ ‡å‡†å½¢å¼ä¸º: $\\max_{x} f(x) \\s.t. \\quad h(x_i) = 0 \\\\quad g(x_i) &gt;= 0 \\quad(2)\\$ è¿™é‡Œå¼•å…¥å¹¿ä¹‰æ‹‰æ ¼æœ—æ—¥ä¹˜æ³•: $$L(x,\\lambda,\\eta) = f(x) - \\sum_i \\lambda_ih(x_i) - \\sum_i\\eta_ig(x_i) \\quad(3) \\\\eta_i &gt;= 0$$ è€ƒè™‘xçš„å‡½æ•°$\\theta_p(x) = \\max_{\\lambda,\\eta,\\eta &gt;= 0} L(x,\\lambda,\\eta)$å¦‚æœxä¸æ»¡è¶³å¼ï¼ˆ2ï¼‰ä¸­çš„çº¦æŸæ¡ä»¶ï¼Œå³å­˜åœ¨ $h(x) \\neq 0$ æˆ–è€… $g(x) &lt; 0$, æ­¤æ—¶æ€»å­˜åœ¨ ä¸€ä¸ª$\\lambda$ æˆ–è€…$\\eta$ ä½¿å¾—ï¼Œ $\\eta g(x) \\rightarrow +\\infty \\\\lambda h(x) \\rightarrow +\\infty$è€Œå½“ xç¬¦åˆï¼ˆ2ï¼‰ä¸­æ¡ä»¶æ—¶ï¼Œ$\\theta_P(x) = f(x)$ã€‚å› æ­¤è€ƒè™‘æå°åŒ–é—®é¢˜ï¼Œ $$\\begin{aligned}&amp;\\min_{x}{f(x)} = \\min_{x}{\\theta_p(x)} = \\min_{x} \\max_{\\lambda,\\eta,\\eta &gt;= 0}{L(x,\\eta,\\lambda)} \\&amp;\\text{Dual Problem} \\max_{\\lambda, \\eta; \\eta &gt;= 0} \\min_{x L(x,\\eta,\\lambda)}\\end{aligned}$$ è®¾ï¼š$p^{\\star} = \\min_{x}\\theta_p(x) \\d^{\\star} = \\max_{\\lambda, \\eta;\\eta &gt;= 0} \\min_{x} L(x,\\eta,\\lambda)$åˆ™æœ‰ï¼š $$\\min_{x}L(x,\\eta,\\lambda) &lt;= L(x,\\eta,\\lambda) &lt;= \\max_{\\lambda,\\eta,\\eta &gt;= 0}{L(x,\\eta,\\lambda)} \\\\rightarrow \\quad d^{\\star} &lt;= p^{\\star}$$ å½“ ä¼˜åŒ–é—®é¢˜çš„è§£æ»¡è¶³ KKTæ¡ä»¶æ—¶ï¼Œ $d^{\\star} = p^{\\star}$ 2.2 KKTæ¡ä»¶æŠŠä¸‹é¢çš„æ¡ä»¶è®°ä½œ KKT æ¡ä»¶ï¼š $$ \\begin{aligned} \\triangledown L(x,\\lambda,\\eta) = 0 \\\\ \\eta_i >= 0 \\\\ \\eta_ig(x_i) = 0 \\\\ g(x_i) >=0 \\\\ h(x_i) = 0 \\end{aligned} $$ è¯æ˜ï¼š $å½“g(x_i) &gt; 0 æ—¶ï¼Œæ­¤æ—¶æ¡ä»¶ g(x_i) ä¸èµ·ä½œç”¨ï¼Œä¸ºç­‰å¼çº¦æŸï¼Œæ­¤æ—¶ \\eta_i = 0$ $å½“ g(x_i) = 0æ—¶ï¼Œæ­¤æ—¶ \\eta_ig(x_i) = 0$ 2.3 æ¨¡å‹æ±‚è§£å› æ­¤ï¼ŒåŸé—®é¢˜å¯ä»¥è½¬åŒ–ä¸ºå¯¹å¶é—®é¢˜ $$ \\begin{aligned} L(w,b,\\lambda) = \\frac{w^Tw}{2} - \\sum_i^n \\lambda_i(y_i(w^Tx_i + b) - 1) \\quad(3)\\\\ \\min_{w,b}\\max_{\\lambda}L(w,b,\\lambda) \\rightarrow \\max_{\\lambda}\\min_{w,b}L(w,b,\\lambda) \\end{aligned} $$ æ±‚è§£ï¼š å¯¹ wï¼Œb æ±‚åå¯¼æ•°å¹¶ä»¤å…¶ç­‰äº0 $$ \\begin{aligned} \\frac{dL}{dw} = w - \\sum_i^n\\lambda_iy_ix_i = 0 \\quad(4)\\\\ \\frac{dL}{db} = -\\sum_i^n \\lambda_iy_i = 0 \\quad(5) \\end{aligned} $$ å°†ï¼ˆ4),(5ï¼‰å¸¦å…¥åˆ°(3)ä¸­ï¼Œå¯å¾—ï¼š $$ \\begin{aligned} G(\\lambda) &= \\frac{\\sum_i^n\\lambda_iy_ix_i^T\\sum_i^n\\lambda_iy_ix_i}{2} - \\sum_i^n \\lambda_i(y_i(\\sum_j^n\\lambda_jy_jx_j^Tx_i + b) - 1) \\\\ &= \\frac{\\sum_i^n\\lambda_iy_ix_i^T\\sum_i^n\\lambda_iy_ix_i}{2} - \\sum_i^n \\lambda_i(y_i(\\sum_j^n\\lambda_jy_jx_j^Tx_i)) +\\sum_i^n\\lambda_i \\\\ &= \\sum_i^n\\lambda_i - \\frac{\\sum_i^n\\sum_j^n\\lambda_jy_ix_jx_i^T\\lambda_iy_i}{2} \\\\ \\end{aligned}\\tag{6} $$ æ­¤æ—¶ä¼˜åŒ–é—®é¢˜ä¸º: $$\\begin{aligned} &\\max_{\\lambda} G(\\lambda) \\\\ s.t.\\quad & \\sum_i^n \\lambda_iy_i = 0 \\\\ &\\lambda_i >= 0 \\end{aligned} \\tag{7} $$ å¯¹Gå‡½æ•°æ±‚æå¤§å€¼ï¼Œå³å¯å¾—åˆ°è§£ $\\lambda^{\\star}$ï¼Œ å¸¦å…¥åˆ° (4),(5) å¯ä»¥æ±‚è§£å‡º $w^{\\star} = \\sum_i^n \\lambda^{\\star}_iy_ix_i$ã€‚ æ±‚è§£b, æ˜“çŸ¥å­˜åœ¨ $\\lambda_j \\neq 0$ï¼ˆå¯ä»¥ä½¿ç”¨åè¯æ³•è¯æ˜ï¼Œè‹¥å…¨éƒ¨$\\lambda$å‡ä¸º0ï¼Œåˆ™ wä¸º0ï¼Œè€Œw=0ä¸æ˜¯åŸå§‹ä¼˜åŒ–é—®é¢˜çš„è§£ï¼‰ã€‚æ­¤æ—¶ï¼Œæœ‰$y_i(w^{\\star} \\cdot x_i + b ) - 1 = 0$,å¯å¾— $b^{\\star} = y_i^2 - w^{\\star} \\cdot x_i$ ã€‚ 2.4 æ”¯æ’‘å‘é‡ç”±2.3 ç¬¬3ã€4æ­¥å¯çŸ¥ï¼Œå¦‚æœåªä¿ç•™ $\\lambda \\neq 0, \\quad y(w^Tx + b) - 1 = 0$ å¯¹åº”çš„x,yï¼Œæ±‚å¾—çš„ç»“æœwå’Œbä¸å˜ã€‚ å› æ­¤æŠŠè¿™äº›å‘é‡ç§°ä¹‹ä¸ºæ”¯æ’‘å‘é‡ï¼Œå³ support vectorã€‚ reference ç»Ÿè®¡å­¦ä¹ æ–¹æ³•. æèˆª. chapter 7 æœºå™¨å­¦ä¹ . å‘¨å¿—å","link":"/2020/09/27/SVM(1)_%20Hard-SVM/"},{"title":"Disjoint Set (Union-Find )","text":"å¹¶æŸ¥é›†æ•°æ®ç»“æ„ åªæœ‰ find å’Œ union æ“ä½œ, å®ƒç”¨äºå¤„ç†ä¸€äº›ä¸äº¤é›†çš„ åˆå¹¶ åŠ æŸ¥è¯¢ é—®é¢˜ã€‚ find : ç¡®å®šå…ƒç´ æ‰€åœ¨çš„é›†åˆ union: åˆå¹¶ä¸¤ä¸ªä¸ç›¸äº¤é›†åˆ å¹¶æŸ¥é›†çš„æ•°æ®ç»“æ„ åˆå§‹åŒ– åˆå§‹åŒ–æ—¶ï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½æ˜¯ä¸€ä¸ªé›†åˆã€‚ union(x,y) åˆå¹¶çš„è¿‡ç¨‹æ˜¯ï¼š å…ˆæ‰¾åˆ°xï¼ˆyï¼‰èŠ‚ç‚¹çš„ç¥–å…ˆèŠ‚ç‚¹(find(x)) [xpï¼Œyp] ï¼Œç„¶åæ¯”è¾ƒç¥–å…ˆèŠ‚ç‚¹æ˜¯å¦ç›¸åŒï¼Œè‹¥ç›¸åŒåˆ™å®Œæˆåˆå¹¶ã€‚è´Ÿè´£å°†å…¶ä¸­çš„ç¥–å…ˆèŠ‚ç‚¹ (xp) çš„çˆ¶èŠ‚ç‚¹æŒ‡å‘å¦ä¸€ä¸ªç¥–å…ˆèŠ‚ç‚¹ (yp)ï¼šparent[xp] = yp; ä¸€ä¸ªç®€å•çš„å¹¶æŸ¥é›†æ¨¡ç‰ˆ 12345678910111213141516171819202122232425262728int parent[MAXLEN];// åˆå§‹åŒ–é€šå¸¸å°†å…¶è‡ªèº«ä½œä¸ºçˆ¶èŠ‚ç‚¹void makeSet(int k){ for(int i =0;i&lt;k;i++) parent[i] = i;}// æŸ¥æ‰¾å…¶æ ¹èŠ‚ç‚¹int find(int x){ if(parent[x] != x){ parent[x] = find(parent[x]); } return parent[x];}// åˆå¹¶ä¸¤ä¸ªä¸ç›¸äº¤é›†åˆvoid union(int x,int y){ int xp = find(x); int yp = find(y); if(xp != yp){ parent[xp] = yp; } while(parent[x]!=yp){ int t = parent[x]; parent[x]=yp; x = t; }} è·¯å¾„å‹ç¼© è¿™æ ·çš„ç¡®å¯ä»¥è¾¾æˆç›®çš„ï¼Œä½†æ˜¯æ˜¾ç„¶æ•ˆç‡å®åœ¨å¤ªä½ã€‚ä¸ºä»€ä¹ˆå‘¢ï¼Ÿå› ä¸ºæˆ‘ä»¬ä½¿ç”¨äº†å¤ªå¤šæ²¡ç”¨çš„ä¿¡æ¯ï¼Œæˆ‘çš„ç¥–å…ˆæ˜¯è°ä¸æˆ‘çˆ¶äº²æ˜¯è°æ²¡ä»€ä¹ˆå…³ç³»ï¼Œè¿™æ ·ä¸€å±‚ä¸€å±‚æ‰¾å¤ªæµªè´¹æ—¶é—´ï¼Œä¸å¦‚æˆ‘ç›´æ¥å½“ç¥–å…ˆçš„å„¿å­ï¼Œé—®ä¸€æ¬¡å°±å¯ä»¥å‡ºç»“æœäº†ã€‚ç”šè‡³ç¥–å…ˆæ˜¯è°éƒ½æ— æ‰€è°“ï¼Œåªè¦è¿™ä¸ªäººå¯ä»¥ä»£è¡¨æˆ‘ä»¬å®¶æ—å°±èƒ½å¾—åˆ°æƒ³è¦çš„æ•ˆæœã€‚æŠŠåœ¨è·¯å¾„ä¸Šçš„æ¯ä¸ªèŠ‚ç‚¹éƒ½ç›´æ¥è¿æ¥åˆ°æ ¹ä¸Šï¼Œè¿™å°±æ˜¯è·¯å¾„å‹ç¼©ã€‚ å¹¶æŸ¥é›†çš„åº”ç”¨1. ç»Ÿè®¡ä¸ç›¸äº¤é›†åˆçš„ä¸ªæ•° 200. å²›å±¿æ•°é‡ ç»™ä½ ä¸€ä¸ªç”± â€˜1â€™ï¼ˆé™†åœ°ï¼‰å’Œ â€˜0â€™ï¼ˆæ°´ï¼‰ç»„æˆçš„çš„äºŒç»´ç½‘æ ¼ï¼Œè¯·ä½ è®¡ç®—ç½‘æ ¼ä¸­å²›å±¿çš„æ•°é‡ã€‚å²›å±¿æ€»æ˜¯è¢«æ°´åŒ…å›´ï¼Œå¹¶ä¸”æ¯åº§å²›å±¿åªèƒ½ç”±æ°´å¹³æ–¹å‘å’Œ/æˆ–ç«–ç›´æ–¹å‘ä¸Šç›¸é‚»çš„é™†åœ°è¿æ¥å½¢æˆã€‚æ­¤å¤–ï¼Œä½ å¯ä»¥å‡è®¾è¯¥ç½‘æ ¼çš„å››æ¡è¾¹å‡è¢«æ°´åŒ…å›´ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼šgrid = [ [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;] ] è¾“å‡ºï¼š1 ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼šgrid = [ [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;] ] è¾“å‡ºï¼š3 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;class Solution {public: struct Node{ int x; int y; Node():x(0),y(0){}; Node(int x, int y):x(x),y(y){}; bool equal(Node node){return node.x == x &amp;&amp; node.y == y;}; }; Node find(vector&lt;vector&lt;Node&gt;&gt; &amp;parent, Node node){ while(!node.equal(parent[node.x][node.y])){ node = parent[node.x][node.y]; } return node; } bool isParent(vector&lt;vector&lt;Node&gt;&gt; &amp;parent, Node node){ return node.equal(parent[node.x][node.y]); } void unionNode(vector&lt;vector&lt;Node&gt;&gt; &amp;parent, Node x, Node y){ Node xp = find(parent,x); Node yp = find(parent,y); if(!xp.equal(yp)) { parent[xp.x][xp.y] = yp; } while(!x.equal(yp)){ Node node = parent[x.x][x.y]; parent[x.x][x.y] = yp; x = node; } } int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) { int m = grid.size(), n = grid[0].size(); vector&lt;vector&lt;Node&gt;&gt; parent(m,vector&lt;Node&gt;(n,Node())); for(int i =0;i&lt;m;i++){ for(int j=0;j&lt;n;j++){ parent[i][j] = Node(i,j); } } vector&lt;int&gt; xd = {-1,0,1,0}; vector&lt;int&gt; yd = {0,1,0,-1}; for(int i =0;i&lt;m;i++){ for(int j=0;j&lt;n;j++){ if(grid[i][j] == '0') continue; for(int k =0;k&lt; 4;k++){ int x = xd[k] + i; int y = yd[k] + j; if(x &gt;=0 &amp;&amp; x &lt; m &amp;&amp; y &gt;=0 &amp;&amp; y &lt; n){ if(grid[x][y] == '1') unionNode(parent,Node(i,j),Node(x,y)); } } } } int ans = 0; for(int i =0;i&lt;m;i++){ for(int j = 0;j&lt;n;j++){ if(grid[i][j] == '1' &amp;&amp; isParent(parent,Node(i,j))) ans++; } } return ans; }}; Referencehttps://oi-wiki.org/ds/dsu/ https://leetcode-cn.com/problems/number-of-provinces/solution/jie-zhe-ge-wen-ti-ke-pu-yi-xia-bing-cha-0unne/","link":"/2022/01/12/Disjoint%20S%208c71a/"},{"title":"1021 Deepest Root (25åˆ†)","text":"A graph which is connected and acyclic can be considered a tree. The height of the tree depends on the selected root. Now you are supposed to find the root that results in a highest tree. Such a root is called the deepest root. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (&lt;=10000) which is the number of nodes, and hence the nodes are numbered from 1 to N. Then N-1 lines follow, each describes an edge by given the two adjacent nodesâ€™ numbers. Output Specification:For each test case, print each of the deepest roots in a line. If such a root is not unique, print them in increasing order of their numbers. In case that the given graph is not a tree, print â€œError: K componentsâ€ where K is the number of connected components in the graph. Sample Input 1:51 21 31 42 5 Sample Output 1:345 Sample Input 2:51 31 42 53 4 Sample Output 2:Error: 2 components Solutionæœ¬é¢˜å¾ˆå…³é”®çš„ä¸€ä¸ªç‚¹æ˜¯ï¼š æœ‰ n ä¸ªé¡¶ç‚¹ï¼Œä½†æ˜¯åªæœ‰ n-1 æ¡è¾¹ã€‚ç”±äºæ„æˆä¸€ä¸ªè¿é€šå›¾çš„æ— å‘å›¾è¦æ±‚ï¼Œnä¸ªé¡¶ç‚¹æœ€å°‘æœ‰nä¸ªè¾¹ï¼Œå› æ­¤æœ¬é¢˜å¯ä»¥çœ‹ä½œä¸ºæ±‚ ä¸€ä¸ªå›¾çš„è¿é€šåˆ†é‡æ•°ç›® ä»¥åŠ å›¾çš„éå†ã€‚ å¯¹äºå›¾çš„éå†ï¼Œå¯ä»¥é‡‡ç”¨ DFS æˆ–è€… BFSï¼Œæ±‚å›¾çš„è¿é€šåˆ†é‡ä¸ªæ•°ï¼Œå¯ä»¥é‡‡ç”¨å¹¶æŸ¥é›†æˆ–è€…æ•´åˆåˆ°å›¾çš„éå†è¿‡ç¨‹ä¸­ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;void dfs_1021(vector&lt;int&gt; *graph,int *visited,int node,int height,int &amp;maxheight,vector&lt;int&gt; &amp;res){ visited[node] = 1; if(height &gt; maxheight){ maxheight = height; res.clear(); res.push_back(node); } else if(height == maxheight) res.push_back(node); for(int i=0;i&lt;graph[node].size();i++){ if( !visited[graph[node][i]] ) dfs_1021(graph,visited,graph[node][i],height+1,maxheight,res); }}void pat_1021(){ int n,i; cin &gt;&gt; n; // é‡‡ç”¨é‚»æ¥è¡¨çš„æ¥å­˜å‚¨æ— å‘å›¾ vector&lt;int&gt; graph[n+1]; int x,y,visited[n+1]; // æ ‡è®°ä¸ºæœªè®¿é—®è¿‡ fill(visited,visited+n+1,0); for(i= 0;i&lt;n-1;i++){ cin &gt;&gt; x &gt;&gt; y; graph[x].push_back(y); graph[y].push_back(x); } vector&lt;int&gt; res; int maxheight = 0; int k =0; for(int j=1;j&lt;=n;j++){ if(visited[j]==0){ dfs_1021(graph,visited,j,1,maxheight,res); k++; } } if(k&gt;1) printf(&quot;Error: %d components\\n&quot;,k); else { int nodes[n+1],node = res[0]; fill(nodes,nodes+n+1,0); for(i =0;i&lt;res.size();i++) nodes[res[i]]++; if(n&gt;1){ res.clear(); fill(visited,visited+n+1,0); maxheight = 0; dfs_1021(graph,visited,node,1,maxheight,res); for(i =0;i&lt;res.size();i++) nodes[res[i]]++; } for(i=1;i&lt;=n;i++){ if(nodes[i] &gt; 0) cout &lt;&lt; i &lt;&lt; endl; } } }int main(){ pat_1021(); return 0;}","link":"/2020/03/08/2020-03-08-1021-Deepest-Root-(25%E5%88%86)/"},{"title":"1040 Longest Symmetric String (25åˆ†)","text":"Given a string, you are supposed to output the length of the longest symmetric sub-string. For example, given Is PAT&amp;TAP symmetric?, the longest symmetric sub-string is s PAT&amp;TAP s, hence you must output 11. Input Specification:Each input file contains one test case which gives a non-empty string of length no more than 1000. Output Specification:For each test case, simply print the maximum length in a line. SampleInput:Is PAT&amp;TAP symmetric? Output:11 Solutionå‡è®¾å›æ–‡ä¸²åœ¨ i,j ä¹‹é—´ï¼Œæ‰€æœ‰çš„ i,j ç»„åˆæœ‰ $C_2^n$ï¼Œå…¶ä¸­å¤§çº¦æœ‰ä¸€åŠçš„é‡å¤( i&gt;j ä¸ i &lt; j)ã€‚å› æ­¤ç¬¬ä¸€ç§å¯ä»¥è€ƒè™‘æš´åŠ›æ±‚è§£æ³•ï¼Œç©·ä¸¾æ‰€æœ‰çš„ç»„åˆï¼Œç„¶ååˆ¤æ–­æ˜¯éä¸ºå›æ–‡å­—ç¬¦ä¸²å³å¯ï¼Œæ­¤æ—¶çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(N^3)$ ã€‚ ç„¶åï¼Œè¿›ä¸€æ­¥åˆ†æä¼šå‘ç°ï¼Œå…¶å®å­˜åœ¨å¾ˆå¤šé‡å¤çš„å­é—®é¢˜ï¼Œå¦‚ å¯¹äºä¸‹æ ‡ä¸ºi,jçš„å­—ç¬¦ä¸²å®ƒä¾èµ–äºi+1,j-1ã€‚å› æ­¤ç¬¦åˆåŠ¨æ€è§„åˆ’çš„æ€æƒ³ï¼Œå³ä»åº•å‘ä¸Šå¹¶ä¸”å¯¹å­é—®é¢˜è¿›è¡Œè®°å½•ã€‚å®ƒçš„è§„åˆ’å¼ä¸º $$ LSS(i,j) = LSS(i+1,j-1) \\And (A[i] == A[j]); $$ è¿™é‡Œæœ‰ä¸€ä¸ªé—®é¢˜ç‚¹ï¼Œè®¡ç®— LSS(i,j) è¦ç”¨åˆ° LSS(i+1,j-1) ï¼Œå› æ­¤è®¡ç®—æ—¶ä¸èƒ½é‡‡ç”¨ i,j è¿™æ ·éå†ï¼Œè€Œæ˜¯ä»¥ j-i çš„é•¿åº¦ä¸ºä¾æ®è¿›è¡Œéå†ï¼Œå…ˆè®¡ç®—ä¸º1,2çš„æƒ…å†µï¼Œåœ¨è®¡ç®—å…¶å®ƒæƒ…å†µã€‚ Codeæš´åŠ›12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;bool isSymmetric(string str,int i,int j){ while(i&lt;j){ if(str[i++]!=str[j--]) return false; } return true;}// æš´åŠ›æ±‚è§£ o(n^3)void pat_1040(){ string str; getline(cin,str); int i=0,l=str.size()-1,j=l,res = 0; for(;i&lt;=l;i++){ for(j=i;j&lt;=l;j++){ if(isSymmetric(str,i,j)){ res = max(res,j-i+1); } } } cout &lt;&lt; res;}int main(){ pat_1040(); return 0;} åŠ¨æ€è§„åˆ’1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;void pat_1040(){ string str; getline(cin,str); int i=0,l=str.size()-1,j=l,res = 1; bool is[l+1][l+1]; fill(is[0],is[0]+(l+1)*(l+1),false); // æ ‡è®° é•¿åº¦ä¸º1 å’Œ 2 for(i=0;i&lt;=l;i++){ is[i][i] = true; if(i+1&lt;=l &amp;&amp; str[i+1] == str[i]){ is[i][i+1] = true; res = 2; } } j = 3 ; while(j&lt;=l+1){ for(i=0;i + j -1&lt;=l;i++){ int k = i+j-1; if(str[i] == str[k] &amp;&amp; is[i+1][k-1] ){ res = j; is[i][k] = true; } } j++; } cout &lt;&lt; res;}int main(){ pat_1040(); return 0;}","link":"/2020/03/10/2020-03-10-1040-Longest-Symmetric-String-(25%E5%88%86)/"},{"title":"LaTex Markdown Syntax","text":"see https://www.caam.rice.edu/~heinken/latex/symbols.pdf $2x - 5y = 8$$3x + 9y = -12$ $$f(x)=\\frac{P(x)}{Q(x)}$$","link":"/2020/03/10/2020-03-10-LaTex-Markdown-Syntax/"},{"title":"1090 Highest Price in Supply Chain (25åˆ†)","text":"A supply chain is a network of retailersï¼ˆé›¶å”®å•†ï¼‰, distributorsï¼ˆç»é”€å•†ï¼‰, and suppliersï¼ˆä¾›åº”å•†ï¼‰â€“ everyone involved in moving a product from supplier to customer. Starting from one root supplier, everyone on the chain buys products from oneâ€™s supplier in a price P and sell or distribute them in a price that is r% higher than P. It is assumed that each member in the supply chain has exactly one supplier except the root supplier, and there is no supply cycle. Now given a supply chain, you are supposed to tell the highest price we can expect from some retailers. Input Specification:Each input file contains one test case. For each case, The first line contains three positive numbers: ($N â‰¤ 10^5$), the total number of the members in the supply chain (and hence they are numbered from 0 to Nâˆ’1); P, the price given by the root supplier; and r, the percentage rate of price increment for each distributor or retailer. Then the next line contains N numbers, each number $S_i$ is the index of the supplier for the i-th member. $S_root$ for the root supplier is defined to be âˆ’1. All the numbers in a line are separated by a space. Output Specification:For each test case, print in one line the highest price we can expect from some retailers, accurate up to 2 decimal places, and the number of retailers that sell at the highest price. There must be one space between the two numbers. It is guaranteed that the price will not exceed $$10^10$$. SampleInput:129 1.80 1.001 5 4 4 -1 4 5 3 6 Output:11.85 2 Solutionä¾‹å­å¯ä»¥æŠ½è±¡ä¸ºå¦‚ä¸‹æ‰€ç¤ºçš„ä¸€é¢—æ ‘ 123456789 4 / | \\ 2 3 5 / / \\ 7 6 1 / / 8 0 &lt;- height = 4, number = 2 -&gt; ä¾›åº”é“¾æ˜¯ä¸€ä¸ªæœ‰å‘æ— ç¯å›¾ï¼Œå¯ä»¥æŠ½è±¡ä¸ºä¸€æ£µæ ‘ã€‚æœ¬é¢˜ä¸»è¦æ˜¯ä¸ºäº†æ±‚æ ‘çš„é«˜åº¦ä»¥åŠæœ€åä¸€å±‚æ ‘çš„èŠ‚ç‚¹æ•°ï¼Œé‡‡ç”¨å±‚åºéå†ï¼ˆBFSï¼‰å³å¯ã€‚æ³¨æ„ä¸€ç‚¹æ˜¯ï¼Œfloat çš„è¡¨ç¤ºèŒƒå›´æ— æ³•åˆ°è¾¾ $$10^10$$ï¼Œæ•…éœ€é‡‡ç”¨ double ç±»å‹ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;void pat_1090(){ // n the total number of the numbers in the supply chain int n; // p is the original price // r is the up rate in every convery double p,r; cin &gt;&gt; n &gt;&gt; p &gt;&gt; r; // æ‹“æ‰‘å›¾(æ— ç¯ï¼Œæœ‰å‘å›¾)ï¼Œé‡‡ç”¨æ ‘æ¥æ¨¡æ‹Ÿ vector&lt;int&gt; tree[n+1]; // æ„å»ºæ ‘ int i,parent,root; for(int i=0;i&lt;n;i++){ cin &gt;&gt; parent; if(parent == -1) root = i; else tree[parent].push_back(i); } int size ,height = 0,node; // é‡‡ç”¨æ ‘çš„å±‚åºéå†ã€‚å³ç±»ä¼¼äºå›¾çš„ BFS æ¥å¯»æ‰¾æœ€é•¿è·¯å¾„ queue&lt;int&gt; q; q.push(root); while(!q.empty()){ size = q.size(); height ++; for(i=0;i&lt; size;i++){ node = q.front(); q.pop(); // è¿™é‡Œç”±äºæ˜¯æœ‰å‘æ— ç¯å›¾ï¼Œæ¯ä¸ªèŠ‚ç‚¹åªè®¿é—®ä¸€æ¬¡ï¼Œæ•…æ— éœ€æ ‡è®° for(int j=0;j&lt;tree[node].size();j++){ q.push(tree[node][j]); } } } r = 1+0.01*r; double res = pow(r,height-1) * p; printf(&quot;%.2lf %d\\n&quot;,res,size); }int main(){ pat_1090(); return 0;}","link":"/2020/03/10/2020-03-10-1090-Highest-Price-in-Supply-Chain-(25%E5%88%86)/"},{"title":"1045 Favorite Color Stripe (30åˆ†)","text":"Eva is trying to make her own color stripe out of a given one. She would like to keep only her favorite colors in her favorite order by cutting off those unwanted pieces and sewing the remaining parts together to form her favorite color stripe. It is said that a normal human eye can distinguish about less than 200 different colors, so Evaâ€™s favorite colors are limited. However the original stripe could be very long, and Eva would like to have the remaining favorite stripe with the maximum length. So she needs your help to find her the best result. Note that the solution might not be unique, but you only have to tell her the maximum length. For example, given a stripe of colors {2 2 4 1 5 5 6 3 1 1 5 6}. If Evaâ€™s favorite colors are given in her favorite order as {2 3 1 5 6}, then she has 4 possible best solutions {2 2 1 1 1 5 6}, {2 2 1 5 5 5 6}, {2 2 1 5 5 6 6}, and {2 2 3 1 1 5 6}. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (â‰¤200) which is the total number of colors involved (and hence the colors are numbered from 1 to N). Then the next line starts with a positive integer M (â‰¤200) followed by M Evaâ€™s favorite color numbers given in her favorite order. Finally the third line starts with a positive integer L (â‰¤$10^4$ ) which is the length of the given stripe, followed by L colors on the stripe. All the numbers in a line a separated by a space. Output Specification:For each test case, simply print in a line the maximum length of Evaâ€™s favorite stripe. SampleInput:123456765 2 3 1 5 612 2 2 4 1 5 5 6 3 1 1 5 6``` ### Output: 7 1234567891011## Solutioné¢˜ç›®æ„æ€ä¸ºè¦æ±‚å‡ºèƒ½å¤Ÿç•™ä¸‹çš„å–œæ¬¢æ¡çº¹çš„æœ€å¤§é•¿åº¦ï¼Œçº¦æŸä¸»è¦æ˜¯å–œæ¬¢åºåˆ—çš„é¡ºåºï¼Œå³å¿…é¡»æŒ‰ç…§é¡ºåºè¿›è¡Œä¿ç•™ã€‚å¯¹äºç›®æ ‡åºåˆ— `2 3 1 5 6`ï¼Œå¦‚æœ`3` å·²ç»ä¿ç•™ï¼Œåé¢çš„æ¡çº¹å¦‚æœå‡ºç°çš„`2`åˆ™è¢«æŠ›å¼ƒæ‰ï¼ˆä¼˜å…ˆçº§ä¸€æ¬¡é€’å‡çš„æ„Ÿè§‰ï¼‰ã€‚è€Œä¸”ï¼Œç»“æœçš„åŒä¸€ç§æ¡çº¹å¯ä»¥è¿ç»­å‡ºç°ï¼Œæ¡çº¹ç§ç±»å¯ä»¥ä¸å®Œå…¨éƒ½æœ‰ã€‚å¯¹äºæ¯ä¸ªæœ€ä¼˜å­ç»“æ„éƒ½æœ‰ ï¼ˆF(n) ä¸ºå½“å‰é¢œè‰²ä¸º`n`çš„æœ€å¤§é•¿åº¦ï¼‰```latexF(2) = F(2) + 1 // max(F(2),F(0))+1 F(3) = max(F(2),F(3)) +1... ç”±æ­¤å¯ä»¥å¾—åˆ°é€’æ¨å…¬å¼: $$ F(n) = max(F(n),F(n-1)) +1 $$ è¿™é‡Œéœ€è¦ F(n-1)ï¼ŒF(n) ç±»ä¼¼äº F(3) ,F(2) ï¼Œå› æ­¤éœ€è¦ä¿ç•™ ç›®æ ‡æ¡çº¹ä¹‹é—´çš„ä½ç½®å…³ç³»ï¼Œè¿™ä¸ªå¯ä»¥ä½¿ç”¨ map å®ç°ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ ç©ºé—´æ¢æ—¶é—´çš„ æ•°ç»„å®ç° ï¼ˆå…¶å®ä¹Ÿæ˜¯ map çš„æ€æƒ³ï¼‰ Code123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;void pat_1045(){ int n,m,l,color; cin &gt;&gt; n; int i,wanted[n+1],indexes[n+1]; wanted[0] = 0; fill(indexes,indexes+n+1,0); cin &gt;&gt; m; for(i=1;i&lt;= m;i++){ cin &gt;&gt; color; indexes[color] = i; wanted[i] = color; } cin &gt;&gt; l; int nums[l+1]; for(i=1;i&lt;=l;i++ ) cin &gt;&gt; nums[i]; int res[n+1]; fill(res,res+n+1,0); int max_re = 0; for(i=1;i&lt;=l;i++){ if(indexes[nums[i]]&gt;0) { res[nums[i]] = max(res[nums[i]],res[wanted[indexes[nums[i]]-1]]) + 1; max_re = max(max_re,res[nums[i]]); } } cout &lt;&lt; max_re;}int main(){ pat_1045(); return 0;}","link":"/2020/03/11/2020-03-11-1045-Favorite-Color-Stripe-(30%E5%88%86)/"},{"title":"1099 Build A Binary Search Tree (30åˆ†)","text":"A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the nodeâ€™s key.The right subtree of a node contains only nodes with keys greater than or equal to the nodeâ€™s key.Both the left and right subtrees must also be binary search trees.Given the structure of a binary tree and a sequence of distinct integer keys, there is only one way to fill these keys into the tree so that the resulting tree satisfies the definition of a BST. You are supposed to output the level order traversal sequence of that tree. The sample is illustrated by Figure 1 and 2. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (&lt;=100) which is the total number of nodes in the tree. The next N lines each contains the left and the right children of a node in the format â€œleft_index right_indexâ€, provided that the nodes are numbered from 0 to N-1, and 0 is always the root. If one child is missing, then -1 will represent the NULL child pointer. Finally N distinct integer keys are given in the last line. Output Specification:For each test case, print in one line the level order traversal sequence of that tree. All the numbers must be separated by a space, with no extra space at the end of the line. SampleInput:123456789101191 62 3-1 -1-1 45 -1-1 -17 -1-1 8-1 -173 45 11 58 82 25 67 38 42 Output:58 25 82 11 38 67 45 73 42 SolutionBSTæ ‘ï¼Œæœ‰ä¸€ä¸ªç‰¹ç‚¹ï¼šå®ƒçš„ä¸­åºåºåˆ—æ˜¯ä¸€ä¸ªæœ‰åºåºåˆ—ï¼Œè¿™é“é¢˜çš„å…³é”®å°±æ˜¯æŠ“ä½è¿™ä¸ªç‰¹ç‚¹ã€‚æ­¥éª¤ä¹Ÿå¾ˆæ¸…æ™° æ„å»ºæ ‘ (çœ‹æ¸…é¢˜å¹²ï¼Œå¯ä»¥é€‰æ‹©ä¸€ä¸ªç»“æ„ä½“æ•°ç»„æ¥å­˜å‚¨æ ‘çš„å„ä¸ªèŠ‚ç‚¹) æ•°æ®æ’åºï¼Œä»å°åˆ°å¤§æ’åº æ„å»ºæ ‘çš„ä¸­åºåºåˆ—ï¼ˆå¯ä»¥é€‰æ‹©é€’å½’æˆ–è€…é‡‡ç”¨éé€’å½’éå†ï¼‰ï¼Œè¿™ä¸€æ­¥ä¸»è¦æ˜¯æ‰¾åˆ°æ ‘çš„èŠ‚ç‚¹ä¸æ•°æ®çš„å¯¹åº”å…³ç³» æ ‘çš„å±‚åºéå†ï¼Œéå†çš„åŒæ—¶æ‰“å°èŠ‚ç‚¹å€¼å³å¯ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;struct TreeNode{ int parent, left, right;};TreeNode nodes[100];vector&lt;int&gt; orders;void inorders(int parent){ if (parent != -1) { TreeNode node = nodes[parent]; inorders(node.left); orders.push_back(node.parent); inorders(node.right); }}void pat_1099(){ int n, parent = 0, i, j; cin &gt;&gt; n; // æ„å»ºæ ‘ for(i=0;i&lt;n;i++){ cin &gt;&gt; nodes[i].left &gt;&gt; nodes[i].right; nodes[i].parent = i; } // ä¸­åºåºåˆ— inorders(parent); int nums[n], maps[n]; // å»ºç«‹èµ· ä¸­åºåºåˆ—ä¸å…¶ç´¢å¼•ä¹‹é—´çš„å…³ç³» for (i = 0; i &lt; orders.size(); i++) maps[orders[i]] = i; for (i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;nums[i]); // ä¸­åºåºåˆ—ä¸ºæœ‰åºåºåˆ— sort(nums, nums + n); queue&lt;TreeNode&gt; q; q.push(nodes[0]); int size = 1; // å±‚åºéå†ï¼Œæ‰“å°ç»“æœ while (!q.empty()) { size = q.size(); for (j = 0; j &lt; size; j++) { TreeNode node = q.front(); q.pop(); if (node.parent != 0) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; nums[maps[node.parent]]; if (node.left != -1) q.push(nodes[node.left]); if (node.right != -1) q.push(nodes[node.right]); } }}int main(){ pat_1099(); return 0;}","link":"/2020/03/12/2020-03-12-1099-Build-A-Binary-Search-Tree-(30%E5%88%86)/"},{"title":"1115 Counting Nodes in a BST (30åˆ†)","text":"A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than or equal to the nodeâ€™s key. The right subtree of a node contains only nodes with keys greater than the nodeâ€™s key. Both the left and right subtrees must also be binary search trees. Insert a sequence of numbers into an initially empty binary search tree. Then you are supposed to count the total number of nodes in the lowest 2 levels of the resulting tree. Input Specification:Each input file contains one test case. For each case, the first line gives a positive integer N (â‰¤1000) which is the size of the input sequence. Then given in the next line are the N integers in [âˆ’1000,1000] which are supposed to be inserted into an initially empty binary search tree. Output Specification:For each case, print in one line the numbers of nodes in the lowest 2 levels of the resulting tree in the format: 1n1 + n2 = n where n1 is the number of nodes in the lowest level, n2 is that of the level above, and n is the sum. SampleInput:12925 30 42 16 20 20 35 -5 28 Output:12 + 4 = 6 Solutionå…ˆå»ºç«‹BST, å»ºæ ‘çš„åŒæ—¶å¯ä»¥è®°å½•èŠ‚ç‚¹çš„å±‚æ•°å³æœ€å¤§å±‚æ•°ï¼Œæœ€åéå†ä¸€éå³å¯ æ³¨æ„ï¼šçœ‹æ¸…é¢˜å¹²ï¼Œæœ¬é¢˜ The left subtree of a node contains only nodes with keys less than or equal to the node's key. ï¼Œ æ‰¾äº†åŠä¸ªå°æ—¶ï¼Œæ‰å‘ç° ä»£ç å°±å¾ˆç®€å•äº† Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;using namespace std;struct BinaryNode{ int left, right, data, level;};void pat_1115(){ int n,val,i; cin &gt;&gt; n; BinaryNode nodes[n]; for (i = 0; i &lt; n; i++) { cin &gt;&gt; val; nodes[i] = {-1,-1,val,0}; } int root = 0, cur, maxLevel = 0; for (i = 1; i &lt; n; i++) { root = 0; while (root != -1) { if (nodes[root].data &gt;= nodes[i].data) { cur = nodes[root].left; if (cur == -1) { nodes[root].left = i; nodes[i].level = nodes[root].level + 1; } } else { cur = nodes[root].right; if (cur == -1) { nodes[root].right = i; nodes[i].level = nodes[root].level + 1; } } maxLevel = max(maxLevel, nodes[i].level); root = cur; } } int prelevel = 0, curlevel = 0; for (i = 0; i &lt; n; i++) { if (nodes[i].level == maxLevel) curlevel++; else if (nodes[i].level == maxLevel - 1) prelevel++; } printf(&quot;%d + %d = %d\\n&quot;, curlevel, prelevel, curlevel + prelevel);}int main(){ pat_1115(); return 0;}","link":"/2020/03/12/2020-03-12-1115-Counting-Nodes-in-a-BST-(30%E5%88%86)/"},{"title":"1123 Is It a Complete AVL Tree (30åˆ†)","text":"An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules. Now given a sequence of insertions, you are supposed to output the level-order traversal sequence of the resulting AVL tree, and to tell if it is a complete binary tree. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer N (â‰¤ 20). Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space. Output Specification:For each test case, insert the keys one by one into an initially empty AVL tree. Then first print in a line the level-order traversal sequence of the resulting AVL tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Then in the next line, print YES if the tree is complete, or NO if not. SampleInput 1:12588 70 61 63 65 Output 1:1270 63 88 61 65YES ##Sample Input 2:12888 70 61 96 120 90 65 68 Output 2:1288 65 96 61 70 90 120 68NO Solutionä¸»è¦åˆ†ä¸¤æ­¥: å»ºç«‹avlæ ‘ (è¿‡ç¨‹å‚è§ AvlTree) è¿›è¡Œå±‚åºéå†ï¼Œéå†è¿‡ç¨‹ä¸­åˆ¤æ–­æ˜¯å¦ä¸ºå®Œå…¨äºŒå‰æ ‘ å®Œå…¨äºŒå‰æ ‘çš„å®šä¹‰ä¸º æœ€å¤šæœ‰ä¸€ä¸ªåªæœ‰ä¸€ä¸ªå¶å­çš„èŠ‚ç‚¹Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;iostream&gt;#include&lt;cmath&gt;#include &lt;queue&gt;using namespace std; struct avl_node{ struct avl_node *left, *right; int data, height;};typedef struct avl_node *AvlTree, *AvlNode;int height(AvlNode k){ return k ? k-&gt;height : -1;}// lr æ—‹è½¬AvlNode left_right_rotate(AvlNode k2){ AvlNode k1 = k2-&gt;left; k2-&gt;left = k1-&gt;right; k1-&gt;right = k2; k2-&gt;height = max(height(k2-&gt;left), height(k2-&gt;right)) + 1; k1-&gt;height = max(height(k1-&gt;left), height(k1-&gt;right)) + 1; return k1;}// rl æ—‹è½¬AvlNode right_left_rotate(AvlNode k1){ AvlNode k2 = k1-&gt;right; k1-&gt;right = k2-&gt;left; k2-&gt;left = k1; k1-&gt;height = max(height(k1-&gt;left), height(k1-&gt;right)) + 1; k2-&gt;height = max(height(k2-&gt;left), height(k2-&gt;right)) + 1; return k2;}// ll æ—‹è½¬AvlNode left_left_rotate(AvlNode k3){ k3-&gt;left = right_left_rotate(k3-&gt;left); return left_right_rotate(k3);}// rr æ—‹è½¬AvlNode right_right_rotate(AvlNode k1){ k1-&gt;right = left_right_rotate(k1-&gt;right); return right_left_rotate(k1);}AvlNode insert(AvlNode t, int val){ if (!t) { t = new avl_node(); t-&gt;data = val; t-&gt;height = 0; t-&gt;left = t-&gt;right = nullptr; return t; } // self-check if (t-&gt;data &gt; val) { t-&gt;left = insert(t-&gt;left, val); if (height(t-&gt;left) - height(t-&gt;right) == 2) { // lr æ—‹è½¬ if (t-&gt;left-&gt;data &gt; val) t = left_right_rotate(t); else t = left_left_rotate(t); } } else { t-&gt;right = insert(t-&gt;right, val); if (height(t-&gt;right) - height(t-&gt;left) == 2) { // rl æ—‹è½¬ if (t-&gt;right-&gt;data &lt; val) t = right_left_rotate(t); else t = right_right_rotate(t); } } t-&gt;height = max(height(t-&gt;left), height(t-&gt;right)) + 1; return t;}bool level_loop(AvlNode tree){ queue&lt;AvlNode&gt; q; q.push(tree); int flag = 1; bool complete = true, leaf = false, falg = true; while (!q.empty()) { AvlNode node = q.front(); q.pop(); if (!flag) cout &lt;&lt; &quot; &quot;; else flag = false; cout &lt;&lt; node-&gt;data; if (node-&gt;left) q.push(node-&gt;left); if (node-&gt;right) q.push(node-&gt;right); if (!node-&gt;left &amp;&amp; node-&gt;right) complete = false; if (leaf &amp;&amp; (node-&gt;left || node-&gt;right)) complete = false; if (!node-&gt;left || !node-&gt;right) leaf = true; } cout &lt;&lt; endl; return complete;}void pat_1123(){ int n, i, val; cin &gt;&gt; n; AvlTree root = nullptr; for (i = 0; i &lt; n; i++) { cin &gt;&gt; val; root = insert(root, val); } bool complete = level_loop(root); if (complete) cout &lt;&lt; &quot;YES&quot;; else cout &lt;&lt; &quot;NO&quot;;}int main(){ pat_1123(); return 0;}","link":"/2020/03/12/2020-03-12-1123-Is-It-a-Complete-AVL-Tree-(30%E5%88%86)/"},{"title":"Avl Tree","text":"å¯¹äºäºŒå‰æœç´¢æ ‘ï¼Œå¦‚æœé¢„å…ˆè¾“å…¥ä¸€å †æ’å¥½åºçš„åºåˆ—ï¼Œå…¶ä¼šé€€åŒ–æˆå•é“¾è¡¨ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œè§„å®šä¸€ä¸ªå¹³è¡¡çš„é™„åŠ æ¡ä»¶:ä»»ä½•èŠ‚ç‚¹çš„æ·±åº¦éƒ½ä¸çš„è¿‡æ·±ã€‚ä½†æ˜¯æ ‡å‡†çš„äºŒå‰å¹³è¡¡æ ‘å®ç°èµ·æ¥å¤æ‚æ€§è¿‡é«˜ï¼Œå› æ­¤ä»‹ç»ä¸€ç§è¾ƒä¸ºç»å…¸çš„å¹³è¡¡æœ¯â€”avl(adelson-velskii and landis) æ ‘ å®ƒçš„ç‰¹ç‚¹æ˜¯: æ¯ä¸ªèŠ‚ç‚¹çš„å·¦å­æ ‘å’Œå³å­æ ‘ç›¸å·®é«˜åº¦ä¸è¶…è¿‡1çš„äºŒå‰æœç´¢æ ‘ Insertå¯¹äº avl æ ‘æœ€ä¸»è¦çš„é—®é¢˜åº”è¯¥åœ¨äºæ’å…¥åï¼Œå¦‚ä½•ä¿è¯å…¶å¹³è¡¡çš„è¦æ±‚å³: æ¯ä¸ªèŠ‚ç‚¹çš„å·¦å­æ ‘å’Œå³å­æ ‘ç›¸å·®é«˜åº¦ä¸è¶…è¿‡1 å¯¹äºä¸€èŠ‚å¾…å¹³è¡¡èŠ‚ç‚¹ï¼Œç ´åå…¶å¹³è¡¡ç”±å››ç§å¯èƒ½ å¯¹å…¶å·¦å„¿å­çš„å·¦å­æ ‘ä¸€æ¬¡æ’å…¥ å¯¹å…¶å·¦å„¿å­çš„å³å­æ ‘ä¸€æ¬¡æ’å…¥ å¯¹å…¶å³å„¿å­çš„å³å­æ ‘ä¸€æ¬¡æ’å…¥ å¯¹å…¶å³å„¿å­çš„å·¦å­æ ‘ä¸€æ¬¡æ’å…¥ å¯¹äºæ¯ä¸€ç§æƒ…å†µè¿›è¡Œåˆ†æ left - left ç»“æ„(å³ç¬¬ä¸€ç§) æ­¤æ—¶ k2 èŠ‚ç‚¹æ˜¯ä¸å¹³è¡¡çš„ï¼Œ æ­¤æ—¶ä»¥k1ä¸ºèŠ‚ç‚¹ï¼Œé¡ºæ—¶é’ˆæ—‹è½¬,k2ï¼Œç„¶åå°†k1çš„å³å­©å­ç½®ä¸ºk2ï¼Œk2çš„å·¦å­©å­ç½®ä¸ºy 12345678910111213Position single_rotate_with_left(Position k2){ Position k1; k1 = k2-&gt;left; k2-&gt;left = k1-&gt;right; k1-&gt;right = k2; k2-&gt;height = max(height(k2-&gt;left), height(k2-&gt;right)) + 1; k1-&gt;height = max(height(k1-&gt;left), height(k1-&gt;right)) + 1; return k1;} right - right ç»“æ„(ç¬¬ä¸‰ç§) æ­¤æ—¶ä¸ç¬¬ä¸€ç§å¯¹ç§° 123456789101112Position single_retate_with_right(Position k1){ Position k2; k2 = k1-&gt;right; k1-&gt;right = k2-&gt;left; k2-&gt;left = k1; k2-&gt;height = max(height(k2-&gt;left), height(k2-&gt;right)) + 1; k1-&gt;height = max(height(k1-&gt;left), height(k1-&gt;right)) + 1; return k2;} left-right ç»“æ„[ç¬¬äºŒç§ç»“æ„] æ­¤æ—¶å¯ä»¥è§‚å¯Ÿï¼Œk1,k2,k3å¸ƒå±€ï¼Œä½¿ç”¨ä¸¤æ¬¡æ—‹è½¬ã€‚ç¬¬ä¸€æ¬¡å¯¹äºk1,k2è¿›è¡Œä¸€æ¬¡å³å•æ—‹(ç¬¬ä¸‰ç§ç»“æ„)ã€‚å†å¯¹è°ƒæ•´åçš„å¸ƒå±€(k2,k3)å†è¿›è¡Œä¸€æ¬¡å·¦å•æ—‹ã€‚ 1234567Position rotate_with_right_left(Position k3){ k3-&gt;left = single_rotate_with_right(k3-&gt;left); return single_rotate_with_left(k3);} right-left ç»“æ„[ç¬¬å››ç§ç»“æ„] æ­¤æ—¶å¯ä»¥è§‚å¯Ÿï¼Œk1,k2,k3å¸ƒå±€ï¼Œä½¿ç”¨ä¸¤æ¬¡æ—‹è½¬ã€‚ç¬¬ä¸€æ¬¡å¯¹äºk2,k3è¿›è¡Œä¸€æ¬¡å·¦å•æ—‹(ç¬¬ä¸€ç§ç»“æ„)ã€‚å†å¯¹è°ƒæ•´åçš„å¸ƒå±€(k1,k2)å†è¿›è¡Œä¸€æ¬¡å³å•æ—‹ã€‚ 123456Position rotate_with_left_right(Position k1){ k1-&gt;right = single_rotate_with_left(k1-&gt;right); return single_rotate_with_right(k1);} æ’å…¥æ¥ä¸‹æ¥çš„æ’å…¥å°±æ¯”è¾ƒæ¸…æ™°äº†ï¼Œæ’å…¥æµç¨‹ä¸äºŒå‰æœç´¢æ ‘ä¸€æ ·ï¼Œä½†æ˜¯æ¯æ¬¡æ’å…¥ä¹‹åï¼Œè¦å¯¹å…¶å¹³è¡¡æ€§è¿›è¡Œåˆ¤æ–­ï¼Œæ ¹æ®ä¸åŒçš„æƒ…å½¢ï¼Œè¿›è¡Œä¸åŒçš„è°ƒæ•´: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748AvlTree insert(Element e, AvlTree t, compare_func cmp){ if (t == NULL) { t = (AvlTree)malloc(sizeof(struct AvlNode)); t-&gt;height = 0; t-&gt;e = e; return t; } int cp = cmp(e, t-&gt;e); if (cp == 0) return t; else if (cp &gt; 0) { t-&gt;right = insert(e, t-&gt;right, cmp); if (height(t-&gt;right) - height(t-&gt;left) == 2) { if (cmp(e, t-&gt;right-&gt;e) &gt; 0) { t = single_rotate_with_right(t); } else { t = rotate_with_right_left(t); } } } else { t-&gt;left = insert(e, t-&gt;left, cmp); if (height(t-&gt;left) - height(t-&gt;right) == 2) { if (cmp(e, t-&gt;left-&gt;e) &lt; 0) { t = single_rotate_with_left(t); } else { t = rotate_with_left_right(t); } } } t-&gt;height = max(height(t-&gt;left), height(t-&gt;right)) + 1; return t;} findæŸ¥æ‰¾è¿‡ç¨‹ä¸äºŒå‰æœç´¢æ ‘ä¸€æ · deleteåˆ é™¤é‡‡ç”¨å“‘èŠ‚ç‚¹çš„æ¨¡å¼ï¼Œå› ä¸ºåˆ é™¤åçš„è°ƒæ•´æ›´ä¸ºç¹æ‚ã€‚ 1234567891011AvlTree remove(Element e, AvlTree t, compare_func cmp){ Position p = find(e, t, cmp); if (p == NULL) { return NULL; } p-&gt;rate = 0; return p;} // TODOæ›´å¤šåˆ é™¤æ–¹æ³•ï¼Œè¯·è§â€¦ Implementavl_tree","link":"/2020/03/12/2020-03-12-Avl-Tree/"},{"title":"1135 Is It A Red-Black Tree (30åˆ†)","text":"There is a kind of balanced binary search tree named red-black tree in the data structure. It has the following 5 properties: (1) Every node is either red or black.(2) The root is black.(3) Every leaf (NULL) is black.(4) If a node is red, then both its children are black.(5) For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.For example, the tree in Figure 1 is a red-black tree, while the ones in Figure 2 and 3 are not.For each given binary search tree, you are supposed to tell if it is a legal red-black tree. Input Specification:Each input file contains several test cases. The first line gives a positive integer K (â‰¤30) which is the total number of cases. For each case, the first line gives a positive integer N (â‰¤30), the total number of nodes in the binary tree. The second line gives the preorder traversal sequence of the tree. While all the keys in a tree are positive integers, we use negative signs to represent red nodes. All the numbers in a line are separated by a space. The sample input cases correspond to the trees shown in Figure 1, 2 and 3. Output Specification:For each test case, print in a line â€œYesâ€ if the given tree is a red-black tree, or â€œNoâ€ if not. SampleInput:12345678397 -2 1 5 -4 -11 8 14 -15911 -2 1 -7 5 -4 8 14 -15810 -7 5 -6 8 15 -11 17 Output:123YesNoNo Solutionå…³äºçº¢é»‘æ ‘çš„å®šä¹‰å‚ç…§ (rb_tree) äº†è§£äº†çº¢é»‘æ ‘çš„å®šä¹‰åï¼Œæ­¥éª¤å°±å¾ˆæ¸…æ™°äº† å»ºæ ‘ï¼ˆé‡‡ç”¨é“¾è¡¨æˆ–è€…æ•°ç»„å‡å¯ä»¥ï¼‰ åˆ¤æ–­æ˜¯å¦ä¸ºçº¢é»‘æ ‘ï¼Œä¸»è¦æŠ“ä½ä¸€ä¸‹å‡ ç‚¹ æ ¹èŠ‚ç‚¹ä¸ºé»‘è‰² æ¯ä¸ªèŠ‚ç‚¹éé»‘å³çº¢ çº¢è‰²èŠ‚ç‚¹æ˜¯å¶å­ç»“ç‚¹æˆ–è€…å®ƒçš„å­©å­èŠ‚ç‚¹ï¼ˆå·¦å³ï¼‰ å‡ä¸ºé»‘è‰²èŠ‚ç‚¹ æ¯ä¸ªèŠ‚ç‚¹çš„å·¦å³èŠ‚ç‚¹çš„é»‘é«˜å‡ç›¸ç­‰ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495struct RBNode{ struct RBNode *left, *right; int key;};int getheight(RBNode *root){ if (!root) return 0; int l = getheight(root-&gt;left); int r = getheight(root-&gt;right); return root-&gt;key &gt; 0 ? max(l, r) + 1 : max(l, r);}RBNode *insertRBTree(RBNode *root, int val){ if (!root) { root = new RBNode(); root-&gt;left = root-&gt;right = nullptr; root-&gt;key = val; } else { if (abs(val) &lt;= abs(root-&gt;key)) { root-&gt;left = insertRBTree(root-&gt;left, val); } else root-&gt;right = insertRBTree(root-&gt;right, val); } return root;}// åˆ¤æ–­æ˜¯éä¸º rb treebool isRBTree(RBNode *root){ // é‡‡ç”¨ å±‚åºéå† æ¥åˆ¤æ–­æ˜¯å¦ç¬¦åˆè¦æ±‚ queue&lt;RBNode *&gt; q; q.push(root); bool is = true; while (!q.empty() &amp;&amp; is) { RBNode *node = q.front(); q.pop(); if (node-&gt;left) { q.push(node-&gt;left); } if (node-&gt;right) { q.push(node-&gt;right); } int left = getheight(node-&gt;left), right = getheight(node-&gt;right); if (left != right) is = false; if (node-&gt;key &lt; 0) { if (!((!node-&gt;left &amp;&amp; !node-&gt;right) || (node-&gt;left &amp;&amp; node-&gt;left-&gt;key &gt; 0 &amp;&amp; node-&gt;right &amp;&amp; node-&gt;right-&gt;key &gt; 0))) is = false; } else if (node-&gt;key == 0) is = false; } return is;}void pat_1135(){ int k, i, j, n, val; cin &gt;&gt; k; for (i = 0; i &lt; k; i++) { cin &gt;&gt; n; RBNode *root = nullptr; for (j = 0; j &lt; n; j++) { cin &gt;&gt; val; root = insertRBTree(root, val); } if (root-&gt;key &lt; 0 || !isRBTree(root)) cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; }}int main(){ pat_1135(); return 0;}","link":"/2020/03/13/2020-03-13-1135-Is-It-A-Red-Black-Tree-(30%E5%88%86)/"},{"title":"1154 Vertex Coloring (25åˆ†)","text":"A proper vertex coloring is a labeling of the graphâ€™s vertices with colors such that no two vertices sharing the same edge have the same color. A coloring using at most k colors is called a (proper) k-coloring. Now you are supposed to tell if a given coloring is a proper k-coloring. Input Specification:Each input file contains one test case. For each case, the first line gives two positive integers N and M (both no more than $10^4$), being the total numbers of vertices and edges, respectively. Then M lines follow, each describes an edge by giving the indices (from 0 to Nâˆ’1) of the two ends of the edge. After the graph, a positive integer K (â‰¤ 100) is given, which is the number of colorings you are supposed to check. Then K lines follow, each contains N colors which are represented by non-negative integers in the range of int. The i-th color is the color of the i-th vertex. Output Specification:For each coloring, print in a line k-coloring if it is a proper k-coloring for some positive k, or No if not. SampleInput:123456789101112131415161710 118 76 84 58 48 11 21 49 89 11 02 440 1 0 1 4 1 0 1 3 00 1 0 1 4 1 0 1 0 08 1 0 1 4 1 0 5 3 01 2 3 4 5 6 7 8 8 9 Output:12344-coloringNo6-coloringNo Solutionå®é™…ä¸Šè€ƒå¯Ÿçš„æ˜¯å›¾çš„éå†ï¼Œè¿™é‡Œé‡‡ç”¨çš„æ˜¯æ— å‘å›¾çš„é‚»æ¥è¡¨çš„å­˜æ³•ï¼ŒBFS (ç±»ä¼¼äº) Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;vector&gt;using namespace std; void pat_1154(){ int n, m; cin &gt;&gt; n &gt;&gt; m; int i, v1, v2, visited[n]; vector&lt;int&gt; vertices[n]; for (i = 0; i &lt; m; i++) { cin &gt;&gt; v1 &gt;&gt; v2; vertices[v1].push_back(v2); vertices[v2].push_back(v1); } int k; cin &gt;&gt; k; for (int j = 0; j &lt; k; j++) { int color = 0, colors[n], num = 0; map&lt;int, int&gt; maps; fill(visited, visited + n, 0); for (i = 0; i &lt; n; i++) { cin &gt;&gt; color; if (maps.count(color) == 0) { num++; maps[color] = 1; } colors[i] = color; } bool ok = true; for (i = 0; i &lt; n; i++) { if (!visited[i]) { for (int k = 0; k &lt; vertices[i].size(); k++) { if (!visited[vertices[i][k]]) { if (colors[i] == colors[vertices[i][k]]) { ok = false; break; } } } visited[i] = 1; } } if (ok) printf(&quot;%d-coloring\\n&quot;, num); else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; }}int main(){ pat_1154(); return 0;}","link":"/2020/03/13/2020-03-13-1154-Vertex-Coloring-(25%E5%88%86)/"},{"title":"RB Tree","text":"ä¸Šé¢ä»‹ç»äº†äºŒå‰æœç´¢æ ‘ä»¥åŠavlæ ‘ï¼Œè¿™é‡Œä»‹ç»å¦å¤–ä¸€ç§è¿‘ä¼¼å¹³è¡¡çš„äºŒå‰æ ‘â€“ çº¢é»‘æ ‘å®ƒçš„æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰5ä¸ªå±æ€§: colorã€keyã€leftã€rightã€p ä¸€æ£µçº¢é»‘æ ‘é€šå¸¸æ‹¥æœ‰ä»¥ä¸‹æ€§è´¨ æ¯ä¸ªèŠ‚ç‚¹æˆ–æ˜¯çº¢è‰²ï¼Œæˆ–æ˜¯é»‘è‰²çš„ (rb) æ ¹èŠ‚ç‚¹æ˜¯é»‘è‰²çš„ æ¯ä¸ªå¶å­èŠ‚ç‚¹ä¹Ÿæ˜¯é»‘è‰²çš„ å¦‚æœä¸€ä¸ªèŠ‚ç‚¹æ˜¯çº¢è‰²çš„ï¼Œåˆ™å®ƒçš„ä¸¤ä¸ªå­èŠ‚ç‚¹éƒ½æ˜¯é»‘è‰²çš„ å¯¹äºæ¯ä¸ªèŠ‚ç‚¹ï¼Œä»è¯¥èŠ‚ç‚¹åˆ°æ‰€æœ‰åä»£å¶èŠ‚ç‚¹çš„ç®€å•è·¯å¾„ä¸Šï¼Œå‡åŒ…å«ç›¸åŒæ•°ç›®çš„é»‘è‰²èŠ‚ç‚¹ ä¸Šå›¾ 1 æ˜¯çº¢é»‘æ ‘ï¼Œå…¶ä½™å‡ä¸æ˜¯ å®ƒçš„æ’å…¥åˆ é™¤ä»¥åŠè®¿é—®çš„æ—¶é—´å¤æ‚åº¦ä¸º O(lgN)å®šä¹‰ï¼Œbh(x) (black height) ä¸ºé»‘é«˜ï¼Œå³èŠ‚ç‚¹xåˆ°æœŸå¶å­èŠ‚ç‚¹çš„é»‘è‰²èŠ‚ç‚¹çš„ä¸ªæ•° è¯æ˜: ä¸€ä¸ªnä¸ªå†…éƒ¨èŠ‚ç‚¹çš„çº¢é»‘æ ‘ï¼Œå®ƒçš„é«˜åº¦æœ€å¤šä¸º $2*log_2(n+1)$ é¦–å…ˆè¯æ˜: ä»¥ä»»ä¸€èŠ‚ç‚¹çš„xä¸ºæ ¹çš„çº¢é»‘æ ‘æœ€å°‘å«æœ‰ $2^{bh(x)}-1$ ä¸ªèŠ‚ç‚¹ å½’çº³æ³•è¯æ˜: ç”±æ€§è´¨5ï¼Œå¯ä»¥çœ‹å‡º: è‹¥xçš„é«˜åº¦ä¸º0ï¼Œå³å…¶ä¸ºå¶å­èŠ‚ç‚¹(nil)ï¼Œæ­¤æ—¶æœ‰ $n &gt;= 2^0 - 1 = 0$ è‹¥xçš„é«˜åº¦ä¸º1ï¼Œåˆ™è‡³å°‘æœ‰ $n = 2^0-1 + 2^0 -1 + 1 = 1$ å¯¹äºä¸€ä¸ªä»»æ„èŠ‚ç‚¹xï¼Œå®ƒçš„å·¦å³èŠ‚ç‚¹çš„é»‘é«˜ä¸ºbh(x)æˆ–è€…bh(x)-1.å³å®ƒçš„æœ€å°‘é»‘é«˜ä¸ºbh(x)-1ï¼Œåˆ™ ä»¥xä¸ºæ ¹çš„å­æ ‘ï¼Œè‡³å°‘å«æœ‰ $$ (2^{(bh(x)-1)}-1)+ (2^{(bh(x)-1)}-1)+1 = 2^{bh(x)}-1 $$ ä¸ªèŠ‚ç‚¹æ•°ï¼Œ ç”±æ€§è´¨4ï¼Œå¯ä»¥çœ‹å‡º å¯¹äºé«˜åº¦ä¸ºhçš„çº¢é»‘æ ‘ï¼Œå®ƒçš„é»‘é«˜è‡³å°‘ä¸º $h/2$,æ‰€ä»¥ $$ n&gt;=2^{(h/2)}-1 $$ è§£ä¹‹å¯ğŸ‰: $$ h&lt;= 2*log_2(n+1) $$ å¾—è¯ è°ƒæ•´èŠ‚ç‚¹ä¸avlæ ‘ï¼Œç±»ä¼¼ï¼Œçº¢é»‘æ ‘çš„æ’å…¥æˆ–è€…åˆ é™¤ï¼Œå¯èƒ½ç ´åå…¶å¹³è¡¡(æ€§è´¨)ã€‚å› æ­¤éœ€è¦è¿›è¡Œæ—‹è½¬è°ƒæ•´ã€‚ å¹³è¡¡çš„ç ´åæˆ‘ä»¬è®¾å®šæ¯æ¬¡æ’å…¥çš„å…ƒç´ éƒ½æ˜¯çº¢è‰²èŠ‚ç‚¹(è¿™æ ·å­å¯ä»¥é¿å…æœ€åæƒ…å†µçš„å‘ç”Ÿ)ï¼Œè¿™æ ·å­ä¸ä¼šç ´åæ€§è´¨1ã€3ã€5. å¯¹äºæ€§è´¨2çš„ç ´åï¼Œæˆ‘ä»¬å¾ˆå®¹æ˜“è¿›è¡Œè¯†åˆ«å‡ºæ¥ã€‚å¯¹äºæ€§è´¨4çš„ç ´åï¼Œæˆ‘ä»¬è¦è¿›è¡Œç®€å•åˆ†æä¸€ä¸‹ã€‚ å¯¹äºæ›´æ–°ç ´åçº¢é»‘æ ‘ç‰¹æ€§çš„é—®é¢˜ï¼Œæœ‰ä¸€äº›è°ƒæ•´çš„æ–¹æ³•: BST operation Color changes Restructure the tree via rotation (recolorã€lint) å·¦æ—‹ and å³æ—‹ è¿™äº›æ“ä½œåªæ˜¯è¿›è¡Œäº†æŒ‡é’ˆçš„äº¤æ¢ï¼Œè¯è´¹å¸¸æ•°æ—¶é—´ã€‚ Insert element (O(lgN))å¯¹äºæ–°æ’å…¥çš„èŠ‚ç‚¹ï¼Œæˆ‘ä»¬è®¾å®šå®ƒéƒ½æ˜¯çº¢è‰²çš„ï¼Œç„¶åé‡‡ç”¨ä¸€äº›æ“ä½œï¼Œå¯¹å…¶å¹³è¡¡æ€§è¿›è¡Œè°ƒæ•´ä¸»è¦çš„è°ƒæ•´æ–¹æ³•ä¸º: recolor rotation ä¸€ä¸ªä¾‹å­å…ˆé€šè¿‡ä¸€ä¸ªå®ä¾‹è¿›è¡Œè¯¦ç»†æè¿°ï¼Œåé¢åœ¨è¿›è¡ŒæŠ½è±¡ï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªçº¢é»‘æ ‘æ’å…¥å…ƒç´ 15çš„è¿‡ç¨‹ã€‚ å…ˆæ‰¾åˆ°å¾…æ’å…¥çš„ä½ç½®ï¼Œæ’å…¥å…ƒç´ 15ï¼Œå¹¶å°†å…¶ç€è‰²ä¸º çº¢è‰² 15çš„ç¥–çˆ¶èŠ‚ç‚¹é¢œè‰²æ˜¯é»‘è‰²ï¼Œè€Œå®ƒçš„çˆ¶èŠ‚ç‚¹ä»¥åŠå”èŠ‚ç‚¹é¢œè‰²æ˜¯çº¢è‰²ï¼Œå› æ­¤ï¼Œå¯ä»¥å°†ç¥–çˆ¶èŠ‚ç‚¹é¢œè‰²ä¸‹æ²‰ï¼Œå³é‡æ–°ç€è‰²ç¥–çˆ¶èŠ‚ç‚¹ä¸ºçº¢è‰²ï¼Œå”èŠ‚ç‚¹ä»¥åŠçˆ¶èŠ‚ç‚¹ä¸ºé»‘è‰²(case-1)ã€‚è¿™æ—¶ï¼Œå†²çªå°±å˜æˆäº† 10-18 é¢œè‰²å†²çª 10-18 é¢œè‰²å†²çªï¼Œä¸”å¯¹äºèŠ‚ç‚¹10æ¥è¯´ï¼Œå®ƒå¹¶æ»¡è¶³ï¼ˆcase-1ï¼‰çš„æƒ…å†µï¼Œæ— æ³•è¿›è¡Œé‡ç€è‰²æ¥æ»¡è¶³æ¡ä»¶4.æ­¤æ—¶ï¼Œé‡‡ç”¨æ—‹è½¬æ“ä½œï¼Œä»¥èŠ‚ç‚¹18è¿›è¡Œå³æ—‹ï¼ˆcase-2ï¼‰ï¼Œå°†10-18ä»¥åŠç¥–çˆ¶èŠ‚ç‚¹åœ¨ä¸€æ¡ç›´çº¿(çœ‹ä¸Šå»)ã€‚ 4. å†ä»¥èŠ‚ç‚¹7ä¸ºèŠ‚ç‚¹ï¼Œè¿›è¡Œå·¦æ—‹(case-3)ï¼Œç„¶åé‡æ–°ç€è‰²ï¼ˆæ¬¡æ•°å·¦å­æ ‘é»‘é«˜é™ä½ä¸€ï¼Œå› æ­¤éœ€è¦é‡æ–°ç€è‰²ï¼‰5. å°†è·ŸèŠ‚ç‚¹é‡æ–°ç€è‰²ã€‚ æŠ½è±¡å¯¹äºä»¥ä¸Šå¯ä»¥åˆ†ä¸ºä¸‰ç§çŠ¶æ€(æˆ–6ç§ï¼Œå› ä¸ºå·¦å³æƒ…å†µå¯¹ç§°,ä¸‹é¢å·²å·¦é¢æƒ…å†µä¸ºä¾‹)ã€‚ æ˜¯æ’å…¥çš„èŠ‚ç‚¹ï¼Œ`f(x)` æ˜¯å…¶çˆ¶èŠ‚ç‚¹ï¼Œ`f(f(x))` æ˜¯å…¶ç¥–çˆ¶èŠ‚ç‚¹ `uncle of x as u(x)` æ˜¯å…¶å”å”èŠ‚ç‚¹ï¼ˆyï¼‰ã€‚123456789101112å•çº¿æ¡æ˜¯é»‘è‰²èŠ‚ç‚¹ï¼ŒåŒçº¿æ¡æ˜¯çº¢è‰²##### case-1 ![](https://raw.githubusercontent.com/hsjfans/git_resource/master/20190506202531.png)è¯¥æƒ…å†µæ˜¯ï¼Œ`f(f(x))` æ˜¯é»‘è‰²ï¼Œ`f(x)`æ˜¯çº¢è‰²ï¼Œ`u(x)`æ˜¯çº¢è‰²ã€‚æ­¤æ—¶ï¼Œå¯ä»¥å°†å…¶ç¥–çˆ¶èŠ‚ç‚¹(`f(f(x))`)é¢œè‰²å“æˆï¼Œå³å˜æˆ color[f(x)] = BLACKcolor[f(f(x))] = REDcolor[u(x)] = BLACK 1234567891011æ­¤æ—¶ï¼Œå¯ä»¥è§£å†³èŠ‚ç‚¹xçš„é¢œè‰²å†²çªã€‚```cvoid re_color(RBTreeNode b){ b-&gt;parent-&gt;color = RED; b-&gt;parent-&gt;left-&gt;color = BLACK; b-&gt;parent-&gt;right-&gt;color = BLACK; return;} case-2 æ­¤æ—¶ï¼ŒèŠ‚ç‚¹yä¸æ˜¯çº¢è‰²ï¼Œæ— æ³•é€šè¿‡ç€è‰²æ¥è§£å†³ã€‚x æ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„å³èŠ‚ç‚¹ï¼Œè§†è§‰ä¸Šçœ‹ï¼ŒèŠ‚ç‚¹C-A-Bä¸å†ä¸€æ¡ç›´çº¿ä¸Šï¼Œæ­¤æ—¶é‡‡ç”¨æ—‹è½¬ï¼Œæ¥ä½¿èŠ‚ç‚¹C-A-Båœ¨ä¸€æ¡ç›´çº¿ä¸Š 1234567a-&gt;right = cc-&gt;left = bb-&gt;parent = ca-&gt;parent= c-&gt;parentc-&gt;parent = a 1234567891011121314151617181920212223242526// right rotationvoid right_rotation(RBTree t, RBTreeNode a){ RBTreeNode b = a-&gt;parent; a-&gt;parent = b-&gt;parent; if (b-&gt;parent == NULL) { t-&gt;root = a; } else if (b-&gt;parent-&gt;left == b) { b-&gt;parent-&gt;left = a; } else { b-&gt;parent-&gt;right = a; } if (a-&gt;right != NULL) { a-&gt;right-&gt;parent = b; } b-&gt;left = a-&gt;right; b-&gt;parent = a; a-&gt;right = b;} case-3 èŠ‚ç‚¹yä¸æ˜¯çº¢è‰²ï¼Œæ— æ³•é€šè¿‡ç€è‰²æ¥è§£å†³ã€‚x æ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹ï¼Œè§†è§‰ä¸Šçœ‹ï¼ŒèŠ‚ç‚¹C-A-Båœ¨ä¸€æ¡ç›´çº¿ä¸Šã€‚æ­¤æ—¶ï¼Œå¯ä»¥é‡‡ç”¨æ—‹è½¬åŠ é‡ç€è‰²è¿›è¡Œè°ƒæ•´ã€‚ 1234567891011c-&gt;left = a-&gt;righta-&gt;right = ca-&gt;parent=c-&gt;parentc-&gt;parent=ac-&gt;left=ccolor[a] = BLACKcolor[c] = RED 123456789101112131415161718192021222324252627void left_rotation(RBTree t, RBTreeNode a){ RBTreeNode b = a-&gt;right; a-&gt;right = b-&gt;left; if (a-&gt;left != NULL) { b-&gt;left-&gt;parent = a; } b-&gt;parent = a-&gt;parent; if (a-&gt;parent == NULL) { t-&gt;root = b; } else if (a == b-&gt;parent-&gt;left) { a-&gt;parent-&gt;left = b; } else { a-&gt;parent-&gt;right = b; } b-&gt;left = a; a-&gt;parent = b;} complicate123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596void insert(RBTree t, Element e, compare_func cmp){ RBTreeNode root = t-&gt;root; RBTreeNode temp = t-&gt;nil; while (root != t-&gt;nil) { temp = root; if (cmp(e, root-&gt;val) &lt; 0) { root = root-&gt;left; } else { root = root-&gt;right; } } RBTreeNode n = make_node(e); n-&gt;parent = temp; if (temp == t-&gt;nil) { t-&gt;root = n; } else if (cmp(e, temp-&gt;val) &lt; 0) { temp-&gt;left = n; } else { temp-&gt;right = n; } n-&gt;left = t-&gt;nil; n-&gt;right = t-&gt;nil; n-&gt;color = RED; insert_fix_up(t, n); return;}void insert_fix_up(RBTree t, RBTreeNode n){ while (n-&gt;parent-&gt;color == RED) { // left child subtree if (n-&gt;parent == n-&gt;parent-&gt;parent-&gt;left) { RBTreeNode y = n-&gt;parent-&gt;parent-&gt;right; // case-1 if (y-&gt;color == RED) { re_color(n-&gt;parent); n = n-&gt;parent-&gt;parent; } // case 2 else if (n == n-&gt;parent-&gt;right) { n = n-&gt;parent; left_rotation(t, n); } // case 3 else { n-&gt;parent-&gt;color = BLACK; n-&gt;parent-&gt;parent-&gt;color = RED; right_rotation(t, n-&gt;parent-&gt;parent); } } // right subtree else { RBTreeNode y = n-&gt;parent-&gt;parent-&gt;left; // case-1 if (y-&gt;color == RED) { re_color(n-&gt;parent); n = n-&gt;parent-&gt;parent; } // case 2 else if (n == n-&gt;parent-&gt;left) { n = n-&gt;parent; right_rotation(t, n); } // case 3 else { n-&gt;parent-&gt;color = BLACK; n-&gt;parent-&gt;parent-&gt;color = RED; left_rotation(t, n-&gt;parent-&gt;parent); } } } t-&gt;root-&gt;color = BLACK;} Deletion (O(lgN))åˆ é™¤è¾ƒæ’å…¥æ“ä½œæ›´ä¸ºå¤æ‚ä¸€äº›ã€‚ // todo Related skip_list avl_tree Treap RBTree and mysql Reference geeksforgeeks r_b_tree","link":"/2020/03/13/2020-03-13-RB-Tree/"},{"title":"ä¸‰ä½“â…¡- é»‘æš—æ£®æ—","text":"çœ‹å®Œå°è±¡æ·±åˆ»çš„ä¸æ˜¯è‘—åçš„â€œå®‡å®™ç¤¾ä¼šå­¦â€ï¼Œè€Œæ˜¯ç»“å±€æ—¶é‚£ä¸ªæ›¾ç»ç»™åœ°çƒå‘è¿‡è­¦å‘Šçš„ä¸‰ä½“äººçš„ä¸€å¥è¯ï¼š æˆ‘åªæ˜¯æƒ³å’Œæ‚¨è®¨è®ºä¸€ç§å¯èƒ½ï¼šä¹Ÿè®¸çˆ±çš„èŒèŠ½åœ¨å®‡å®™çš„å…¶ä»–åœ°æ–¹ä¹Ÿå­˜åœ¨ï¼Œæˆ‘ä»¬åº”è¯¥åˆ°å¤„é¼“åŠ±å¥¹çš„èŒå‘å’Œæˆé•¿ã€‚ ä¸ºæ­¤æˆ‘ä»¬å¯ä»¥å†’é™©ã€‚å¯¹ï¼Œå¯ä»¥å†’é™©ã€‚","link":"/2020/03/13/2020-03-13-%E4%B8%89%E4%BD%93%E2%85%A1--%E9%BB%91%E6%9A%97%E6%A3%AE%E6%9E%97/"},{"title":"æœºå™¨å­¦ä¹ å…¥é—¨å¯¼è®º","text":"æœºå™¨å­¦ä¹ æˆ–è€…æ˜¯äººå·¥æ™ºèƒ½å…¥é—¨éœ€è¦è¾ƒæ·±çš„æ•°å­¦åŸºç¡€ï¼Œå¦‚ ã€ŠçŸ©é˜µåˆ†æã€‹ã€ã€Šæ•°å€¼ä¼˜åŒ–ã€‹è¿˜æœ‰æ¦‚ç‡è®ºç›¸å…³çš„çŸ¥è¯†ã€‚åé¢åˆä¼šæ¶‰åŠåˆ° å›¾è®¡ç®—ï¼Œå„ç§ç¥ç»ç½‘ç»œçš„æ¨¡å‹å’Œå±‚å‡ºä¸ç©·çš„è®ºæ–‡ã€‚è¿™éœ€è¦æœ‰ä¸€ç§â€œè¡£å¸¦æ¸å®½ç»ˆä¸æ‚”ï¼Œä¸ºä¼Šæ¶ˆå¾—äººæ†”æ‚´â€çš„ç²¾ç¥ã€‚ä¸‹é¢å†™å‡ºä¸€äº›å­¦ä¹ ç”¨çš„ä¹¦å• ï¼ˆæŒç»­æ›´æ–°â€¦ï¼‰ ã€Šæœºå™¨å­¦ä¹ ã€‹ï¼ˆè¥¿ç“œä¹¦ï¼‰ã€ŠçŸ©é˜µåˆ†æã€‹ã€Šæ•°å€¼ä¼˜åŒ–ã€‹ã€Šprmlã€‹ã€Šç»Ÿè®¡å­¦ä¹ æ–¹æ³•ã€‹ â€¦ å½“ç„¶è¿™ä¹Ÿç¦»ä¸å¼€æ‰å®çš„è®¡ç®—æœºåŸºç¡€ï¼Œå¦‚å›¾è®ºï¼Œc/c++ï¼Œpythonç­‰ æ€»ä¹‹ï¼Œäººç”Ÿå½“ä»°æœ›æ˜Ÿç©ºï¼Œå­¦ä¹ å½“è„šè¸å®åœ°ï½ï½ï½","link":"/2020/03/13/2020-03-13-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E5%AF%BC%E8%AE%BA/"},{"title":"62. ä¸åŒè·¯å¾„","text":"ä¸€ä¸ªæœºå™¨äººä½äºä¸€ä¸ª m x n ç½‘æ ¼çš„å·¦ä¸Šè§’ ï¼ˆèµ·å§‹ç‚¹åœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸ºâ€œStartâ€ ï¼‰ã€‚ æœºå™¨äººæ¯æ¬¡åªèƒ½å‘ä¸‹æˆ–è€…å‘å³ç§»åŠ¨ä¸€æ­¥ã€‚æœºå™¨äººè¯•å›¾è¾¾åˆ°ç½‘æ ¼çš„å³ä¸‹è§’ï¼ˆåœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸ºâ€œFinishâ€ï¼‰ã€‚ é—®æ€»å…±æœ‰å¤šå°‘æ¡ä¸åŒçš„è·¯å¾„ï¼Ÿ ä¾‹å¦‚ï¼Œä¸Šå›¾æ˜¯ä¸€ä¸ª7 x 3 çš„ç½‘æ ¼ã€‚æœ‰å¤šå°‘å¯èƒ½çš„è·¯å¾„ï¼Ÿ ç¤ºä¾‹ 1:1234567è¾“å…¥: m = 3, n = 2è¾“å‡º: 3è§£é‡Š:ä»å·¦ä¸Šè§’å¼€å§‹ï¼Œæ€»å…±æœ‰ 3 æ¡è·¯å¾„å¯ä»¥åˆ°è¾¾å³ä¸‹è§’ã€‚1. å‘å³ -&gt; å‘å³ -&gt; å‘ä¸‹2. å‘å³ -&gt; å‘ä¸‹ -&gt; å‘å³3. å‘ä¸‹ -&gt; å‘å³ -&gt; å‘å³ ç¤ºä¾‹ 2:12è¾“å…¥: m = 7, n = 3è¾“å‡º: 28 æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/unique-paths SolutionåŠ¨æ€è§„åˆ’é—®ï¼Œé€’æ¨å…¬å¼ä¸º $$F(m,n)=\\begin{cases}1,\\quad m=1 or n=1\\F(m-1,n) + F(m,n-1), \\quad m&gt;1 and n &gt; 1\\end{cases}$$ Code12345678910111213141516171819class Solution {public: int uniquePaths(int m, int n) { int maps[m+1][n+1]; fill(maps[0],maps[0]+(m+1)*(n+1),0); for(int i=1;i&lt;=m;i++){ for(int j=1;j&lt;=n;j++){ if(i==1 || j==1) maps[i][j] = 1; else{ maps[i][j] = maps[i-1][j] + maps[i][j-1]; } } } return maps[m][n]; }};","link":"/2020/03/17/2020-03-17-62.-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"},{"title":"63. ä¸åŒè·¯å¾„ II","text":"ä¸€ä¸ªæœºå™¨äººä½äºä¸€ä¸ª m x n ç½‘æ ¼çš„å·¦ä¸Šè§’ ï¼ˆèµ·å§‹ç‚¹åœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸ºâ€œStartâ€ ï¼‰ã€‚ æœºå™¨äººæ¯æ¬¡åªèƒ½å‘ä¸‹æˆ–è€…å‘å³ç§»åŠ¨ä¸€æ­¥ã€‚æœºå™¨äººè¯•å›¾è¾¾åˆ°ç½‘æ ¼çš„å³ä¸‹è§’ï¼ˆåœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸ºâ€œFinishâ€ï¼‰ã€‚ ç°åœ¨è€ƒè™‘ç½‘æ ¼ä¸­æœ‰éšœç¢ç‰©ã€‚é‚£ä¹ˆä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’å°†ä¼šæœ‰å¤šå°‘æ¡ä¸åŒçš„è·¯å¾„ï¼Ÿç½‘æ ¼ä¸­çš„éšœç¢ç‰©å’Œç©ºä½ç½®åˆ†åˆ«ç”¨ 1 å’Œ 0 æ¥è¡¨ç¤ºã€‚ è¯´æ˜ï¼šm å’Œ n çš„å€¼å‡ä¸è¶…è¿‡ 100ã€‚ ç¤ºä¾‹ 1:123456789101112è¾“å…¥:[ [0,0,0], [0,1,0], [0,0,0]]è¾“å‡º: 2è§£é‡Š:3x3 ç½‘æ ¼çš„æ­£ä¸­é—´æœ‰ä¸€ä¸ªéšœç¢ç‰©ã€‚ä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’ä¸€å…±æœ‰ 2 æ¡ä¸åŒçš„è·¯å¾„ï¼š1. å‘å³ -&gt; å‘å³ -&gt; å‘ä¸‹ -&gt; å‘ä¸‹2. å‘ä¸‹ -&gt; å‘ä¸‹ -&gt; å‘å³ -&gt; å‘å³ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/unique-paths-ii Solutionä¸ä¸Šä¸€é¢˜å·®ä¸å¤šï¼Œä¸åŒçš„æ˜¯å¢åŠ äº†éšœç¢ç‰©ï¼Œåªéœ€è¦å°†éšœç¢ç‰©å¤„è®¾ç½®ä¸º 0 å³å¯ï¼›é€’æ¨å¼ä¸º:$$F(m,n)=\\begin{cases}0,\\quad obstacleGrid[m][n] = 1\\F(m,n-1),\\quad m=1 and obstacleGrid[m][n] = 0\\F(m-1,n),\\quad n=1 and obstacleGrid[m][n] = 0\\F(m-1,n) + F(m,n-1), \\quad m&gt;1 and n &gt; 1\\end{cases}$$ Code1234567891011121314151617181920class Solution {public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) { int m = obstacleGrid.size(),n = obstacleGrid[0].size(); long maps[m][n]; fill(maps[0],maps[0]+m*n,0); for(int i=0;i&lt;m;i++){ for(int j=0;j&lt;n;j++){ if(obstacleGrid[i][j]==1) maps[i][j] = 0; else{ if(i == 0 &amp;&amp; j ==0) maps[i][j] = 1; else if(i==0) maps[i][j] = maps[i][j-1]; else if(j==0) maps[i][j] = maps[i-1][j]; else maps[i][j] = maps[i-1][j] + maps[i][j-1]; } } } return maps[m-1][n-1]; }};","link":"/2020/03/17/2020-03-17-63.-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-II/"},{"title":"1143. æœ€é•¿å…¬å…±å­åºåˆ—","text":"ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸² text1 å’Œ text2ï¼Œè¿”å›è¿™ä¸¤ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å…¬å…±å­åºåˆ—ã€‚ ä¸€ä¸ªå­—ç¬¦ä¸²çš„ å­åºåˆ— æ˜¯æŒ‡è¿™æ ·ä¸€ä¸ªæ–°çš„å­—ç¬¦ä¸²ï¼šå®ƒæ˜¯ç”±åŸå­—ç¬¦ä¸²åœ¨ä¸æ”¹å˜å­—ç¬¦çš„ç›¸å¯¹é¡ºåºçš„æƒ…å†µä¸‹åˆ é™¤æŸäº›å­—ç¬¦ï¼ˆä¹Ÿå¯ä»¥ä¸åˆ é™¤ä»»ä½•å­—ç¬¦ï¼‰åç»„æˆçš„æ–°å­—ç¬¦ä¸²ã€‚ä¾‹å¦‚ï¼Œâ€aceâ€ æ˜¯ â€œabcdeâ€ çš„å­åºåˆ—ï¼Œä½† â€œaecâ€ ä¸æ˜¯ â€œabcdeâ€ çš„å­åºåˆ—ã€‚ä¸¤ä¸ªå­—ç¬¦ä¸²çš„ã€Œå…¬å…±å­åºåˆ—ã€æ˜¯è¿™ä¸¤ä¸ªå­—ç¬¦ä¸²æ‰€å…±åŒæ‹¥æœ‰çš„å­åºåˆ—ã€‚ è‹¥è¿™ä¸¤ä¸ªå­—ç¬¦ä¸²æ²¡æœ‰å…¬å…±å­åºåˆ—ï¼Œåˆ™è¿”å› 0ã€‚ ç¤ºä¾‹ 1:12345678910111213è¾“å…¥ï¼štext1 = &quot;abcde&quot;, text2 = &quot;ace&quot; è¾“å‡ºï¼š3 è§£é‡Šï¼šæœ€é•¿å…¬å…±å­åºåˆ—æ˜¯ &quot;ace&quot;ï¼Œå®ƒçš„é•¿åº¦ä¸º 3ã€‚ç¤ºä¾‹ 2:è¾“å…¥ï¼štext1 = &quot;abc&quot;, text2 = &quot;abc&quot;è¾“å‡ºï¼š3è§£é‡Šï¼šæœ€é•¿å…¬å…±å­åºåˆ—æ˜¯ &quot;abc&quot;ï¼Œå®ƒçš„é•¿åº¦ä¸º 3ã€‚ç¤ºä¾‹ 3:è¾“å…¥ï¼štext1 = &quot;abc&quot;, text2 = &quot;def&quot;è¾“å‡ºï¼š0è§£é‡Šï¼šä¸¤ä¸ªå­—ç¬¦ä¸²æ²¡æœ‰å…¬å…±å­åºåˆ—ï¼Œè¿”å› 0ã€‚ æç¤º:1231 &lt;= text1.length &lt;= 10001 &lt;= text2.length &lt;= 1000è¾“å…¥çš„å­—ç¬¦ä¸²åªå«æœ‰å°å†™è‹±æ–‡å­—ç¬¦ã€‚ SolutionLCS é—®é¢˜é€’å½’å¼ $$c(m,n)=\\begin{cases}0 ,\\quad m=0 or n =0 \\c(m-1,n-1) + 1),\\quad text1[m]=text2[n] and m &gt;0,n&gt;0 \\ max(c(m-1,n),c(m,n-1)), \\quad m&gt;0 and n &gt; 0\\end{cases}$$ Code123456789101112131415class Solution {public: int longestCommonSubsequence(string text1, string text2) { int m = text1.size(), n = text2.size(); int c[m+1][n+1]; for(int i=0;i&lt;=m;i++){ for(int j=0;j&lt;=n;j++){ if(i==0||j==0) c[i][j] = 0; else if(text1[i-1] == text2[j-1]) c[i][j] = c[i-1][j-1] + 1; else c[i][j] = max(c[i-1][j],c[i][j-1]); } } return c[m][n]; }};","link":"/2020/03/19/2020-03-19-1143.-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"},{"title":"64. æœ€å°è·¯å¾„å’Œ","text":"ç»™å®šä¸€ä¸ªåŒ…å«éè´Ÿæ•´æ•°çš„ m x n ç½‘æ ¼ï¼Œè¯·æ‰¾å‡ºä¸€æ¡ä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’çš„è·¯å¾„ï¼Œä½¿å¾—è·¯å¾„ä¸Šçš„æ•°å­—æ€»å’Œä¸ºæœ€å°ã€‚ è¯´æ˜ï¼šæ¯æ¬¡åªèƒ½å‘ä¸‹æˆ–è€…å‘å³ç§»åŠ¨ä¸€æ­¥ã€‚ ç¤ºä¾‹:12345678è¾“å…¥:[ [1,3,1], [1,5,1], [4,2,1]]è¾“å‡º: 7è§£é‡Š: å› ä¸ºè·¯å¾„ 1â†’3â†’1â†’1â†’1 çš„æ€»å’Œæœ€å°ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/minimum-path-sum SolutionåŠ¨æ€è§„åˆ’ï¼Œé€’å½’å¼ä¹Ÿå¾ˆç®€å• $$grid(m,n)=\\begin{cases}grid(m,n) ,\\quad m=0 and n =0 \\grid(m,n) + grid(m,n-1),\\quad m=0 \\grid(m,n) + grid(m-1,n),\\quad n=0 \\grid(m,n) + min(grid(m-1,n),grid(m,n-1)), \\quad m&gt;0 and n &gt; 0\\end{cases}$$ Code123456789101112131415class Solution {public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m = grid.size(),n = grid[0].size(); for(int i=0;i&lt;m;i++){ for(int j=0;j&lt;n;j++){ if(i==0 &amp;&amp; j==0) continue; else if(i==0) grid[i][j] += grid[i][j-1]; else if(j==0) grid[i][j] += grid[i-1][j]; else grid[i][j] = grid[i][j] + min(grid[i-1][j],grid[i][j-1]); } } return grid[m-1][n-1]; }};","link":"/2020/03/17/2020-03-17-64.-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"},{"title":"72. ç¼–è¾‘è·ç¦»","text":"ç»™å®šä¸¤ä¸ªå•è¯ word1 å’Œ word2ï¼Œè®¡ç®—å‡ºå°† word1 è½¬æ¢æˆ word2 æ‰€ä½¿ç”¨çš„æœ€å°‘æ“ä½œæ•° ã€‚ ä½ å¯ä»¥å¯¹ä¸€ä¸ªå•è¯è¿›è¡Œå¦‚ä¸‹ä¸‰ç§æ“ä½œï¼š æ’å…¥ä¸€ä¸ªå­—ç¬¦åˆ é™¤ä¸€ä¸ªå­—ç¬¦æ›¿æ¢ä¸€ä¸ªå­—ç¬¦##ç¤ºä¾‹ 1: 123456è¾“å…¥: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;è¾“å‡º: 3è§£é‡Š: horse -&gt; rorse (å°† 'h' æ›¿æ¢ä¸º 'r')rorse -&gt; rose (åˆ é™¤ 'r')rose -&gt; ros (åˆ é™¤ 'e') ##ç¤ºä¾‹ 2: 12345678è¾“å…¥: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;è¾“å‡º: 5è§£é‡Š: intention -&gt; inention (åˆ é™¤ 't')inention -&gt; enention (å°† 'i' æ›¿æ¢ä¸º 'e')enention -&gt; exention (å°† 'n' æ›¿æ¢ä¸º 'x')exention -&gt; exection (å°† 'n' æ›¿æ¢ä¸º 'c')exection -&gt; execution (æ’å…¥ 'u') æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/edit-distance Solutiondp[i][j] ä»£è¡¨ word1[i] åˆ° word2[j] çš„æœ€å°å˜æ¢ word1[i] == word2[j] iå’Œj åŒæ—¶å‘å‰ç§»åŠ¨ä¸€ä½ å³ dp[i][j] == dp[i-1][j-1] word1[i] $\\neq$ word2[j] æ­¤æ—¶æœ‰ä¸‰ç§æ–¹æ¡ˆ æ›¿æ¢ å³ä»¤ word1[i] = word2[j] ï¼Œæœ‰ dp[i][j] == dp[i-1][j-1] + 1 åˆ é™¤ï¼Œå³åˆ æ‰å…ƒç´  word1[i],æ­¤æ—¶æœ‰ dp[i][j] == dp[i-1][j] + 1 æ’å…¥ï¼Œå³åœ¨ word1 i å¤„æ’å…¥ å…ƒç´  word2[j] ï¼Œæ­¤æ—¶æœ‰ dp[i][j] == dp[i][j-1] + 1 å–ä»¥ä¸Šä¸‰è€…æœ€å°å€¼å³å¯ dp[i][j] = min{dp[i-1][j-1] ,dp[i-1][j] ,dp[i][j-1] }+1 Code12345678910111213141516171819class Solution {public: int minDistance(string word1, string word2){ int m = word1.size(), n =word2.size(); int dp[m+1][n+1]; for(int i=0;i&lt;=m;i++) dp[i][0] = i; for(int i=0;i&lt;=n;i++) dp[0][i] = i; for(int i=1;i&lt;=m;i++){ for(int j=1;j&lt;=n;j++){ if(word1[i-1]== word2[j-1]) dp[i][j] = dp[i-1][j-1]; else { dp[i][j] = min(min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1]) + 1; } } } return dp[m][n];}};","link":"/2020/03/19/2020-03-19-72.-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"},{"title":"1048 Find Coins (25åˆ†)","text":"Eva loves to collect coins from all over the universe, including some other planets like Mars. One day she visited a universal shopping mall which could accept all kinds of coins as payments. However, there was a special requirement of the payment: for each bill, she could only use exactly two coins to pay the exact amount. Since she has as many as 10â€‹5â€‹â€‹ coins with her, she definitely needs your help. You are supposed to tell her, for any given amount of money, whether or not she can find two coins to pay for it. Input Specification:Each input file contains one test case. For each case, the first line contains 2 positive numbers: N (â‰¤$10^5$, the total number of coins) and M (â‰¤$10^3$) , the amount of money Eva has to pay). The second line contains N face values of the coins, which are all positive numbers no more than 500. All the numbers in a line are separated by a space. Output Specification:For each test case, print in one line the two face values $V_1$ and $V_2$â€‹â€‹ (separated by a space) such that $V_1 + V_2 = m$ and $V_1 &lt;= V_2$. If such a solution is not unique, output the one with the smallest $V_1$. If there is no solution, output No Solution instead. SampleInput 1:128 151 2 8 7 2 4 11 15 Output 1:14 11 Input 2:127 141 8 7 2 4 11 15 Output 2:1No Solution Solutionå‚è§ leetcode çš„ Two-Sumï¼Œå…¥é—¨çº§é—®é¢˜ Code1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;void pat_1048(){ int n,m; cin &gt;&gt; n &gt;&gt; m; int maps[m]; fill(maps,maps+m,0); int v1 = m,coin; for(int i=0;i&lt;n;i++){ cin &gt;&gt; coin; if(m &gt; coin){ if(maps[coin]==1){ v1 = min(coin,min(m-coin,v1)); }else maps[m-coin] = 1; } } if( v1 != m ) cout &lt;&lt; v1 &lt;&lt; &quot; &quot; &lt;&lt; m-v1; else cout &lt;&lt; &quot;No Solution&quot; &lt;&lt; endl; }int main(){ pat_1048(); return 0;}","link":"/2020/03/22/2020-03-22-1048-Find-Coins-(25%E5%88%86)/"},{"title":"1030 Travel Plan (30åˆ†)","text":"A travelerâ€™s map gives the distances between cities along the highways, together with the cost of each highway. Now you are supposed to write a program to help a traveler to decide the shortest path between his/her starting city and the destination. If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique. Input Specification:Each input file contains one test case. Each case starts with a line containing 4 positive integers N, M, S, and D, where N (â‰¤500) is the number of cities (and hence the cities are numbered from 0 to Nâˆ’1); M is the number of highways; S and D are the starting and the destination cities, respectively. Then M lines follow, each provides the information of a highway, in the format: 1City1 City2 Distance Cost where the numbers are all integers no more than 500, and are separated by a space. Output Specification:For each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output. SampleInput:1234564 5 0 30 1 1 201 3 2 300 3 4 100 2 2 202 3 1 20 Output:10 2 3 3 40 Solutionæœ€çŸ­è·¯å¾„é—®é¢˜ï¼Œä¿®æ”¹ Dijkstra ç®—æ³•ï¼Œè®°å½•ä¸‹å…¶ æƒé‡ã€ä»£ä»·ä»¥åŠ å‰è·¯å¾„å³å¯ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;using namespace std;void pat_1030(){ int n,m,s,d; int max = 0x7fffffff; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; d; // è·ç¦»,æˆæœ¬ï¼Œè·¯å¾„ä»¥åŠæ˜¯å¦è®¿é—®è¿‡ int distance[n],costs[n],paths[n],visited[n]; int v[n][n],c[n][n]; fill(v[0],v[0]+n*n,0); fill(distance,distance+n,max); fill(costs,costs+n,max); fill(visited,visited+n,0); fill(paths,paths+n,s); int i,x,y,dis,cost; for(i=0;i&lt;m;i++){ cin &gt;&gt; x &gt;&gt; y &gt;&gt; dis &gt;&gt; cost; v[x][y] = dis; v[y][x] = dis; c[x][y] = cost; c[y][x] = cost; } // æœ€çŸ­è·¯å¾„é—®é¢˜ int visit =0,cur = s,min_id=s,min; visited[cur] = 1; costs[cur] = 0; distance[cur] = 0; while(visit&lt;n &amp;&amp; cur!=d){ min = max; for(int k=0;k&lt;n;k++){ // å­˜åœ¨è·¯å¾„ if(v[cur][k] &gt; 0 &amp;&amp; !visited[k]){ dis = v[cur][k] + distance[cur]; cost = c[cur][k] + costs[cur]; if(dis &lt; distance[k] ){ distance[k] = dis; paths[k] = cur; costs[k] = cost; } else if(dis == distance[k]){ if(cost &lt; costs[k]) { costs[k] = cost; paths[k] = cur; } } } if(!visited[k] &amp;&amp; distance[k] &lt; min ){ min = distance[k]; min_id = k; } } cur = min_id; visited[cur] = 1; visit++; } int target = d; string res = to_string(d)+&quot; &quot;; while(d!=paths[d]){ res = to_string(paths[d]) + &quot; &quot; + res; d = paths[d]; } cout &lt;&lt; res &lt;&lt; distance[target] &lt;&lt; &quot; &quot; &lt;&lt; costs[target];}int main(){ pat_1030(); return 0;}","link":"/2020/03/10/2020-03-10-1030-Travel-Plan-(30%E5%88%86)/"},{"title":"123. ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº III","text":"ç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œå®ƒçš„ç¬¬ i ä¸ªå…ƒç´ æ˜¯ä¸€æ”¯ç»™å®šçš„è‚¡ç¥¨åœ¨ç¬¬ i å¤©çš„ä»·æ ¼ã€‚ è®¾è®¡ä¸€ä¸ªç®—æ³•æ¥è®¡ç®—ä½ æ‰€èƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚ä½ æœ€å¤šå¯ä»¥å®Œæˆ ä¸¤ç¬” äº¤æ˜“ã€‚ æ³¨æ„: ä½ ä¸èƒ½åŒæ—¶å‚ä¸å¤šç¬”äº¤æ˜“ï¼ˆä½ å¿…é¡»åœ¨å†æ¬¡è´­ä¹°å‰å‡ºå”®æ‰ä¹‹å‰çš„è‚¡ç¥¨ï¼‰ã€‚ ç¤ºä¾‹ 1:12è¾“å…¥: [3,3,5,0,0,3,1,4]è¾“å‡º: 6 è§£é‡Š: åœ¨ç¬¬ 4 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 0ï¼‰çš„æ—¶å€™ä¹°å…¥ï¼Œåœ¨ç¬¬ 6 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 3ï¼‰çš„æ—¶å€™å–å‡ºï¼Œè¿™ç¬”äº¤æ˜“æ‰€èƒ½è·å¾—åˆ©æ¶¦ = 3-0 = 3 ã€‚ éšåï¼Œåœ¨ç¬¬ 7 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 1ï¼‰çš„æ—¶å€™ä¹°å…¥ï¼Œåœ¨ç¬¬ 8 å¤© ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 4ï¼‰çš„æ—¶å€™å–å‡ºï¼Œè¿™ç¬”äº¤æ˜“æ‰€èƒ½è·å¾—åˆ©æ¶¦ = 4-1 = 3 ã€‚ ç¤ºä¾‹ 2:12è¾“å…¥: [1,2,3,4,5]è¾“å‡º: 4 è§£é‡Š: åœ¨ç¬¬ 1 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 1ï¼‰çš„æ—¶å€™ä¹°å…¥ï¼Œåœ¨ç¬¬ 5 å¤© ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 5ï¼‰çš„æ—¶å€™å–å‡º, è¿™ç¬”äº¤æ˜“æ‰€èƒ½è·å¾—åˆ©æ¶¦ = 5-1 = 4 ã€‚ æ³¨æ„ä½ ä¸èƒ½åœ¨ç¬¬ 1 å¤©å’Œç¬¬ 2 å¤©æ¥è¿è´­ä¹°è‚¡ç¥¨ï¼Œä¹‹åå†å°†å®ƒä»¬å–å‡ºã€‚ å› ä¸ºè¿™æ ·å±äºåŒæ—¶å‚ä¸äº†å¤šç¬”äº¤æ˜“ï¼Œä½ å¿…é¡»åœ¨å†æ¬¡è´­ä¹°å‰å‡ºå”®æ‰ä¹‹å‰çš„è‚¡ç¥¨ã€‚ ç¤ºä¾‹ 3:12è¾“å…¥: [7,6,4,3,1] è¾“å‡º: 0 è§£é‡Š: åœ¨è¿™ä¸ªæƒ…å†µä¸‹, æ²¡æœ‰äº¤æ˜“å®Œæˆ, æ‰€ä»¥æœ€å¤§åˆ©æ¶¦ä¸º 0ã€‚ Solutioné€’å½’å¼ä¸º $$res = max( \\sum_{j=0}^{n-1} (profits[j]+profits-reverse[j]) )$$ å…¶ä¸­ $profits[j]$ ä»£è¡¨ä¸º æ­£å‘(0,j.) èƒ½å¤Ÿè·å–çš„æœ€å¤§åˆ©æ¶¦ï¼›$profits-reverse[j]$ ä»£è¡¨(j,n-1)èƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦ Code123456789101112131415161718192021222324class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int n = prices.size(); if(n&lt;=1) return 0; int profits[n]; fill(profits,profits+n,0); int less = prices[0]; for(int i=1;i&lt;n;i++){ profits[i] = max(prices[i]-less,profits[i-1]); less = min(less,prices[i]); } int res = profits[n-1],last,ma = prices[n-1]; profits[n-1] = 0; for(int j=n-2;j&gt;=0;j--){ last = profits[j]; profits[j] = max(profits[j+1],ma - prices[j]); ma = max(ma,prices[j]); res = max(res,last + profits[j]); } return res; }};","link":"/2020/03/22/2020-03-22-123.-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-III/"},{"title":"208. å®ç° Trie (å‰ç¼€æ ‘)","text":"å®ç°ä¸€ä¸ª Trie (å‰ç¼€æ ‘)ï¼ŒåŒ…å« insert, search, å’Œ startsWith è¿™ä¸‰ä¸ªæ“ä½œã€‚ ç¤ºä¾‹: 12345678Trie trie = new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;); // è¿”å› truetrie.search(&quot;app&quot;); // è¿”å› falsetrie.startsWith(&quot;app&quot;); // è¿”å› truetrie.insert(&quot;app&quot;); trie.search(&quot;app&quot;); // è¿”å› true è¯´æ˜: ä½ å¯ä»¥å‡è®¾æ‰€æœ‰çš„è¾“å…¥éƒ½æ˜¯ç”±å°å†™å­—æ¯ a-z æ„æˆçš„ã€‚ä¿è¯æ‰€æœ‰è¾“å…¥å‡ä¸ºéç©ºå­—ç¬¦ä¸²ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/implement-trie-prefix-treeè‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Node{public: char c; map&lt;char, Node&gt; next; int end; Node(char c) { this-&gt;c = c; this-&gt;end = 0; } Node(){};};class Trie{public: Node root; /** Initialize your data structure here. */ Trie() { root = Node(); } /** Inserts a word into the trie. */ void insert(string word) { Node *p = &amp;root; for(char c:word){ if(p-&gt;next.find(c) == p-&gt;next.end()){ p-&gt;next[c] = Node(c); } p = &amp;(p-&gt;next[c]); } p-&gt;end = 1; } /** Returns if the word is in the trie. */ bool search(string word) { Node *p = &amp;root; for(char c:word){ if(p-&gt;next.find(c) == p-&gt;next.end()) return false; p = &amp;(p-&gt;next[c]); } return p-&gt;end == 1; } /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith(string prefix) { Node *p = &amp;root; for(char c:prefix){ if(p-&gt;next.find(c) == p-&gt;next.end()) return false; p = &amp;(p-&gt;next[c]); } return true; }};/** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj-&gt;insert(word); * bool param_2 = obj-&gt;search(word); * bool param_3 = obj-&gt;startsWith(prefix); */","link":"/2020/03/24/2020-03-24-208.-%E5%AE%9E%E7%8E%B0-Trie-(%E5%89%8D%E7%BC%80%E6%A0%91)/"},{"title":"679. 24 ç‚¹æ¸¸æˆ","text":"ä½ æœ‰ 4 å¼ å†™æœ‰ 1 åˆ° 9 æ•°å­—çš„ç‰Œã€‚ä½ éœ€è¦åˆ¤æ–­æ˜¯å¦èƒ½é€šè¿‡ *ï¼Œ/ï¼Œ+ï¼Œ-ï¼Œ(ï¼Œ) çš„è¿ç®—å¾—åˆ° 24ã€‚ ç¤ºä¾‹ 1: 123è¾“å…¥: [4, 1, 8, 7]è¾“å‡º: Trueè§£é‡Š: (8-4) * (7-1) = 24 ç¤ºä¾‹ 2: 12è¾“å…¥: [1, 2, 1, 2]è¾“å‡º: False æ³¨æ„: é™¤æ³•è¿ç®—ç¬¦ / è¡¨ç¤ºå®æ•°é™¤æ³•ï¼Œè€Œä¸æ˜¯æ•´æ•°é™¤æ³•ã€‚ä¾‹å¦‚ 4 / (1 - 2/3) = 12 ã€‚æ¯ä¸ªè¿ç®—ç¬¦å¯¹ä¸¤ä¸ªæ•°è¿›è¡Œè¿ç®—ã€‚ç‰¹åˆ«æ˜¯æˆ‘ä»¬ä¸èƒ½ç”¨ - ä½œä¸ºä¸€å…ƒè¿ç®—ç¬¦ã€‚ä¾‹å¦‚ï¼Œ[1, 1, 1, 1] ä½œä¸ºè¾“å…¥æ—¶ï¼Œè¡¨è¾¾å¼ -1 - 1 - 1 - 1 æ˜¯ä¸å…è®¸çš„ã€‚ä½ ä¸èƒ½å°†æ•°å­—è¿æ¥åœ¨ä¸€èµ·ã€‚ä¾‹å¦‚ï¼Œè¾“å…¥ä¸º [1, 2, 1, 2] æ—¶ï¼Œä¸èƒ½å†™æˆ 12 + 12 ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/24-gameè‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ Solutionç©·ä¸¾æ³•ï¼Œåˆ—å‡ºæ‰€æœ‰å¯èƒ½æ€§ï¼Œè¾¹è¿›è¡Œè¾¹å¯¹æ¯” Code1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: bool solve(vector&lt;double&gt; nums) { if (nums.size() == 0) return false; if (nums.size() == 1) return abs(nums[0] - 24) &lt; 1e-6; for (int i = 0; i &lt; nums.size(); i++) { for (int j = 0; j &lt; nums.size(); j++) { if (i != j) { vector&lt;double&gt; nums2; for (int k = 0; k &lt; nums.size(); k++) if (k != i &amp;&amp; k != j) { nums2.push_back(nums[k]); } for (int k = 0; k &lt; 4; k++) { if (k &lt; 2 &amp;&amp; j &gt; i) continue; if (k == 0) nums2.push_back(nums[i] + nums[j]); if (k == 1) nums2.push_back(nums[i] * nums[j]); if (k == 2) nums2.push_back(nums[i] - nums[j]); if (k == 3) { if (nums[j] != 0) { nums2.push_back(nums[i] / nums[j]); } else { continue; } } if (solve(nums2)) return true; nums2.erase(nums2.end()-1); } } } } return false; } bool judgePoint24(vector&lt;int&gt;&amp; nums) { vector&lt;double&gt; nums2; for(int i=0;i&lt;nums.size();i++) nums2.push_back((double)nums[i]); return solve(nums2); }};","link":"/2020/03/24/2020-03-24-679.-24-%E7%82%B9%E6%B8%B8%E6%88%8F/"},{"title":"98. éªŒè¯äºŒå‰æœç´¢æ ‘","text":"ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œåˆ¤æ–­å…¶æ˜¯å¦æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„äºŒå‰æœç´¢æ ‘ã€‚ å‡è®¾ä¸€ä¸ªäºŒå‰æœç´¢æ ‘å…·æœ‰å¦‚ä¸‹ç‰¹å¾ï¼š èŠ‚ç‚¹çš„å·¦å­æ ‘åªåŒ…å«å°äºå½“å‰èŠ‚ç‚¹çš„æ•°ã€‚ èŠ‚ç‚¹çš„å³å­æ ‘åªåŒ…å«å¤§äºå½“å‰èŠ‚ç‚¹çš„æ•°ã€‚ æ‰€æœ‰å·¦å­æ ‘å’Œå³å­æ ‘è‡ªèº«å¿…é¡»ä¹Ÿæ˜¯äºŒå‰æœç´¢æ ‘ã€‚ç¤ºä¾‹ 1:12345è¾“å…¥: 2 / \\ 1 3è¾“å‡º: true ç¤ºä¾‹ 2:1234567è¾“å…¥: 5 / \\ 1 4 / \\ 3 6è¾“å‡º: false è§£é‡Š: è¾“å…¥ä¸º: [5,1,4,null,null,3,6]ã€‚ æ ¹èŠ‚ç‚¹çš„å€¼ä¸º 5 ï¼Œä½†æ˜¯å…¶å³å­èŠ‚ç‚¹å€¼ä¸º 4 ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/validate-binary-search-treeè‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ SolutionäºŒå‰æœç´¢æ ‘çš„ä¸­åºåºåˆ—ä¸º æœ‰åºåºåˆ—ï¼Œå› æ­¤åªéœ€è¦è¿›è¡Œä¸­åºéå†å³å¯ Code123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ // ä¸­åºä¸ºæœ‰åºåºåˆ—class Solution {public: bool isValidBST(TreeNode* root) { TreeNode *p = root; stack&lt;TreeNode *&gt; s; TreeNode *prev = NULL, *next = NULL; while(p || !s.empty()){ while(p){ s.push(p); p = p -&gt; left; } p = s.top(); s.pop(); prev = next; next = p; if(prev &amp;&amp; next &amp;&amp; (prev-&gt;val &gt;= next-&gt;val)){ return false; } p = p-&gt;right; } return true; }};","link":"/2020/03/24/2020-03-24-98.-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"title":"99. æ¢å¤äºŒå‰æœç´¢æ ‘","text":"äºŒå‰æœç´¢æ ‘ä¸­çš„ä¸¤ä¸ªèŠ‚ç‚¹è¢«é”™è¯¯åœ°äº¤æ¢ã€‚ è¯·åœ¨ä¸æ”¹å˜å…¶ç»“æ„çš„æƒ…å†µä¸‹ï¼Œæ¢å¤è¿™æ£µæ ‘ã€‚ ç¤ºä¾‹ 1:123456789101112131415è¾“å…¥: [1,3,null,null,2] 1 / 3 \\ 2è¾“å‡º: [3,1,null,null,2] 3 / 1 \\ 2 ç¤ºä¾‹ 2:123456789101112131415è¾“å…¥: [3,1,4,null,null,2] 3 / \\1 4 / 2è¾“å‡º: [2,1,4,null,null,3] 2 / \\1 4 / 3 è¿›é˜¶:ä½¿ç”¨ O(n) ç©ºé—´å¤æ‚åº¦çš„è§£æ³•å¾ˆå®¹æ˜“å®ç°ã€‚ä½ èƒ½æƒ³å‡ºä¸€ä¸ªåªä½¿ç”¨å¸¸æ•°ç©ºé—´çš„è§£å†³æ–¹æ¡ˆå—ï¼Ÿ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/recover-binary-search-treeè‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ O(n) ç®—æ³•Solutionè·å–ä¸­åºéå†åºåˆ—ï¼Œç„¶åå†æ’åºï¼Œå†éå†ä¸€æ¬¡é‡æ–°å†™å…¥åˆ°åŸäºŒå‰æ ‘ä¸­ Code12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: void loop(TreeNode *root,vector&lt;int&gt; &amp;nums){ if(root){ loop(root-&gt;left,nums); nums.push_back(root-&gt;val); loop(root-&gt;right,nums); } } void recover(TreeNode *root,vector&lt;int&gt; &amp;nums){ stack&lt;TreeNode*&gt; s; int idx = 0; while(root ||!s.empty()){ while(root){ s.push(root); root = root-&gt;left; } root = s.top(); s.pop(); root-&gt;val = nums[idx++]; root = root-&gt;right; } } void recoverTree(TreeNode* root) { vector&lt;int&gt; nums; TreeNode *p = root,*head = root; loop(p,nums); sort(nums.begin(),nums.end()); recover(head,nums); }}; O(1) ç®—æ³•Solutionéå†çš„åŒæ—¶ï¼Œæ‰¾åˆ°è¿™ä¸¤ä¸ªé—®é¢˜èŠ‚ç‚¹ï¼Œå°†å…¶å€¼äº¤æ¢å³å¯ Code1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: void recoverTree(TreeNode* root) { TreeNode *p = root; stack&lt;TreeNode*&gt; s; TreeNode *first = NULL, *prev = NULL, *second = NULL; bool invalid = false; while(p ||!s.empty()){ while(p){ s.push(p); p = p-&gt;left; } p = s.top(); s.pop(); if(prev &amp;&amp; (prev-&gt;val &gt; p-&gt;val)){ if(first == NULL) first = prev; second = p; } prev = p; p = p-&gt;right; } int tmp = second-&gt;val; second-&gt;val = first-&gt;val; first-&gt;val = tmp; }};","link":"/2020/03/24/2020-03-24-99.-%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"title":"é¢è¯•é¢˜ 17.15. æœ€é•¿å•è¯","text":"ç»™å®šä¸€ç»„å•è¯wordsï¼Œç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œæ‰¾å‡ºå…¶ä¸­çš„æœ€é•¿å•è¯ï¼Œä¸”è¯¥å•è¯ç”±è¿™ç»„å•è¯ä¸­çš„å…¶ä»–å•è¯ç»„åˆè€Œæˆã€‚è‹¥æœ‰å¤šä¸ªé•¿åº¦ç›¸åŒçš„ç»“æœï¼Œè¿”å›å…¶ä¸­å­—å…¸åºæœ€å°çš„ä¸€é¡¹ï¼Œè‹¥æ²¡æœ‰ç¬¦åˆè¦æ±‚çš„å•è¯åˆ™è¿”å›ç©ºå­—ç¬¦ä¸²ã€‚ ç¤ºä¾‹ï¼š123è¾“å…¥ï¼š [&quot;cat&quot;,&quot;banana&quot;,&quot;dog&quot;,&quot;nana&quot;,&quot;walk&quot;,&quot;walker&quot;,&quot;dogwalker&quot;]è¾“å‡ºï¼š &quot;dogwalker&quot;è§£é‡Šï¼š &quot;dogwalker&quot;å¯ç”±&quot;dog&quot;å’Œ&quot;walker&quot;ç»„æˆã€‚ æç¤ºï¼š 120 &lt;= len(words) &lt;= 1001 &lt;= len(words[i]) &lt;= 100 æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/longest-word-lcci Solution hashmap ä¸ é€’å½’ å¯¹äºä¸€ä¸ªå­—ç¬¦ä¸² ï¼Œç”±äºä¸çŸ¥é“å®ƒç”±å‡ éƒ¨åˆ†ç»„æˆï¼Œå› æ­¤åªèƒ½æŒ‰ä½åˆ†å‰²ï¼Œé€æ®µåŒ¹é…ã€‚ä½¿ç”¨ hash çš„ä½œç”¨æ˜¯ä¸ºäº†åŠ å¿«åŒ¹é…é€Ÿåº¦ Code 1234567891011121314151617181920212223242526272829303132333435 class Solution {public: static bool cmp(string a,string b){ if(a.size()!=b.size()) return a.size() &gt; b.size(); else return a &lt; b; } bool isCombine(map&lt;string,int&gt; &amp;maps,string str,int less,bool origin){ if(str.size() &lt; less) return false; if(maps.count(str)&gt;0 &amp;&amp; !origin) return true; for(int i=less;i&lt;= str.size()-less;i++){ if(maps.count(str.substr(0,i)) &gt; 0 &amp;&amp; isCombine(maps,str.substr(i,str.size()-i),less,false)) return true; } return false; } string longestWord(vector&lt;string&gt;&amp; words) { if(words.size() &lt; 2) return &quot;&quot;; map&lt;string,int&gt; maps; int len = words.size(); for(int i=0;i&lt; len;i++ ) maps[words[i]] = 1; sort(words.begin(),words.end(),cmp); int less = words[len-1].size(); for(int i= 0;i&lt; len -1;i++){ string word = words[i]; if(word.size() &lt; less *2) return &quot;&quot;; if(isCombine(maps,word,less,true)){ return word; } } return &quot;&quot;; }};","link":"/2020/03/24/2020-03-24-%E9%9D%A2%E8%AF%95%E9%A2%98-17.15.-%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/"},{"title":"206. åè½¬é“¾è¡¨","text":"åè½¬ä¸€ä¸ªå•é“¾è¡¨ã€‚ ç¤ºä¾‹: 12è¾“å…¥: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLè¾“å‡º: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL SolutionåŒæŒ‡é’ˆ Code12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseList(ListNode* head) { ListNode *p1 = NULL, *p2 = head; ListNode *p; while(p2){ p = p2-&gt;next; p2-&gt;next = p1; p1 = p2; p2 = p; } return p1; }};","link":"/2020/03/25/2020-03-25-206.-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"title":"Weekly Contest 83","text":"830. è¾ƒå¤§åˆ†ç»„çš„ä½ç½®åœ¨ä¸€ä¸ªç”±å°å†™å­—æ¯æ„æˆçš„å­—ç¬¦ä¸² S ä¸­ï¼ŒåŒ…å«ç”±ä¸€äº›è¿ç»­çš„ç›¸åŒå­—ç¬¦æ‰€æ„æˆçš„åˆ†ç»„ã€‚ ä¾‹å¦‚ï¼Œåœ¨å­—ç¬¦ä¸² S = â€œabbxxxxzyyâ€ ä¸­ï¼Œå°±å«æœ‰ â€œaâ€, â€œbbâ€, â€œxxxxâ€, â€œzâ€ å’Œ â€œyyâ€ è¿™æ ·çš„ä¸€äº›åˆ†ç»„ã€‚ æˆ‘ä»¬ç§°æ‰€æœ‰åŒ…å«å¤§äºæˆ–ç­‰äºä¸‰ä¸ªè¿ç»­å­—ç¬¦çš„åˆ†ç»„ä¸ºè¾ƒå¤§åˆ†ç»„ã€‚æ‰¾åˆ°æ¯ä¸€ä¸ªè¾ƒå¤§åˆ†ç»„çš„èµ·å§‹å’Œç»ˆæ­¢ä½ç½®ã€‚ æœ€ç»ˆç»“æœæŒ‰ç…§å­—å…¸é¡ºåºè¾“å‡ºã€‚ ç¤ºä¾‹ 1: 123è¾“å…¥: &quot;abbxxxxzzy&quot;è¾“å‡º: [[3,6]]è§£é‡Š: &quot;xxxx&quot; æ˜¯ä¸€ä¸ªèµ·å§‹äº 3 ä¸”ç»ˆæ­¢äº 6 çš„è¾ƒå¤§åˆ†ç»„ã€‚ ç¤ºä¾‹ 2: 123è¾“å…¥: &quot;abc&quot;è¾“å‡º: []è§£é‡Š: &quot;a&quot;,&quot;b&quot; å’Œ &quot;c&quot; å‡ä¸æ˜¯ç¬¦åˆè¦æ±‚çš„è¾ƒå¤§åˆ†ç»„ã€‚ ç¤ºä¾‹ 3: 12è¾“å…¥: &quot;abcdddeeeeaabbbcd&quot;è¾“å‡º: [[3,5],[6,9],[12,14]] è¯´æ˜: 1 &lt;= S.length &lt;= 1000 Solution è¿™é“é¢˜æ¯”è¾ƒç®€å•ï¼Œåªéœ€è¦å‘åæ‰¾å³å¯,å½“å­—ç¬¦å˜åŒ–æ—¶ï¼Œåˆ¤æ–­å…¶é•¿åº¦æ˜¯å¦ç¬¦åˆè¦æ±‚ Code 1234567891011121314151617181920212223class Solution {public: vector&lt;vector&lt;int&gt;&gt; largeGroupPositions(string S) { vector&lt;vector&lt;int&gt;&gt; result; if(S.size()&lt;3) return result; int num = 1,prev = 0; for(int i=1;i&lt;S.size();i++){ if(S[prev] == S[i]){ num ++; } if(S[prev] != S[i] || i == S.size()-1){ if(num &gt;=3 ) { vector&lt;int&gt; re{prev,prev+num-1}; result.push_back(re); } prev = i; num = 1; } } return result; }}; 831. éšè—ä¸ªäººä¿¡æ¯ ç»™ä½ ä¸€æ¡ä¸ªäººä¿¡æ¯ string Sï¼Œå®ƒå¯èƒ½æ˜¯ä¸€ä¸ªé‚®ç®±åœ°å€ï¼Œä¹Ÿå¯èƒ½æ˜¯ä¸€ä¸ªç”µè¯å·ç ã€‚ æˆ‘ä»¬å°†éšè—å®ƒçš„éšç§ä¿¡æ¯ï¼Œé€šè¿‡å¦‚ä¸‹è§„åˆ™: 1. ç”µå­é‚®ç®± å®šä¹‰åç§° æ˜¯é•¿åº¦å¤§äºç­‰äº 2 ï¼ˆlength â‰¥ 2ï¼‰ï¼Œå¹¶ä¸”åªåŒ…å«å°å†™å­—æ¯ a-z å’Œå¤§å†™å­—æ¯ A-Z çš„å­—ç¬¦ä¸²ã€‚ ç”µå­é‚®ç®±åœ°å€ç”±åç§° å¼€å¤´ï¼Œç´§æ¥ç€æ˜¯ç¬¦å· â€˜@â€™ï¼Œåé¢æ¥ç€ä¸€ä¸ªåç§° ï¼Œå†æ¥ç€ä¸€ä¸ªç‚¹å· â€˜.â€™ï¼Œç„¶åæ˜¯ä¸€ä¸ªåç§° ã€‚ ç”µå­é‚®ç®±åœ°å€ç¡®å®šä¸ºæœ‰æ•ˆçš„ï¼Œå¹¶ä¸”æ ¼å¼æ˜¯ â€œname1@name2.name3â€œã€‚ ä¸ºäº†éšè—ç”µå­é‚®ç®±ï¼Œæ‰€æœ‰çš„åç§° å¿…é¡»è¢«è½¬æ¢æˆå°å†™çš„ï¼Œå¹¶ä¸”ç¬¬ä¸€ä¸ªåç§° çš„ç¬¬ä¸€ä¸ªå­—æ¯å’Œæœ€åä¸€ä¸ªå­—æ¯çš„ä¸­é—´çš„æ‰€æœ‰å­—æ¯ç”± 5 ä¸ª â€˜*â€™ ä»£æ›¿ã€‚ 2. ç”µè¯å·ç  ç”µè¯å·ç æ˜¯ä¸€ä¸²åŒ…æ‹¬æ•°å­— 0-9ï¼Œä»¥åŠ {â€˜+â€™, â€˜-â€˜, â€˜(â€˜, â€˜)â€™, â€˜ â€˜} è¿™å‡ ä¸ªå­—ç¬¦çš„å­—ç¬¦ä¸²ã€‚ä½ å¯ä»¥å‡è®¾ç”µè¯å·ç åŒ…å« 10 åˆ° 13 ä¸ªæ•°å­—ã€‚ ç”µè¯å·ç çš„æœ€å 10 ä¸ªæ•°å­—ç»„æˆæœ¬åœ°å·ç ï¼Œåœ¨è¿™ä¹‹å‰çš„æ•°å­—ç»„æˆå›½é™…å·ç ã€‚æ³¨æ„ï¼Œå›½é™…å·ç æ˜¯å¯é€‰çš„ã€‚æˆ‘ä»¬åªæš´éœ²æœ€å 4 ä¸ªæ•°å­—å¹¶éšè—æ‰€æœ‰å…¶ä»–æ•°å­—ã€‚ æœ¬åœ°å·ç æ˜¯æœ‰æ ¼å¼çš„ï¼Œå¹¶ä¸”å¦‚ â€œ--1111â€ è¿™æ ·æ˜¾ç¤ºï¼Œè¿™é‡Œçš„ 1 è¡¨ç¤ºæš´éœ²çš„æ•°å­—ã€‚ ä¸ºäº†éšè—æœ‰å›½é™…å·ç çš„ç”µè¯å·ç ï¼Œåƒ â€œ+111 111 111 1111â€ï¼Œæˆ‘ä»¬ä»¥ â€œ+--***-1111â€ çš„æ ¼å¼æ¥æ˜¾ç¤ºã€‚åœ¨æœ¬åœ°å·ç å‰é¢çš„ â€˜+â€™ å·å’Œç¬¬ä¸€ä¸ª â€˜-â€˜ å·ä»…å½“ç”µè¯å·ç ä¸­åŒ…å«å›½é™…å·ç æ—¶å­˜åœ¨ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ª 12 ä½çš„ç”µè¯å·ç åº”å½“ä»¥ â€œ+**-â€œ å¼€å¤´è¿›è¡Œæ˜¾ç¤ºã€‚ æ³¨æ„ï¼šåƒ â€œ(â€œï¼Œâ€)â€ï¼Œâ€ â€œ è¿™æ ·çš„ä¸ç›¸å¹²çš„å­—ç¬¦ä»¥åŠä¸ç¬¦åˆä¸Šè¿°æ ¼å¼çš„é¢å¤–çš„å‡å·æˆ–è€…åŠ å·éƒ½åº”å½“è¢«åˆ é™¤ã€‚ æœ€åï¼Œå°†æä¾›çš„ä¿¡æ¯æ­£ç¡®éšè—åè¿”å›ã€‚ ç¤ºä¾‹ 1ï¼š12345è¾“å…¥: &quot;LeetCode@LeetCode.com&quot;è¾“å‡º: &quot;l*****e@leetcode.com&quot;è§£é‡Šï¼š æ‰€æœ‰çš„åç§°è½¬æ¢æˆå°å†™, ç¬¬ä¸€ä¸ªåç§°çš„ç¬¬ä¸€ä¸ªå­—ç¬¦å’Œæœ€åä¸€ä¸ªå­—ç¬¦ä¸­é—´ç”± 5 ä¸ªæ˜Ÿå·ä»£æ›¿ã€‚å› æ­¤ï¼Œ&quot;leetcode&quot; -&gt; &quot;l*****e&quot;ã€‚ ç¤ºä¾‹ 2ï¼š12345è¾“å…¥: &quot;AB@qq.com&quot;è¾“å‡º: &quot;a*****b@qq.com&quot;è§£é‡Š: ç¬¬ä¸€ä¸ªåç§°&quot;ab&quot;çš„ç¬¬ä¸€ä¸ªå­—ç¬¦å’Œæœ€åä¸€ä¸ªå­—ç¬¦çš„ä¸­é—´å¿…é¡»æœ‰ 5 ä¸ªæ˜Ÿå·å› æ­¤ï¼Œ&quot;ab&quot; -&gt; &quot;a*****b&quot;ã€‚ ç¤ºä¾‹ 3ï¼š1234è¾“å…¥: &quot;1(234)567-890&quot;è¾“å‡º: &quot;***-***-7890&quot;è§£é‡Š: 10 ä¸ªæ•°å­—çš„ç”µè¯å·ç ï¼Œé‚£æ„å‘³ç€æ‰€æœ‰çš„æ•°å­—éƒ½æ˜¯æœ¬åœ°å·ç ã€‚ ç¤ºä¾‹ 4ï¼š1234è¾“å…¥: &quot;86-(10)12345678&quot;è¾“å‡º: &quot;+**-***-***-5678&quot;è§£é‡Š: 12 ä½æ•°å­—ï¼Œ2 ä¸ªæ•°å­—æ˜¯å›½é™…å·ç å¦å¤– 10 ä¸ªæ•°å­—æ˜¯æœ¬åœ°å·ç  ã€‚ æ³¨æ„: S.length &lt;= 40ã€‚ é‚®ç®±çš„é•¿åº¦è‡³å°‘æ˜¯ 8ã€‚ ç”µè¯å·ç çš„é•¿åº¦è‡³å°‘æ˜¯ 10ã€‚ Solutionæ ¹æ®è§„åˆ™ä¹Ÿå³å¯ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution {public: char upToLow(char c){ if(c&gt;='A' &amp;&amp; c &lt;= 'Z') return (char)(c^0x20); else return c; } string hiddenEmail(string s){ string res; bool has = false; for(int i =0;i&lt;s.size();i++){ if(s[i] == '@'){ res = (char)upToLow(s[0]); res += &quot;*****&quot;; res = res + (char)upToLow(s[i-1]); res += &quot;@&quot;; has = true; } else if(has){ res = res + upToLow(s[i]) ; } } return res; } string hiddenPhone(string s){ int num = 0; string res; for(int i=s.size()-1;i&gt;=0;i--){ if(s[i] &gt;='0' &amp;&amp; s[i]&lt;='9'){ num ++; if(num &lt;= 4 ) res = s[i]+res; } } int k = (num-4)/3; int t = num - 3*k -4; for(int i=0;i&lt;k;i++){ res = &quot;***-&quot;+res; } if(t == 0 &amp;&amp; num &gt; 10) { res = &quot;+&quot;+res; }else if(t == 1) res = &quot;+*-&quot;+res; else if(t==2) res = &quot;+**-&quot;+res; return res; } string maskPII(string S) { if((S[0] &gt;='A' &amp;&amp; S[0] &lt;='Z') || (S[0]&gt;='a' &amp;&amp; S[0]&lt;='z')) return hiddenEmail(S); else return hiddenPhone(S); }}; 829. è¿ç»­æ•´æ•°æ±‚å’Œç»™å®šä¸€ä¸ªæ­£æ•´æ•° Nï¼Œè¯•æ±‚æœ‰å¤šå°‘ç»„è¿ç»­æ­£æ•´æ•°æ»¡è¶³æ‰€æœ‰æ•°å­—ä¹‹å’Œä¸º N? ç¤ºä¾‹ 1: 123è¾“å…¥: 5è¾“å‡º: 2è§£é‡Š: 5 = 5 = 2 + 3ï¼Œå…±æœ‰ä¸¤ç»„è¿ç»­æ•´æ•°([5],[2,3])æ±‚å’Œåä¸º 5ã€‚ ç¤ºä¾‹ 2: 123è¾“å…¥: 9è¾“å‡º: 3è§£é‡Š: 9 = 9 = 4 + 5 = 2 + 3 + 4 ç¤ºä¾‹ 3: 123è¾“å…¥: 15è¾“å‡º: 4è§£é‡Š: 15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5 è¯´æ˜: 1 &lt;= N &lt;= 10 ^ 9 Solutionè¿™æ˜¯ä¸€é“æ•°å­¦é¢˜ç›®ï¼Œæ²¡å•¥æŠ€å·§çš„ é¦–å…ˆï¼Œè¿ç»­æ•°å­—å¯ä»¥ç”± 2ï¼Œ3ï¼Œ4ï¼Œ5â€¦ k ä¸ªè¿ç»­æ•°å­—ç»„æˆï¼Œä½†æ˜¯ k æœ‰è¦æ±‚ ä¾‹å¦‚å¯¹äº è¾“å…¥ 15 ï¼Œ k å¿…é¡»è¦$$ (15/k - (k-1)/2) â€¦ 15/k-1 ã€ 15/kã€ 15/k +1 â€¦ å³ (15/k - (k-1)/2) &gt;=1 $$ å› æ­¤å¯¹äºä»»æ„çš„æ•´æ•° nï¼Œåˆ™æœ‰ $kk+k&lt;= 2n$ è€Œå¯¹äºæ»¡è¶³è¦æ±‚çš„ k å€¼ï¼Œ å½“ $n/k == 0 &amp;&amp; k %2 !=0$ æ—¶ï¼Œè‚¯å®šæ»¡è¶³æ¡ä»¶ å½“ $n/k!=0$æ—¶ï¼Œè®¡ç®— sum å€¼å³å¯ Code12345678910111213141516171819class Solution {public: int consecutiveNumbersSum(int N) { int i=2,num = 1; int sum = 0,a; while(i*i + i &lt;= 2*N){ if(N%i == 0 &amp;&amp; i%2 != 0) num ++; else if(N%i != 0){ a = N/i; sum = i * (a - (i-1)/2) + (i-1)*i/2; if(sum == N) num++; } i++; } return num; }}; 828. ç»Ÿè®¡å­ä¸²ä¸­çš„å”¯ä¸€å­—ç¬¦æˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªå‡½æ•° countUniqueChars(s) æ¥ç»Ÿè®¡å­—ç¬¦ä¸² s ä¸­çš„å”¯ä¸€å­—ç¬¦ï¼Œå¹¶è¿”å›å”¯ä¸€å­—ç¬¦çš„ä¸ªæ•°ã€‚ ä¾‹å¦‚ï¼šs = â€œLEETCODEâ€ ï¼Œåˆ™å…¶ä¸­ â€œLâ€, â€œTâ€,â€Câ€,â€Oâ€,â€Dâ€ éƒ½æ˜¯å”¯ä¸€å­—ç¬¦ï¼Œå› ä¸ºå®ƒä»¬åªå‡ºç°ä¸€æ¬¡ï¼Œæ‰€ä»¥ countUniqueChars(s) = 5 ã€‚ æœ¬é¢˜å°†ä¼šç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² s ï¼Œæˆ‘ä»¬éœ€è¦è¿”å› countUniqueChars(t) çš„æ€»å’Œï¼Œå…¶ä¸­ t æ˜¯ s çš„å­å­—ç¬¦ä¸²ã€‚æ³¨æ„ï¼ŒæŸäº›å­å­—ç¬¦ä¸²å¯èƒ½æ˜¯é‡å¤çš„ï¼Œä½†ä½ ç»Ÿè®¡æ—¶ä¹Ÿå¿…é¡»ç®—ä¸Šè¿™äº›é‡å¤çš„å­å­—ç¬¦ä¸²ï¼ˆä¹Ÿå°±æ˜¯è¯´ï¼Œä½ å¿…é¡»ç»Ÿè®¡ s çš„æ‰€æœ‰å­å­—ç¬¦ä¸²ä¸­çš„å”¯ä¸€å­—ç¬¦ï¼‰ã€‚ ç”±äºç­”æ¡ˆå¯èƒ½éå¸¸å¤§ï¼Œè¯·å°†ç»“æœ mod 10 ^ 9 + 7 åå†è¿”å›ã€‚ ç¤ºä¾‹ 1ï¼š 12345è¾“å…¥: &quot;ABC&quot;è¾“å‡º: 10è§£é‡Š: æ‰€æœ‰å¯èƒ½çš„å­ä¸²ä¸ºï¼š&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;AB&quot;,&quot;BC&quot; å’Œ &quot;ABC&quot;ã€‚ å…¶ä¸­ï¼Œæ¯ä¸€ä¸ªå­ä¸²éƒ½ç”±ç‹¬ç‰¹å­—ç¬¦æ„æˆã€‚ æ‰€ä»¥å…¶é•¿åº¦æ€»å’Œä¸ºï¼š1 + 1 + 1 + 2 + 2 + 3 = 10 ç¤ºä¾‹ 2ï¼š 123è¾“å…¥: &quot;ABA&quot;è¾“å‡º: 8è§£é‡Š: é™¤äº† countUniqueChars(&quot;ABA&quot;) = 1 ä¹‹å¤–ï¼Œå…¶ä½™ä¸ç¤ºä¾‹ 1 ç›¸åŒã€‚ ç¤ºä¾‹ 3ï¼š 12è¾“å…¥ï¼šs = &quot;LEETCODE&quot;è¾“å‡ºï¼š92 æç¤ºï¼š 0 &lt;= s.length &lt;= 10^4 s åªåŒ…å«å¤§å†™è‹±æ–‡å­—ç¬¦ Solution æš´åŠ›(ç”¨äº† hash å’Œ dp ä¼˜åŒ–),ç©·ä¸¾æ‰€æœ‰çš„å­—ä¸²ï¼Œç„¶å å°± GGäº† 123456789101112131415161718192021class Solution {public: int uniqueLetterString(string s) { int num = 0; for(int i=0;i&lt;s.size();i++){ int prev = 0,cur = 0, maps[26] = {0}; for(int j=i;j&lt;s.size();j++){ maps[s[j]-'A']++; if(maps[s[j]-'A'] == 1) cur++; else if(maps[s[j]-'A'] == 2) cur = prev-1; else cur = prev; num += cur; prev = cur; } } return num % 1000000007; }}; å†æ·±å…¥ç ”ç©¶ä¸€ä¸‹ä¸¤ä¸ªä»¥ä¸Šçš„é‡å¤å­—ç¬¦å°±æ²¡æœ‰ä½œç”¨äº†ï¼Œè¿™æ˜¯ä¸€ä¸ªå…³é”®ç‚¹ 12345678910111213141516171819class Solution {public: int uniqueLetterString(string s) { map&lt;int,vector&lt;int&gt;&gt; maps; for(int i =0;i&lt;s.size();i++){ maps[s[i]-'A'].push_back(i); } int ans = 0,prev,next; for(auto &amp;p:maps){ for(int j=0;j&lt;p.second.size();j++){ prev = j==0?-1:p.second[j-1]; next = j== p.second.size()-1?s.size():p.second[j+1]; ans += (p.second[j]-prev)*(next - p.second[j]); } } return ans%1000000007; }}; æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰è‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚","link":"/2020/03/25/2020-03-25-Weekly-Contest-83/"},{"title":"820. å•è¯çš„å‹ç¼©ç¼–ç ","text":"ç»™å®šä¸€ä¸ªå•è¯åˆ—è¡¨ï¼Œæˆ‘ä»¬å°†è¿™ä¸ªåˆ—è¡¨ç¼–ç æˆä¸€ä¸ªç´¢å¼•å­—ç¬¦ä¸² S ä¸ä¸€ä¸ªç´¢å¼•åˆ—è¡¨ Aã€‚ ä¾‹å¦‚ï¼Œå¦‚æœè¿™ä¸ªåˆ—è¡¨æ˜¯ [â€œtimeâ€, â€œmeâ€, â€œbellâ€]ï¼Œæˆ‘ä»¬å°±å¯ä»¥å°†å…¶è¡¨ç¤ºä¸º S = â€œtime#bell#â€ å’Œ indexes = [0, 2, 5]ã€‚ å¯¹äºæ¯ä¸€ä¸ªç´¢å¼•ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä»å­—ç¬¦ä¸² S ä¸­ç´¢å¼•çš„ä½ç½®å¼€å§‹è¯»å–å­—ç¬¦ä¸²ï¼Œç›´åˆ° â€œ#â€ ç»“æŸï¼Œæ¥æ¢å¤æˆ‘ä»¬ä¹‹å‰çš„å•è¯åˆ—è¡¨ã€‚ é‚£ä¹ˆæˆåŠŸå¯¹ç»™å®šå•è¯åˆ—è¡¨è¿›è¡Œç¼–ç çš„æœ€å°å­—ç¬¦ä¸²é•¿åº¦æ˜¯å¤šå°‘å‘¢ï¼Ÿ ç¤ºä¾‹ï¼š123è¾“å…¥: words = [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]è¾“å‡º: 10è¯´æ˜: S = &quot;time#bell#&quot; ï¼Œ indexes = [0, 2, 5] ã€‚ æç¤ºï¼š 1 &lt;= words.length &lt;= 2000 1 &lt;= words[i].length &lt;= 7 æ¯ä¸ªå•è¯éƒ½æ˜¯å°å†™å­—æ¯ ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/short-encoding-of-wordsè‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ Solutioné‡‡ç”¨å­—å…¸æ ‘ï¼Œå­—ç¬¦ä¸²åå‘å­˜å‚¨ 12345678910 root / \\ e L | |m L | | i e | | t b Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Node{ public: char c; map&lt;char,Node&gt; next; int index; bool leaf; Node(char c){this-&gt;c = c;}; Node(){};};class Solution {public: // æ’å…¥ void insert(Node *root,string word){ int len = word.size(); Node *p = root; int index = 0; for(int i = len-1;i&gt;=0;i--){ if(p-&gt;next.count(word[i]) == 0){ Node node = Node(word[i]); node.index = len - i; p-&gt;next[word[i]] = node; } p-&gt;leaf = false; p = &amp;(p-&gt;next[word[i]]); } if(p-&gt;next.size() == 0 ) p-&gt;leaf = true; } // å±‚åºéå† int getSum(Node *root){ int sum = 0; queue&lt;Node *&gt; q; q.push(root); while(!q.empty()){ Node *node = q.front(); if(node-&gt;leaf){ sum += (node-&gt;index+1); } q.pop(); for(auto &amp;it:node-&gt;next){ q.push(&amp;(it.second)); } } return sum; } int minimumLengthEncoding(vector&lt;string&gt;&amp; words) { if(words.size()==1) return words[0].size()+1; Node *root = new Node(); int res = 0; for(int i=0;i&lt;words.size();i++){ insert(root,words[i]); } return getSum(root); }};","link":"/2020/03/28/2020-03-28-820.-%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/"},{"title":"1162. åœ°å›¾åˆ†æ","text":"ä½ ç°åœ¨æ‰‹é‡Œæœ‰ä¸€ä»½å¤§å°ä¸º N x N çš„ã€åœ°å›¾ã€ï¼ˆç½‘æ ¼ï¼‰ gridï¼Œä¸Šé¢çš„æ¯ä¸ªã€åŒºåŸŸã€ï¼ˆå•å…ƒæ ¼ï¼‰éƒ½ç”¨ 0 å’Œ 1 æ ‡è®°å¥½äº†ã€‚å…¶ä¸­ 0 ä»£è¡¨æµ·æ´‹ï¼Œ1 ä»£è¡¨é™†åœ°ï¼Œä½ çŸ¥é“è·ç¦»é™†åœ°åŒºåŸŸæœ€è¿œçš„æµ·æ´‹åŒºåŸŸæ˜¯æ˜¯å“ªä¸€ä¸ªå—ï¼Ÿè¯·è¿”å›è¯¥æµ·æ´‹åŒºåŸŸåˆ°ç¦»å®ƒæœ€è¿‘çš„é™†åœ°åŒºåŸŸçš„è·ç¦»ã€‚ æˆ‘ä»¬è¿™é‡Œè¯´çš„è·ç¦»æ˜¯ã€æ›¼å“ˆé¡¿è·ç¦»ã€ï¼ˆ Manhattan Distanceï¼‰ï¼š(x0, y0) å’Œ (x1, y1) è¿™ä¸¤ä¸ªåŒºåŸŸä¹‹é—´çš„è·ç¦»æ˜¯ |x0 - x1| + |y0 - y1| ã€‚ å¦‚æœæˆ‘ä»¬çš„åœ°å›¾ä¸Šåªæœ‰é™†åœ°æˆ–è€…æµ·æ´‹ï¼Œè¯·è¿”å› -1ã€‚ ç¤ºä¾‹ 1ï¼š 1234è¾“å…¥ï¼š[[1,0,1],[0,0,0],[1,0,1]]è¾“å‡ºï¼š2è§£é‡Šï¼š æµ·æ´‹åŒºåŸŸ (1, 1) å’Œæ‰€æœ‰é™†åœ°åŒºåŸŸä¹‹é—´çš„è·ç¦»éƒ½è¾¾åˆ°æœ€å¤§ï¼Œæœ€å¤§è·ç¦»ä¸º 2ã€‚ ç¤ºä¾‹ 2ï¼š 1234è¾“å…¥ï¼š[[1,0,0],[0,0,0],[0,0,0]]è¾“å‡ºï¼š4è§£é‡Šï¼š æµ·æ´‹åŒºåŸŸ (2, 2) å’Œæ‰€æœ‰é™†åœ°åŒºåŸŸä¹‹é—´çš„è·ç¦»éƒ½è¾¾åˆ°æœ€å¤§ï¼Œæœ€å¤§è·ç¦»ä¸º 4ã€‚ æç¤ºï¼š 1 &lt;= grid.length == grid[0].length &lt;= 100 grid[i][j] ä¸æ˜¯ 0 å°±æ˜¯ 1 æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/as-far-from-land-as-possibleè‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ Solutionå¤šæº BFS ,ä»é™†åœ°å‡ºå‘ï¼Œè¿›è¡Œ bfs éå†ï¼Œè®°å½•å…¶å±‚æ•°å³å¯ Code123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: int maxDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m = grid.size(), n = grid[0].size(); queue&lt;vector&lt;int&gt;&gt; q; int visited[100][100] = {0}; int num = 0; // æ‰¾åˆ°æ‰€æœ‰çš„ é™†åœ° for(int i=0;i&lt;m;i++){ for(int j=0;j&lt;n;j++){ if(grid[i][j]){num++;q.push({i,j});visited[i][j] = 1;} } } if(num ==0 || num == m*n) return -1; vector&lt;int&gt; dot; int x,y, dx[4] = {1,-1,0,0},dy[4] = {0,0,1,-1}; int res = -1,size,i,j; while(!q.empty()){ size = q.size(); for(i=0;i&lt;size;i++){ dot = q.front(); q.pop(); for(j=0;j&lt;4;j++){ x = dx[j] + dot[0]; y = dy[j] + dot[1]; // æ‰¾åˆ°å°šæœªè®¿é—®è¿‡çš„æµ·æ´‹èŠ‚ç‚¹ if(x &gt;=0 &amp;&amp; x&lt; m &amp;&amp; y&gt;=0 &amp;&amp; y&lt; n &amp;&amp; !visited[x][y]){ q.push({x,y}); visited[x][y] = 1; } } } // è·ç¦» + 1 res ++; } return res; }};","link":"/2020/03/29/2020-03-29-1162.-%E5%9C%B0%E5%9B%BE%E5%88%86%E6%9E%90/"},{"title":"1306. è·³è·ƒæ¸¸æˆ III","text":"è¿™é‡Œæœ‰ä¸€ä¸ªéè´Ÿæ•´æ•°æ•°ç»„ arrï¼Œä½ æœ€å¼€å§‹ä½äºè¯¥æ•°ç»„çš„èµ·å§‹ä¸‹æ ‡ start å¤„ã€‚å½“ä½ ä½äºä¸‹æ ‡ i å¤„æ—¶ï¼Œä½ å¯ä»¥è·³åˆ° i + arr[i] æˆ–è€… i - arr[i]ã€‚ è¯·ä½ åˆ¤æ–­è‡ªå·±æ˜¯å¦èƒ½å¤Ÿè·³åˆ°å¯¹åº”å…ƒç´ å€¼ä¸º 0 çš„ ä»»æ„ ä¸‹æ ‡å¤„ã€‚ æ³¨æ„ï¼Œä¸ç®¡æ˜¯ä»€ä¹ˆæƒ…å†µä¸‹ï¼Œä½ éƒ½æ— æ³•è·³åˆ°æ•°ç»„ä¹‹å¤–ã€‚ ç¤ºä¾‹ 1ï¼š123456è¾“å…¥ï¼šarr = [4,2,3,0,3,1,2], start = 5è¾“å‡ºï¼štrueè§£é‡Šï¼šåˆ°è¾¾å€¼ä¸º 0 çš„ä¸‹æ ‡ 3 æœ‰ä»¥ä¸‹å¯èƒ½æ–¹æ¡ˆï¼š ä¸‹æ ‡ 5 -&gt; ä¸‹æ ‡ 4 -&gt; ä¸‹æ ‡ 1 -&gt; ä¸‹æ ‡ 3 ä¸‹æ ‡ 5 -&gt; ä¸‹æ ‡ 6 -&gt; ä¸‹æ ‡ 4 -&gt; ä¸‹æ ‡ 1 -&gt; ä¸‹æ ‡ 3 ç¤ºä¾‹ 2ï¼š12345è¾“å…¥ï¼šarr = [4,2,3,0,3,1,2], start = 0è¾“å‡ºï¼štrue è§£é‡Šï¼šåˆ°è¾¾å€¼ä¸º 0 çš„ä¸‹æ ‡ 3 æœ‰ä»¥ä¸‹å¯èƒ½æ–¹æ¡ˆï¼š ä¸‹æ ‡ 0 -&gt; ä¸‹æ ‡ 4 -&gt; ä¸‹æ ‡ 1 -&gt; ä¸‹æ ‡ 3 ç¤ºä¾‹ 3ï¼š123è¾“å…¥ï¼šarr = [3,0,2,1,2], start = 2è¾“å‡ºï¼šfalseè§£é‡Šï¼šæ— æ³•åˆ°è¾¾å€¼ä¸º 0 çš„ä¸‹æ ‡ 1 å¤„ã€‚ æç¤ºï¼š 1 &lt;= arr.length &lt;= 5 * 10^4 0 &lt;= arr[i] &lt; arr.length 0 &lt;= start &lt; arr.length æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/jump-game-iiiè‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ SolutionBFS Code123456789101112131415161718192021222324252627282930class Solution {public: bool canReach(vector&lt;int&gt;&amp; arr, int start) { int n = arr.size(), visited[n]; fill(visited,visited+n,0); queue&lt;int&gt; q; q.push(start); visited[start] = 1; int t,left,right; while(!q.empty()){ t = q.front(); q.pop(); if(arr[t] == 0) return true; left = t+arr[t]; right = t-arr[t]; if(left &gt;=0 &amp;&amp; left &lt; n &amp;&amp; !visited[left]){ q.push(left); visited[left] = 1; } if(right &gt;=0 &amp;&amp; right &lt; n &amp;&amp; !visited[right]){ q.push(right); visited[right] = 1; } } return false; }};","link":"/2020/04/04/2020-04-04-1306.-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-III/"},{"title":"1334. é˜ˆå€¼è·ç¦»å†…é‚»å±…æœ€å°‘çš„åŸå¸‚","text":"æœ‰ n ä¸ªåŸå¸‚ï¼ŒæŒ‰ä» 0 åˆ° n-1 ç¼–å·ã€‚ç»™ä½ ä¸€ä¸ªè¾¹æ•°ç»„ edgesï¼Œå…¶ä¸­ edges[i] = [fromi, toi, weighti] ä»£è¡¨ fromi å’Œ toi ä¸¤ä¸ªåŸå¸‚ä¹‹é—´çš„åŒå‘åŠ æƒè¾¹ï¼Œè·ç¦»é˜ˆå€¼æ˜¯ä¸€ä¸ªæ•´æ•° distanceThresholdã€‚ è¿”å›èƒ½é€šè¿‡æŸäº›è·¯å¾„åˆ°è¾¾å…¶ä»–åŸå¸‚æ•°ç›®æœ€å°‘ã€ä¸”è·¯å¾„è·ç¦» æœ€å¤§ ä¸º distanceThreshold çš„åŸå¸‚ã€‚å¦‚æœæœ‰å¤šä¸ªè¿™æ ·çš„åŸå¸‚ï¼Œåˆ™è¿”å›ç¼–å·æœ€å¤§çš„åŸå¸‚ã€‚ æ³¨æ„ï¼Œè¿æ¥åŸå¸‚ i å’Œ j çš„è·¯å¾„çš„è·ç¦»ç­‰äºæ²¿è¯¥è·¯å¾„çš„æ‰€æœ‰è¾¹çš„æƒé‡ä¹‹å’Œã€‚ ç¤ºä¾‹ 1ï¼š123456789è¾“å…¥ï¼šn = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4è¾“å‡ºï¼š3è§£é‡Šï¼šåŸå¸‚åˆ†å¸ƒå›¾å¦‚ä¸Šã€‚æ¯ä¸ªåŸå¸‚é˜ˆå€¼è·ç¦» distanceThreshold = 4 å†…çš„é‚»å±…åŸå¸‚åˆ†åˆ«æ˜¯ï¼šåŸå¸‚ 0 -&gt; [åŸå¸‚ 1, åŸå¸‚ 2] åŸå¸‚ 1 -&gt; [åŸå¸‚ 0, åŸå¸‚ 2, åŸå¸‚ 3] åŸå¸‚ 2 -&gt; [åŸå¸‚ 0, åŸå¸‚ 1, åŸå¸‚ 3] åŸå¸‚ 3 -&gt; [åŸå¸‚ 1, åŸå¸‚ 2] åŸå¸‚ 0 å’Œ 3 åœ¨é˜ˆå€¼è·ç¦» 4 ä»¥å†…éƒ½æœ‰ 2 ä¸ªé‚»å±…åŸå¸‚ï¼Œä½†æ˜¯æˆ‘ä»¬å¿…é¡»è¿”å›åŸå¸‚ 3ï¼Œå› ä¸ºå®ƒçš„ç¼–å·æœ€å¤§ã€‚ ç¤ºä¾‹ 2ï¼š12345678910è¾“å…¥ï¼šn = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2è¾“å‡ºï¼š0è§£é‡Šï¼šåŸå¸‚åˆ†å¸ƒå›¾å¦‚ä¸Šã€‚ æ¯ä¸ªåŸå¸‚é˜ˆå€¼è·ç¦» distanceThreshold = 2 å†…çš„é‚»å±…åŸå¸‚åˆ†åˆ«æ˜¯ï¼šåŸå¸‚ 0 -&gt; [åŸå¸‚ 1] åŸå¸‚ 1 -&gt; [åŸå¸‚ 0, åŸå¸‚ 4] åŸå¸‚ 2 -&gt; [åŸå¸‚ 3, åŸå¸‚ 4] åŸå¸‚ 3 -&gt; [åŸå¸‚ 2, åŸå¸‚ 4]åŸå¸‚ 4 -&gt; [åŸå¸‚ 1, åŸå¸‚ 2, åŸå¸‚ 3] åŸå¸‚ 0 åœ¨é˜ˆå€¼è·ç¦» 4 ä»¥å†…åªæœ‰ 1 ä¸ªé‚»å±…åŸå¸‚ã€‚ æç¤ºï¼š 2 &lt;= n &lt;= 100 1 &lt;= edges.length &lt;= n * (n - 1) / 2 edges[i].length == 3 0 &lt;= fromi &lt; toi &lt; n 1 &lt;= weighti, distanceThreshold &lt;= 10^4 æ‰€æœ‰ (fromi, toi) éƒ½æ˜¯ä¸åŒçš„ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distanceè‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ SolutionDijkstra ç®—æ³•ï¼Œå¤šæ¬¡ä½¿ç”¨ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution {public: int findTheCity(int n, vector&lt;vector&lt;int&gt; &gt;&amp; edges, int distanceThreshold) { int res = -1, city = 0; int curCity = 0; int visited[n],t,w,cur,num,p,min_id; // fill(v[0],v[0]+n*n,0); vector&lt;vector&lt;int&gt; &gt; v(n,vector&lt;int&gt;(n,0)); for(int i=0;i&lt;edges.size();i++){ v[edges[i][0]][edges[i][1]] = edges[i][2]; v[edges[i][1]][edges[i][0]] = edges[i][2]; } // dijkstra for(int i=0;i&lt;n;i++){ curCity = 0; vector&lt;int&gt; dis(n,0x7fffffff); fill(visited,visited+n,0); cur = i; visited[cur] = 1; dis[cur] = 0; num = 0; while(num &lt; n){ p = 0x7fffffff; min_id = -1; for(int j=0;j&lt;n;j++){ if(!visited[j] &amp;&amp; v[cur][j] &gt; 0){ w = dis[cur] + v[cur][j]; dis[j] = min(w,dis[j]); // if(dis[j] &lt; distanceThreshold) // curCity ++; } if(!visited[j] &amp;&amp; dis[j] &lt; p){ p = dis[j]; min_id = j; } } if(min_id != -1){ num ++; cur = min_id; visited[cur] = 1; }else break; } for(int j=0;j&lt;n;j++){ if(j!=i &amp;&amp; dis[j] &lt;= distanceThreshold) curCity++; } if(res == -1 || curCity &lt;= city) {city= curCity, res = i;} } return res; }};","link":"/2020/04/04/2020-04-04-1334.-%E9%98%88%E5%80%BC%E8%B7%9D%E7%A6%BB%E5%86%85%E9%82%BB%E5%B1%85%E6%9C%80%E5%B0%91%E7%9A%84%E5%9F%8E%E5%B8%82/"},{"title":"207. è¯¾ç¨‹è¡¨","text":"ä½ è¿™ä¸ªå­¦æœŸå¿…é¡»é€‰ä¿® numCourse é—¨è¯¾ç¨‹ï¼Œè®°ä¸º 0 åˆ° numCourse-1 ã€‚ åœ¨é€‰ä¿®æŸäº›è¯¾ç¨‹ä¹‹å‰éœ€è¦ä¸€äº›å…ˆä¿®è¯¾ç¨‹ã€‚ ä¾‹å¦‚ï¼Œæƒ³è¦å­¦ä¹ è¯¾ç¨‹ 0 ï¼Œä½ éœ€è¦å…ˆå®Œæˆè¯¾ç¨‹ 1 ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªåŒ¹é…æ¥è¡¨ç¤ºä»–ä»¬ï¼š[0,1] ç»™å®šè¯¾ç¨‹æ€»é‡ä»¥åŠå®ƒä»¬çš„å…ˆå†³æ¡ä»¶ï¼Œè¯·ä½ åˆ¤æ–­æ˜¯å¦å¯èƒ½å®Œæˆæ‰€æœ‰è¯¾ç¨‹çš„å­¦ä¹ ï¼Ÿ ç¤ºä¾‹ 1:123è¾“å…¥: 2, [[1,0]] è¾“å‡º: trueè§£é‡Š: æ€»å…±æœ‰ 2 é—¨è¯¾ç¨‹ã€‚å­¦ä¹ è¯¾ç¨‹ 1 ä¹‹å‰ï¼Œä½ éœ€è¦å®Œæˆè¯¾ç¨‹ 0ã€‚æ‰€ä»¥è¿™æ˜¯å¯èƒ½çš„ã€‚ ç¤ºä¾‹ 2:123è¾“å…¥: 2, [[1,0],[0,1]]è¾“å‡º: falseè§£é‡Š: æ€»å…±æœ‰ 2 é—¨è¯¾ç¨‹ã€‚å­¦ä¹ è¯¾ç¨‹ 1 ä¹‹å‰ï¼Œä½ éœ€è¦å…ˆå®Œæˆâ€‹è¯¾ç¨‹ 0ï¼›å¹¶ä¸”å­¦ä¹ è¯¾ç¨‹ 0 ä¹‹å‰ï¼Œä½ è¿˜åº”å…ˆå®Œæˆè¯¾ç¨‹ 1ã€‚è¿™æ˜¯ä¸å¯èƒ½çš„ã€‚ æç¤ºï¼š è¾“å…¥çš„å…ˆå†³æ¡ä»¶æ˜¯ç”± è¾¹ç¼˜åˆ—è¡¨ è¡¨ç¤ºçš„å›¾å½¢ï¼Œè€Œä¸æ˜¯ é‚»æ¥çŸ©é˜µ ã€‚è¯¦æƒ…è¯·å‚è§å›¾çš„è¡¨ç¤ºæ³•ã€‚ ä½ å¯ä»¥å‡å®šè¾“å…¥çš„å…ˆå†³æ¡ä»¶ä¸­æ²¡æœ‰é‡å¤çš„è¾¹ã€‚ 1 &lt;= numCourses &lt;= 10^5 æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/course-scheduleè‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ Solution æ‹“æ‰‘æ’åº DFS åˆ¤æ–­æœ‰ç¯ Code æ‹“æ‰‘æ’åº12345678910111213141516171819202122232425262728293031323334353637 class Solution {public: bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) { int d[numCourses]; fill(d,d+numCourses,0); vector&lt;int&gt; v[numCourses]; int x,y; for(int i=0;i&lt;prerequisites.size();i++){ x = prerequisites[i][0], y = prerequisites[i][1]; d[y] ++; v[x].push_back(y); } int point = -1,k = numCourses,ds = 0; while(k &gt; 0){ point = -1; // æ‰¾åˆ° æ‹“æ‰‘æ’åºçš„èµ·ç‚¹ for(int i = 0;i&lt;numCourses;i++){ if(d[i] == 0){ point = i; d[i] = -1; ds ++; break; } } if(point == -1 &amp;&amp; k &gt; 1 ) return false; else if(point == -1) return true; // å»æ‰ é¡¶ç‚¹ point for(int i=0;i &lt; v[point].size();i++){ y = v[point][i]; d[y]--; } v[point].clear(); k--; } return ds == numCourses; }}; DFS åˆ¤æ–­æ˜¯å¦æœ‰ç¯ 123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: bool hasCycle(vector&lt;vector&lt;int&gt;&gt;&amp; v, int idx,vector&lt;int&gt;&amp; visited,vector&lt;int&gt;&amp; localvisited){ // ç¼“å­˜ if(visited[idx]) return false; localvisited[idx] = 1; visited[idx] = 1; for(int i = 0; i&lt; v[idx].size(); i++){ if(localvisited[v[idx][i]]) return true; else if(hasCycle(v,v[idx][i],visited,localvisited)) return true; } localvisited[idx] = 0; return false; } bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) { // æ‹“æ‰‘æ’åº // é‡‡ç”¨é‚»æ¥è¡¨è¡¨ç¤ºæœ‰å‘å›¾ vector&lt;vector&lt;int&gt;&gt; v; for(int i=0;i&lt;numCourses;i++){ v.push_back({}); } for(int i =0 ; i&lt;prerequisites.size(); i++){ v[prerequisites[i][0]].push_back(prerequisites[i][1]); } // æ˜¯å¦è®¿é—®è¿‡ vector&lt;int&gt; visited(numCourses,0); vector&lt;int&gt; localvisited(numCourses,0); for(int i=0;i&lt;numCourses;i++){ if(hasCycle(v,i,visited,localvisited)) return false; } return true; }}","link":"/2020/04/04/2020-04-04-207.-%E8%AF%BE%E7%A8%8B%E8%A1%A8/"},{"title":"é¢è¯•é¢˜ 04.01. èŠ‚ç‚¹é—´é€šè·¯","text":"èŠ‚ç‚¹é—´é€šè·¯ã€‚ç»™å®šæœ‰å‘å›¾ï¼Œè®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œæ‰¾å‡ºä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´æ˜¯å¦å­˜åœ¨ä¸€æ¡è·¯å¾„ã€‚ ç¤ºä¾‹1:12è¾“å…¥ï¼šn = 3, graph = [[0, 1], [0, 2], [1, 2], [1, 2]], start = 0, target = 2è¾“å‡ºï¼štrue ç¤ºä¾‹2: 12è¾“å…¥ï¼šn = 5, graph = [[0, 1], [0, 2], [0, 4], [0, 4], [0, 1], [1, 3], [1, 4], [1, 3], [2, 3], [3, 4]], start = 0, target = 4è¾“å‡º true æç¤ºï¼š èŠ‚ç‚¹æ•°é‡nåœ¨[0, 1e5]èŒƒå›´å†…ã€‚ èŠ‚ç‚¹ç¼–å·å¤§äºç­‰äº 0 å°äº nã€‚ å›¾ä¸­å¯èƒ½å­˜åœ¨è‡ªç¯å’Œå¹³è¡Œè¾¹ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/route-between-nodes-lcciè‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ Solution DFS BFS Code DFS12345678910111213141516171819202122232425262728293031class Solution {public: bool findWhetherExistsPath(int n, vector&lt;vector&lt;int&gt;&gt;&amp; graph, int start, int target) { vector&lt;int&gt; visited(n,0); vector&lt;int&gt; v[n]; for(int i=0;i&lt;graph.size();i++){ v[graph[i][0]].push_back(graph[i][1]); } stack&lt;int&gt; s; s.push(start); visited[start] = 1; int k, flag; while(!s.empty()){ k = s.top(); flag = 0; if(k == target) return true; for(int j=0;j&lt;v[k].size();j++){ if(visited[v[k][j]] == 0){ s.push(v[k][j]); flag = 1; visited[v[k][j]] = 1; break; } } if(!flag) s.pop(); } return false; }}; BFS12345678910111213141516171819202122232425262728class Solution {public: bool findWhetherExistsPath(int n, vector&lt;vector&lt;int&gt;&gt;&amp; graph, int start, int target) { vector&lt;int&gt; visited(n,0); vector&lt;int&gt; v[n]; for(int i=0;i&lt;graph.size();i++){ v[graph[i][0]].push_back(graph[i][1]); } queue&lt;int&gt; q; q.push(start); visited[start] = 1; int k; while(!q.empty()){ k = q.front(); if(k == target) return true; q.pop(); for(auto t : v[k]){ if(visited[t]==0){ visited[t] = 1; q.push(t); } } } return false; }};","link":"/2020/04/04/2020-04-04-%E9%9D%A2%E8%AF%95%E9%A2%98-04.01.-%E8%8A%82%E7%82%B9%E9%97%B4%E9%80%9A%E8%B7%AF/"},{"title":"322. é›¶é’±å…‘æ¢","text":"ç»™å®šä¸åŒé¢é¢çš„ç¡¬å¸ coins å’Œä¸€ä¸ªæ€»é‡‘é¢ amountã€‚ç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥è®¡ç®—å¯ä»¥å‡‘æˆæ€»é‡‘é¢æ‰€éœ€çš„æœ€å°‘çš„ç¡¬å¸ä¸ªæ•°ã€‚å¦‚æœæ²¡æœ‰ä»»ä½•ä¸€ç§ç¡¬å¸ç»„åˆèƒ½ç»„æˆæ€»é‡‘é¢ï¼Œè¿”å› -1ã€‚ ç¤ºä¾‹ 1:123è¾“å…¥: coins = [1, 2, 5], amount = 11è¾“å‡º: 3 è§£é‡Š: 11 = 5 + 5 + 1 ç¤ºä¾‹ 2:12è¾“å…¥: coins = [2], amount = 3è¾“å‡º: -1 è¯´æ˜:ä½ å¯ä»¥è®¤ä¸ºæ¯ç§ç¡¬å¸çš„æ•°é‡æ˜¯æ— é™çš„ã€‚ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/coin-changeè‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ SolutionåŠ¨æ€è§„åˆ’ Code123456789101112131415161718class Solution {public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { int dp[amount+1]; fill(dp,dp+amount+1,0); int c; for(int i=1;i&lt;=amount;i++){ c = -1; for(int j=0;j&lt;coins.size();j++){ if(i &gt;= coins[j]){ if((c==-1 || (c &gt; dp[i-coins[j]])) &amp;&amp; dp[i-coins[j]] &gt;= 0) c = dp[i-coins[j]]; } } dp[i] = c!=-1 ? c+1:-1; } return dp[amount] &gt;= 0 ?dp[amount]:-1; }};","link":"/2020/04/07/2020-04-07-322.-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"},{"title":"The world this week Politics","text":"Trump and America1. Trunmp mooted guidelines to reopen the economyDonald Trump said that America was past the peak of covid-19 outbreak, as he mooted guidelines to reopen the economy. However, when a journalist asked Mr Trump what he had done all February to prepare for covid, he called her â€œdisgracefulâ€; 2. The funding to the WHO will be suspendedAccusing it of pushing â€œChinaâ€™s misinformationâ€ on the coronavirus, Mr Trump said he would suspend American funding to the World Health Organisation. 3. Bernie Sanders bowed out the 2020 persidential compaignMr Bernie is endorsing Mr Biden now so they can unite the Democratic Party in trying the defeat Mr Trump in Novemberâ€™s election","link":"/2020/04/25/2020-04-25-The-world-this-week-Politics/"},{"title":"Is China Winning ?","text":"The geopolitical consequences of covid-19 will be long-lasting and unfortunate","link":"/2020/04/26/2020-04-26-Is-China-Winning-0/"},{"title":"æ¯æ—¥ä¸€é¢˜","text":"é«˜æ¸…å¤§å›¾","link":"/2020/04/30/2020-04-30-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"title":"åŠå­¦ç¯‡ç¬¬ä¸€","text":"è¿‘æ—¥ï¼Œæ— å­¦ä¹ ä¹‹åŠ¨åŠ›ï¼Œæ— å­¦ä¹ ä¹‹æ¯…åŠ›ï¼Œå“è€å­åç¯‡ä»¥è‡ªåŠ±ï¼Œæœ›å­¦ä¸å¯ä»¥å·² åŠå­¦ è€å­ å›å­æ›°ï¼šå­¦ä¸å¯ä»¥å·²ã€‚ é’ã€å–ä¹‹äºè“ï¼Œè€Œé’äºè“ï¼›å†°ã€æ°´ä¸ºä¹‹ï¼Œè€Œå¯’äºæ°´ã€‚æœ¨ç›´ä¸­ç»³ï¼Œè¼®ä»¥ä¸ºè½®ï¼Œå…¶æ›²ä¸­è§„ï¼Œè™½æœ‰æ§æš´ï¼Œä¸å¤æŒºè€…ï¼Œè¼®ä½¿ä¹‹ç„¶ä¹Ÿã€‚æ•…æœ¨å—ç»³åˆ™ç›´ï¼Œé‡‘å°±ç ºåˆ™åˆ©ï¼Œå›å­åšå­¦è€Œæ—¥å‚çœä¹å·±ï¼Œåˆ™çŸ¥æ˜è€Œè¡Œæ— è¿‡çŸ£ã€‚æ•…ä¸ç™»é«˜å±±ï¼Œä¸çŸ¥å¤©ä¹‹é«˜ä¹Ÿï¼›ä¸ä¸´æ·±æºªï¼Œä¸çŸ¥åœ°ä¹‹åšä¹Ÿï¼›ä¸é—»å…ˆç‹ä¹‹é—è¨€ï¼Œä¸çŸ¥å­¦é—®ä¹‹å¤§ä¹Ÿã€‚å¹²ã€è¶Šã€å¤·ã€è²‰ä¹‹å­ï¼Œç”Ÿè€ŒåŒå£°ï¼Œé•¿è€Œå¼‚ä¿—ï¼Œæ•™ä½¿ä¹‹ç„¶ä¹Ÿã€‚è¯—æ›°ï¼šâ€œå—Ÿå°”å›å­ï¼Œæ— æ’å®‰æ¯ã€‚é–å…±å°”ä½ï¼Œå¥½æ˜¯æ­£ç›´ã€‚ç¥ä¹‹å¬ä¹‹ï¼Œä»‹å°”æ™¯ç¦ã€‚â€ç¥è«å¤§äºåŒ–é“ï¼Œç¦è«é•¿äºæ— ç¥¸ã€‚ å¾å°ç»ˆæ—¥è€Œæ€çŸ£ï¼Œä¸å¦‚é¡»è‡¾ä¹‹æ‰€å­¦ä¹Ÿã€‚å¾å°è·‚è€Œæœ›çŸ£ï¼Œä¸å¦‚ç™»é«˜ä¹‹åšè§ä¹Ÿã€‚ç™»é«˜è€Œæ‹›ï¼Œè‡‚éåŠ é•¿ä¹Ÿï¼Œè€Œè§è€…è¿œï¼›é¡ºé£è€Œå‘¼ï¼Œå£°éåŠ ç–¾ä¹Ÿï¼Œè€Œé—»è€…å½°ã€‚å‡èˆ†é©¬è€…ï¼Œéåˆ©è¶³ä¹Ÿï¼Œè€Œè‡´åƒé‡Œï¼›å‡èˆŸæ¥«è€…ï¼Œéèƒ½æ°´ä¹Ÿï¼Œè€Œç»æ±Ÿæ²³ã€‚å›å­ç”Ÿéå¼‚ä¹Ÿï¼Œå–„å‡äºç‰©ä¹Ÿã€‚ å—æ–¹æœ‰é¸Ÿç„‰ï¼Œåæ›°è’™é¸ ï¼Œä»¥ç¾½ä¸ºå·¢ï¼Œè€Œç¼–ä¹‹ä»¥å‘ï¼Œç³»ä¹‹è‹‡è‹•ï¼Œé£è‡³è‹•æŠ˜ï¼Œåµç ´å­æ­»ã€‚å·¢éä¸å®Œä¹Ÿï¼Œæ‰€ç³»è€…ç„¶ä¹Ÿã€‚è¥¿æ–¹æœ‰æœ¨ç„‰ï¼Œåæ›°å°„å¹²ï¼ŒèŒé•¿å››å¯¸ï¼Œç”Ÿäºé«˜å±±ä¹‹ä¸Šï¼Œè€Œä¸´ç™¾ä»ä¹‹æ¸Šï¼Œæœ¨èŒéèƒ½é•¿ä¹Ÿï¼Œæ‰€ç«‹è€…ç„¶ä¹Ÿã€‚è“¬ç”Ÿéº»ä¸­ï¼Œä¸æ‰¶è€Œç›´ï¼›ç™½æ²™åœ¨æ¶…ï¼Œä¸ä¹‹ä¿±é»‘ã€‚å…°æ§ä¹‹æ ¹æ˜¯ä¸ºèŠ·ï¼Œå…¶æ¸ä¹‹æ»«ï¼Œå›å­ä¸è¿‘ï¼Œåº¶äººä¸æœã€‚å…¶è´¨éä¸ç¾ä¹Ÿï¼Œæ‰€æ¸è€…ç„¶ä¹Ÿã€‚æ•…å›å­å±…å¿…æ‹©ä¹¡ï¼Œæ¸¸å¿…å°±å£«ï¼Œæ‰€ä»¥é˜²é‚ªè¾Ÿè€Œè¿‘ä¸­æ­£ä¹Ÿã€‚ ç‰©ç±»ä¹‹èµ·ï¼Œå¿…æœ‰æ‰€å§‹ã€‚è£è¾±ä¹‹æ¥ï¼Œå¿…è±¡å…¶å¾·ã€‚è‚‰è…å‡ºè™«ï¼Œé±¼æ¯ç”Ÿè ¹ã€‚æ€ æ…¢å¿˜èº«ï¼Œç¥¸ç¾ä¹ƒä½œã€‚å¼ºè‡ªå–æŸ±ï¼ŒæŸ”è‡ªå–æŸã€‚é‚ªç§½åœ¨èº«ï¼Œæ€¨ä¹‹æ‰€æ„ã€‚æ–½è–ªè‹¥ä¸€ï¼Œç«å°±ç‡¥ä¹Ÿï¼Œå¹³åœ°è‹¥ä¸€ï¼Œæ°´å°±æ¹¿ä¹Ÿã€‚è‰æœ¨ç•´ç”Ÿï¼Œç¦½å…½ç¾¤ç„‰ï¼Œç‰©å„ä»å…¶ç±»ä¹Ÿã€‚æ˜¯æ•…è´¨çš„å¼ ï¼Œè€Œå¼“çŸ¢è‡³ç„‰ï¼›æ—æœ¨èŒ‚ï¼Œè€Œæ–§æ–¤è‡³ç„‰ï¼›æ ‘æˆè«ï¼Œè€Œä¼—é¸Ÿæ¯ç„‰ã€‚é†¯é…¸ï¼Œè€Œèš‹èšç„‰ã€‚æ•…è¨€æœ‰æ‹›ç¥¸ä¹Ÿï¼Œè¡Œæœ‰æ‹›è¾±ä¹Ÿï¼Œå›å­æ…å…¶æ‰€ç«‹ä¹ï¼ ç§¯åœŸæˆå±±ï¼Œé£é›¨å…´ç„‰ï¼›ç§¯æ°´æˆæ¸Šï¼Œè›Ÿé¾™ç”Ÿç„‰ï¼›ç§¯å–„æˆå¾·ï¼Œè€Œç¥æ˜è‡ªå¾—ï¼Œåœ£å¿ƒå¤‡ç„‰ã€‚æ•…ä¸ç§¯è¹æ­¥ï¼Œæ— ä»¥è‡´åƒé‡Œï¼›ä¸ç§¯å°æµï¼Œæ— ä»¥æˆæ±Ÿæµ·ã€‚éªéª¥ä¸€è·ƒï¼Œä¸èƒ½åæ­¥ï¼›é©½é©¬åé©¾ï¼ŒåŠŸåœ¨ä¸èˆã€‚é”²è€Œèˆä¹‹ï¼Œæœ½æœ¨ä¸æŠ˜ï¼›é”²è€Œä¸èˆï¼Œé‡‘çŸ³å¯é•‚ã€‚è¾æ— çˆªç‰™ä¹‹åˆ©ï¼Œç­‹éª¨ä¹‹å¼ºï¼Œä¸Šé£ŸåŸƒåœŸï¼Œä¸‹é¥®é»„æ³‰ï¼Œç”¨å¿ƒä¸€ä¹Ÿã€‚èŸ¹å…«è·ªè€ŒäºŒè¯ï¼Œéè›‡èŸºä¹‹ç©´ï¼Œæ— å¯å¯„æ‰˜è€…ï¼Œç”¨å¿ƒèºä¹Ÿã€‚æ˜¯æ•…æ— å†¥å†¥ä¹‹å¿—è€…ï¼Œæ— æ˜­æ˜­ä¹‹æ˜ï¼›æ— æƒ›æƒ›ä¹‹äº‹è€…ï¼Œæ— èµ«èµ«ä¹‹åŠŸã€‚è¡Œè¡¢é“è€…ä¸è‡³ï¼Œäº‹ä¸¤å›è€…ä¸å®¹ã€‚ç›®ä¸èƒ½ä¸¤è§†è€Œæ˜ï¼Œè€³ä¸èƒ½ä¸¤å¬è€Œèªã€‚è£è›‡æ— è¶³è€Œé£ï¼Œæ¢§é¼ äº”æŠ€è€Œç©·ã€‚è¯—æ›°ï¼šâ€œå°¸é¸ åœ¨æ¡‘ï¼Œå…¶å­ä¸ƒå…®ã€‚æ·‘äººå›å­ï¼Œå…¶ä»ªä¸€å…®ã€‚å…¶ä»ªä¸€å…®ï¼Œå¿ƒå¦‚ç»“å…®ã€‚â€æ•…å›å­ç»“äºä¸€ä¹Ÿã€‚ æ˜”è€…ç“ å·´é¼“ç‘Ÿï¼Œè€Œæµé±¼å‡ºå¬ï¼›ä¼¯ç‰™é¼“ç´ï¼Œè€Œå…­é©¬ä»°ç§£ã€‚æ•…å£°æ— å°è€Œä¸é—»ï¼Œè¡Œæ— éšè€Œä¸å½¢ã€‚ç‰åœ¨å±±è€Œè‰æœ¨æ¶¦ï¼Œæ¸Šç”Ÿç è€Œå´–ä¸æ¯ã€‚ä¸ºå–„ä¸ç§¯é‚ªï¼Œå®‰æœ‰ä¸é—»è€…ä¹ï¼ å­¦æ¶ä¹å§‹ï¼Ÿæ¶ä¹ç»ˆï¼Ÿæ›°ï¼šå…¶æ•°åˆ™å§‹ä¹è¯µç»ï¼Œç»ˆä¹è¯»ç¤¼ï¼›å…¶ä¹‰åˆ™å§‹ä¹ä¸ºå£«ï¼Œç»ˆä¹ä¸ºåœ£äººã€‚çœŸç§¯åŠ›ä¹…åˆ™å…¥ã€‚å­¦è‡³ä¹æ²¡è€Œåæ­¢ä¹Ÿã€‚æ•…å­¦æ•°æœ‰ç»ˆï¼Œè‹¥å…¶ä¹‰åˆ™ä¸å¯é¡»è‡¾èˆä¹Ÿã€‚ä¸ºä¹‹äººä¹Ÿï¼Œèˆä¹‹ç¦½å…½ä¹Ÿã€‚æ•…ä¹¦è€…ã€æ”¿äº‹ä¹‹çºªä¹Ÿï¼›è¯—è€…ã€ä¸­å£°ä¹‹æ‰€æ­¢ä¹Ÿï¼›ç¤¼è€…ã€æ³•ä¹‹å¤§å…®ï¼Œç±»ä¹‹çº²çºªä¹Ÿã€‚æ•…å­¦è‡³ä¹ç¤¼è€Œæ­¢çŸ£ã€‚å¤«æ˜¯ä¹‹è°“é“å¾·ä¹‹æã€‚ç¤¼ä¹‹æ•¬æ–‡ä¹Ÿï¼Œä¹ä¹‹ä¸­å’Œä¹Ÿï¼Œè¯—ä¹¦ä¹‹åšä¹Ÿï¼Œæ˜¥ç§‹ä¹‹å¾®ä¹Ÿï¼Œåœ¨å¤©åœ°ä¹‹é—´è€…æ¯•çŸ£ã€‚ å›å­ä¹‹å­¦ä¹Ÿï¼Œå…¥ä¹è€³ï¼Œç€ä¹å¿ƒï¼Œå¸ƒä¹å››ä½“ï¼Œå½¢ä¹åŠ¨é™ã€‚ç«¯è€Œè¨€ï¼Œè¡è€ŒåŠ¨ï¼Œä¸€å¯ä»¥ä¸ºæ³•åˆ™ã€‚å°äººä¹‹å­¦ä¹Ÿï¼Œå…¥ä¹è€³ï¼Œå‡ºä¹å£ï¼›å£è€³ä¹‹é—´ï¼Œåˆ™å››å¯¸è€³ï¼Œæ›·è¶³ä»¥ç¾ä¸ƒå°ºä¹‹èº¯å“‰ï¼å¤ä¹‹å­¦è€…ä¸ºå·±ï¼Œä»Šä¹‹å­¦è€…ä¸ºäººã€‚å›å­ä¹‹å­¦ä¹Ÿï¼Œä»¥ç¾å…¶èº«ï¼›å°äººä¹‹å­¦ä¹Ÿï¼Œä»¥ä¸ºç¦½çŠŠã€‚æ•…ä¸é—®è€Œå‘Šè°“ä¹‹å‚²ï¼Œé—®ä¸€è€Œå‘ŠäºŒè°“ä¹‹å›‹ã€‚å‚²ã€éä¹Ÿï¼Œå›‹ã€éä¹Ÿï¼›å›å­å¦‚å‘çŸ£ã€‚ å­¦è«ä¾¿ä¹è¿‘å…¶äººã€‚ç¤¼ä¹æ³•è€Œä¸è¯´ï¼Œè¯—ä¹¦æ•…è€Œä¸åˆ‡ï¼Œæ˜¥ç§‹çº¦è€Œä¸é€Ÿã€‚æ–¹å…¶äººä¹‹ä¹ å›å­ä¹‹è¯´ï¼Œåˆ™å°Šä»¥éçŸ£ï¼Œå‘¨äºä¸–çŸ£ã€‚æ•…æ›°ï¼šå­¦è«ä¾¿ä¹è¿‘å…¶äººã€‚ å­¦ä¹‹ç»è«é€Ÿä¹å¥½å…¶äººï¼Œéš†ç¤¼æ¬¡ä¹‹ã€‚ä¸Šä¸èƒ½å¥½å…¶äººï¼Œä¸‹ä¸èƒ½éš†ç¤¼ï¼Œå®‰ç‰¹å°†å­¦æ‚è¯†å¿—ï¼Œé¡ºè¯—ä¹¦è€Œå·²è€³ã€‚åˆ™æœ«ä¸–ç©·å¹´ï¼Œä¸å…ä¸ºé™‹å„’è€Œå·²ã€‚å°†åŸå…ˆç‹ï¼Œæœ¬ä»ä¹‰ï¼Œåˆ™ç¤¼æ­£å…¶ç»çº¬è¹Šå¾„ä¹Ÿã€‚è‹¥æŒˆè£˜é¢†ï¼Œè¯äº”æŒ‡è€Œé¡¿ä¹‹ï¼Œé¡ºè€…ä¸å¯èƒœæ•°ä¹Ÿã€‚ä¸é“ç¤¼å®ªï¼Œä»¥è¯—ä¹¦ä¸ºä¹‹ï¼Œè­¬ä¹‹çŠ¹ä»¥æŒ‡æµ‹æ²³ä¹Ÿï¼Œä»¥æˆˆèˆ‚é»ä¹Ÿï¼Œä»¥é”¥é¤å£¶ä¹Ÿï¼Œä¸å¯ä»¥å¾—ä¹‹çŸ£ã€‚æ•…éš†ç¤¼ï¼Œè™½æœªæ˜ï¼Œæ³•å£«ä¹Ÿï¼›ä¸éš†ç¤¼ï¼Œè™½å¯Ÿè¾©ï¼Œæ•£å„’ä¹Ÿã€‚ é—®æ¥›è€…ï¼Œå‹¿å‘Šä¹Ÿï¼›å‘Šæ¥›è€…ï¼Œå‹¿é—®ä¹Ÿï¼›è¯´æ¥›è€…ï¼Œå‹¿å¬ä¹Ÿã€‚æœ‰äº‰æ°”è€…ï¼Œå‹¿ä¸è¾©ä¹Ÿã€‚æ•…å¿…ç”±å…¶é“è‡³ï¼Œç„¶åæ¥ä¹‹ï¼›éå…¶é“åˆ™é¿ä¹‹ã€‚æ•…ç¤¼æ­ï¼Œè€Œåå¯ä¸è¨€é“ä¹‹æ–¹ï¼›è¾é¡ºï¼Œè€Œåå¯ä¸è¨€é“ä¹‹ç†ï¼›è‰²ä»è€Œåå¯ä¸è¨€é“ä¹‹è‡´ã€‚æ•…æœªå¯ä¸è¨€è€Œè¨€ï¼Œè°“ä¹‹å‚²ï¼›å¯ä¸è¨€è€Œä¸è¨€ï¼Œè°“ä¹‹éšï¼›ä¸è§‚æ°”è‰²è€Œè¨€ï¼Œè°“ç½ã€‚æ•…å›å­ä¸å‚²ã€ä¸éšã€ä¸ç½ï¼Œè°¨é¡ºå…¶èº«ã€‚è¯—æ›°ï¼šâ€œåŒªäº¤åŒªèˆ’ï¼Œå¤©å­æ‰€äºˆã€‚â€æ­¤ä¹‹è°“ä¹Ÿã€‚ ç™¾å‘å¤±ä¸€ï¼Œä¸è¶³è°“å–„å°„ï¼›åƒé‡Œè¹æ­¥ä¸è‡³ï¼Œä¸è¶³è°“å–„å¾¡ï¼›ä¼¦ç±»ä¸é€šï¼Œä»ä¹‰ä¸ä¸€ï¼Œä¸è¶³è°“å–„å­¦ã€‚å­¦ä¹Ÿè€…ï¼Œå›ºå­¦ä¸€ä¹‹ä¹Ÿã€‚ä¸€å‡ºç„‰ï¼Œä¸€å…¥ç„‰ï¼Œæ¶‚å··ä¹‹äººä¹Ÿï¼›å…¶å–„è€…å°‘ï¼Œä¸å–„è€…å¤šï¼Œæ¡€çº£ç›—è·–ä¹Ÿï¼›å…¨ä¹‹å°½ä¹‹ï¼Œç„¶åå­¦è€…ä¹Ÿã€‚ å›å­çŸ¥å¤«ä¸å…¨ä¸ç²¹ä¹‹ä¸è¶³ä»¥ä¸ºç¾ä¹Ÿï¼Œæ•…è¯µæ•°ä»¥è´¯ä¹‹ï¼Œæ€ç´¢ä»¥é€šä¹‹ï¼Œä¸ºå…¶äººä»¥å¤„ä¹‹ï¼Œé™¤å…¶å®³è€…ä»¥æŒå…»ä¹‹ã€‚ä½¿ç›®éæ˜¯æ— æ¬²è§ä¹Ÿï¼Œä½¿å£éæ˜¯æ— æ¬²è¨€ä¹Ÿï¼Œä½¿å¿ƒéæ˜¯æ— æ¬²è™‘ä¹Ÿã€‚åŠè‡³å…¶è‡´å¥½ä¹‹ä¹Ÿï¼Œç›®å¥½ä¹‹äº”è‰²ï¼Œè€³å¥½ä¹‹äº”å£°ï¼Œå£å¥½ä¹‹äº”å‘³ï¼Œå¿ƒåˆ©ä¹‹æœ‰å¤©ä¸‹ã€‚æ˜¯æ•…æƒåˆ©ä¸èƒ½å€¾ä¹Ÿï¼Œç¾¤ä¼—ä¸èƒ½ç§»ä¹Ÿï¼Œå¤©ä¸‹ä¸èƒ½è¡ä¹Ÿã€‚ç”Ÿä¹ç”±æ˜¯ï¼Œæ­»ä¹ç”±æ˜¯ï¼Œå¤«æ˜¯ä¹‹è°“å¾·æ“ã€‚å¾·æ“ç„¶åèƒ½å®šï¼Œèƒ½å®šç„¶åèƒ½åº”ã€‚èƒ½å®šèƒ½åº”ï¼Œå¤«æ˜¯ä¹‹è°“æˆäººã€‚å¤©è§å…¶æ˜ï¼Œåœ°è§å…¶å…‰ï¼Œå›å­è´µå…¶å…¨ä¹Ÿã€‚","link":"/2020/05/01/2020-05-01-%E5%8A%9D%E5%AD%A6%E7%AF%87%E7%AC%AC%E4%B8%80/"},{"title":"1092 To Buy or Not to Buy (20åˆ†)","text":"Eva would like to make a string of beads with her favorite colors so she went to a small shop to buy some beads. There were many colorful strings of beads. However the owner of the shop would only sell the strings in whole pieces. Hence Eva must check whether a string in the shop contains all the beads she needs. She now comes to you for help: if the answer is Yes, please tell her the number of extra beads she has to buy; or if the answer is No, please tell her the number of beads missing from the string. For the sake of simplicity, letâ€™s use the characters in the ranges [0-9], [a-z], and [A-Z] to represent the colors. For example, the 3rd string in Figure 1 is the one that Eva would like to make. Then the 1st string is okay since it contains all the necessary beads with 8 extra ones; yet the 2nd one is not since there is no black bead and one less red bead. Figure 1 Input Specification:Each input file contains one test case. Each case gives in two lines the strings of no more than 1000 beads which belong to the shop owner and Eva, respectively. Output Specification:For each test case, print your answer in one line. If the answer is Yes, then also output the number of extra beads Eva has to buy; or if the answer is No, then also output the number of beads missing from the string. There must be exactly 1 space between the answer and the number. Sample Input 1:12ppRYYGrrYBR2258YrR8RrY Sample Output 1:1Yes 8 Sample Input 2:12ppRYYGrrYB225YrR8RrY Sample Output 2:1No 2 Solutioné¢˜ç›®æ¯”è¾ƒç®€å•ï¼Œåªè¦åˆ†åˆ«ç»Ÿè®¡å„å­—ç¬¦çš„æ•°é‡ï¼Œç„¶ååˆ¤æ–­æ˜¯å¦ç¬¦åˆéœ€æ±‚å³å¯ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;map&lt;char,int&gt; getCount(string s1){ map&lt;char,int&gt; count; for(char c : s1){ count[c]++; } return count;}void pat_1092(){ string s1,s2; cin &gt;&gt; s1 &gt;&gt; s2; map&lt;char,int&gt; count1 = getCount(s1); map&lt;char,int&gt; count2 = getCount(s2); int res = 0; for(auto &amp;p : count2){ if(count1[p.first] &lt; p.second){ res += (p.second - count1[p.first]); } } if(res &gt; 0) printf(&quot;No %d\\n&quot;,res); else printf(&quot;Yes %d\\n&quot;,(int)(s1.size() - s2.size()));; }int main(){ pat_1092(); return 0;}","link":"/2020/05/02/2020-05-02-1092-To-Buy-or-Not-to-Buy-(20%E5%88%86)/"},{"title":"1316. ä¸åŒçš„å¾ªç¯å­å­—ç¬¦ä¸²","text":"ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² text ï¼Œè¯·ä½ è¿”å›æ»¡è¶³ä¸‹è¿°æ¡ä»¶çš„ ä¸åŒ éç©ºå­å­—ç¬¦ä¸²çš„æ•°ç›®ï¼š å¯ä»¥å†™æˆæŸä¸ªå­—ç¬¦ä¸²ä¸å…¶è‡ªèº«ç›¸è¿æ¥çš„å½¢å¼ï¼ˆå³ï¼Œå¯ä»¥å†™ä¸º a + aï¼Œå…¶ä¸­ a æ˜¯æŸä¸ªå­—ç¬¦ä¸²ï¼‰ã€‚ä¾‹å¦‚ï¼Œabcabc å°±æ˜¯ abc å’Œå®ƒè‡ªèº«è¿æ¥å½¢æˆçš„ã€‚ ç¤ºä¾‹ 1ï¼š123è¾“å…¥ï¼štext = &quot;abcabcabc&quot;è¾“å‡ºï¼š3è§£é‡Šï¼š3 ä¸ªå­å­—ç¬¦ä¸²åˆ†åˆ«ä¸º &quot;abcabc&quot;ï¼Œ&quot;bcabca&quot; å’Œ &quot;cabcab&quot; ã€‚ ç¤ºä¾‹ 2ï¼š 123è¾“å…¥ï¼štext = &quot;leetcodeleetcode&quot;è¾“å‡ºï¼š2è§£é‡Šï¼š2 ä¸ªå­å­—ç¬¦ä¸²ä¸º &quot;ee&quot; å’Œ &quot;leetcodeleetcode&quot; ã€‚ æç¤ºï¼š 1 &lt;= text.length &lt;= 2000 text åªåŒ…å«å°å†™è‹±æ–‡å­—æ¯ã€‚ Solution æš´åŠ›(å¤æ‚åº¦ O(n^3) è¶…æ—¶) æš´åŠ›æšä¸¾æ‰€æœ‰å­—ä¸²ï¼Œç„¶åæ ¸å¯¹æ˜¯å¦ç¬¦åˆæ¡ä»¶ï¼Œä½¿ç”¨ hash è¡¨æ¥æ’é‡ 1234567891011121314151617181920212223242526class Solution {public: string check(string a){ int n = a.size(); if(n % 2 !=0 ) return &quot;&quot;; else return a.substr(0,n/2) == a.substr(n/2,n/2) ? a : &quot;&quot;; } int distinctEchoSubstrings(string text) { int n= text.size(); int ans = 0; string res; map&lt;string,bool&gt; maps; for(int i=0;i&lt;n;i++){ for(int j=i+1;j&lt;n;j++){ res = check(text.substr(i,j-i+1)); if(res.size() &gt; 0 &amp;&amp; !maps[res]){ maps[res] = true; ans ++; } } } return ans; }}; ç”±äºå­—ç¬¦ä¸²çš„æ¯”è¾ƒæœ€åæ˜¯ O(N) å› æ­¤æ—¶é—´å¤æ‚åº¦è¿‡é«˜ï¼Œå¯¼è‡´ ac å¤±è´¥ æš´åŠ›ä¼˜åŒ– ï¼ˆO(n^2) 1234567891011121314151617181920212223242526272829303132333435363738394041using LL = long long;class Solution {private: constexpr static int mod = (int)1e9 + 7; public: int gethash(const vector&lt;int&gt;&amp; pre, const vector&lt;int&gt;&amp; mul, int l, int r) { return (pre[r + 1] - (LL)pre[l] * mul[r - l + 1] % mod + mod) % mod; } int distinctEchoSubstrings(string text) { int n = text.size(); int base = 31; vector&lt;int&gt; pre(n + 1), mul(n + 1); pre[0] = 0; mul[0] = 1; for (int i = 1; i &lt;= n; ++i) { pre[i] = ((LL)pre[i - 1] * base + text[i - 1]) % mod; mul[i] = (LL)mul[i - 1] * base % mod; } unordered_set&lt;int&gt; seen[n]; int ans = 0; for (int i = 0; i &lt; n; ++i) { for (int j = i + 1; j &lt; n; ++j) { int l = j - i; if (j + l &lt;= n) { int hash_left = gethash(pre, mul, i, j - 1); if (!seen[l - 1].count(hash_left) &amp;&amp; hash_left == gethash(pre, mul, j, j + l - 1)) { ++ans; seen[l - 1].insert(hash_left); } } } } return ans; }};","link":"/2020/05/05/2020-05-05-1316.-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"ä¸€é“èƒŒåŒ…é—®é¢˜çš„å˜ç§","text":"é¢˜ç›®æè¿°ä¸€ä¸ªæ•°ç»„ä¸­æœ‰è‹¥å¹²æ­£æ•´æ•°ï¼Œå°†æ­¤æ•°ç»„åˆ’åˆ†ä¸ºä¸¤ä¸ªå­æ•°ç»„ï¼Œä½¿å¾—ä¸¤ä¸ªå­æ•°ç»„å„å…ƒç´ ä¹‹å’Œa,bçš„å·®æœ€å°ï¼Œå¯¹äºéæ³•è¾“å…¥åº”è¯¥è¾“å‡ºERRORã€‚ è¾“å…¥æè¿°:æ•°ç»„ä¸­çš„å…ƒç´  è¾“å‡ºæè¿°:é™åºè¾“å‡ºä¸¤ä¸ªå­æ•°ç»„çš„å…ƒç´ å’Œ ç¤ºä¾‹1è¾“å…¥ 1210 20 30 10 1010 20 abc 10 10 è¾“å‡º 1240 40ERROR Solutioné“¾æ¥ï¼šhttps://www.nowcoder.com/questionTerminal/aea0458d54d74f3ca14012cbdf249918?f=discussionæ¥æºï¼šç‰›å®¢ç½‘ èƒŒåŒ…é—®é¢˜ æœ‰ a + b = sum; a &gt;= b;åˆ™ b &lt;= sum/2 å› æ­¤å¯ä»¥è½¬åŒ–ä¸º é—®é¢˜å¯¹äºç»™å®šçš„åºåˆ— nums, èƒ½å¤Ÿæ„æˆ 1â€”-sum/2 é—®é¢˜ ç„¶åå–å¾—æœ€å¤§çš„èƒ½å¤Ÿæ„æˆçš„ b å³å¯ å°±æ˜¯ä¸çŸ¥é“è¾“å…¥ä¸ºå•¥ğŸ‘¨â€ğŸ«å‡ºé”™ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std; // dp 0-1 èƒŒåŒ…é—®é¢˜void package(vector&lt;int&gt; &amp;nums){ int n = nums.size() , sum = 0; for(int num : nums) sum += num; int target = sum/2; // ä¸èƒ½é‡å¤æ—¶ vector&lt;bool&gt; dp(target + 1, 0); dp[0] = true; for(int num : nums){ for(int i = target; i &gt;= num ; i--){ dp[i] = dp[i] || dp[i-num]; } } int b = 0; for(int i= target; i &gt;= 0; i--){ if(dp[i]) {b = i; break;} } printf(&quot;%d %d\\n&quot;,b,sum-b);} int main(){ string str ; while (getline(cin,str)) { bool ok = true; for (int i = 0; i &lt; str.size(); i++) { if (str[i] != ' ' &amp;&amp; !(str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9')) { ok = false; break; } } if (!ok) { cout &lt;&lt; &quot;ERROR&quot; &lt;&lt; endl; continue; } vector&lt;int&gt; nums; int prev = 0; for (int i = 0; i &lt; str.size(); i++) { char c = str[i]; if (c == ' ' ) { nums.push_back(stoi(str.substr(prev,i-prev))); prev = i + 1; } } nums.push_back(stoi(str.substr(prev,str.size()-prev))); package(nums); } return 0;","link":"/2020/05/06/2020-05-06-%E4%B8%80%E9%81%93%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%98%E7%A7%8D/"},{"title":"677. é”®å€¼æ˜ å°„","text":"å®ç°ä¸€ä¸ª MapSum ç±»é‡Œçš„ä¸¤ä¸ªæ–¹æ³•ï¼Œinsert å’Œ sumã€‚ å¯¹äºæ–¹æ³• insertï¼Œä½ å°†å¾—åˆ°ä¸€å¯¹ï¼ˆå­—ç¬¦ä¸²ï¼Œæ•´æ•°ï¼‰çš„é”®å€¼å¯¹ã€‚å­—ç¬¦ä¸²è¡¨ç¤ºé”®ï¼Œæ•´æ•°è¡¨ç¤ºå€¼ã€‚å¦‚æœé”®å·²ç»å­˜åœ¨ï¼Œé‚£ä¹ˆåŸæ¥çš„é”®å€¼å¯¹å°†è¢«æ›¿ä»£æˆæ–°çš„é”®å€¼å¯¹ã€‚ å¯¹äºæ–¹æ³• sumï¼Œä½ å°†å¾—åˆ°ä¸€ä¸ªè¡¨ç¤ºå‰ç¼€çš„å­—ç¬¦ä¸²ï¼Œä½ éœ€è¦è¿”å›æ‰€æœ‰ä»¥è¯¥å‰ç¼€å¼€å¤´çš„é”®çš„å€¼çš„æ€»å’Œã€‚ ç¤ºä¾‹ 1:1234è¾“å…¥: insert(&quot;apple&quot;, 3), è¾“å‡º: Nullè¾“å…¥: sum(&quot;ap&quot;), è¾“å‡º: 3è¾“å…¥: insert(&quot;app&quot;, 2), è¾“å‡º: Nullè¾“å…¥: sum(&quot;ap&quot;), è¾“å‡º: 5 æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/map-sum-pairsè‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ Solutionå­—å…¸æ ‘ç»“æ„ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//å­—å…¸æ ‘èŠ‚ç‚¹class Node{ public: char data; int val; bool leaf; map&lt;char,Node&gt; next; Node(char c){ data = c; leaf = false; } Node(){};};class MapSum {public: Node root; /** Initialize your data structure here. */ MapSum() { root = Node(); } void insert(string key, int val) { Node *trie = &amp;root; int i =0,n = key.size(); char c; while(i &lt; n){ c = key[i]; if(!trie-&gt;next.count(c)){ trie-&gt;next[c] = Node(c); } trie = &amp;trie-&gt;next[c]; i++; } trie-&gt;val = val; trie-&gt;leaf = true; } // é€’å½’æ±‚å’Œ int trave(Node *trie){ int ans = 0; if(trie-&gt;leaf) {ans += trie-&gt;val;} for(auto &amp;p:trie-&gt;next){ Node *t = &amp;(p.second); ans += trave(t); } return ans; } int sum(string prefix) { Node *trie = &amp;root; int ans = 0; int i =0, n = prefix.size(); char c; while( i &lt; n){ c = prefix[i]; if(!trie-&gt;next.count(c)) return 0; trie = &amp;trie-&gt;next[c]; i++; } return trave(trie); }};/** * Your MapSum object will be instantiated and called as such: * MapSum* obj = new MapSum(); * obj-&gt;insert(key,val); * int param_2 = obj-&gt;sum(prefix); */","link":"/2020/05/07/2020-05-07-677.-%E9%94%AE%E5%80%BC%E6%98%A0%E5%B0%84/"},{"title":"51. Nçš‡å","text":"n çš‡åé—®é¢˜ç ”ç©¶çš„æ˜¯å¦‚ä½•å°† n ä¸ªçš‡åæ”¾ç½®åœ¨ nÃ—n çš„æ£‹ç›˜ä¸Šï¼Œå¹¶ä¸”ä½¿çš‡åå½¼æ­¤ä¹‹é—´ä¸èƒ½ç›¸äº’æ”»å‡»ã€‚ ä¸Šå›¾ä¸º 8 çš‡åé—®é¢˜çš„ä¸€ç§è§£æ³•ã€‚ ç»™å®šä¸€ä¸ªæ•´æ•° nï¼Œè¿”å›æ‰€æœ‰ä¸åŒçš„ n çš‡åé—®é¢˜çš„è§£å†³æ–¹æ¡ˆã€‚ æ¯ä¸€ç§è§£æ³•åŒ…å«ä¸€ä¸ªæ˜ç¡®çš„ n çš‡åé—®é¢˜çš„æ£‹å­æ”¾ç½®æ–¹æ¡ˆï¼Œè¯¥æ–¹æ¡ˆä¸­ â€˜Qâ€™ å’Œ â€˜.â€™ åˆ†åˆ«ä»£è¡¨äº†çš‡åå’Œç©ºä½ã€‚ ç¤ºä¾‹:è¾“å…¥: 4 1234567891011è¾“å‡º: [ [&quot;.Q..&quot;, // è§£æ³• 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // è§£æ³• 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]] è§£é‡Š: 4 çš‡åé—®é¢˜å­˜åœ¨ä¸¤ä¸ªä¸åŒçš„è§£æ³•ã€‚ æç¤ºï¼š çš‡åï¼Œæ˜¯å›½é™…è±¡æ£‹ä¸­çš„æ£‹å­ï¼Œæ„å‘³ç€å›½ç‹çš„å¦»å­ã€‚çš‡ååªåšä¸€ä»¶äº‹ï¼Œé‚£å°±æ˜¯â€œåƒå­â€ã€‚å½“å¥¹é‡è§å¯ä»¥åƒçš„æ£‹å­æ—¶ï¼Œå°±è¿…é€Ÿå†²ä¸Šå»åƒæ‰æ£‹å­ã€‚å½“ç„¶ï¼Œå¥¹æ¨ªã€ç«–ã€æ–œéƒ½å¯èµ°ä¸€æˆ–ä¸ƒæ­¥ï¼Œå¯è¿›å¯é€€ã€‚ï¼ˆå¼•ç”¨è‡ª ç™¾åº¦ç™¾ç§‘ - çš‡å ï¼‰ æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/n-queensè‘—ä½œæƒå½’é¢†æ‰£ç½‘ç»œæ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»å®˜æ–¹æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚ Solutionæš´åŠ›æšä¸¾ï¼Œé¦–å…ˆ å¯¹äº n*n çš„ n çš‡åé—®é¢˜ï¼Œè‚¯å®šä¸ä¼šå‡ºç°åŒä¸€åˆ—å’ŒåŒä¸€è¡Œå­˜åœ¨ä¸¤ä¸ªæ£‹å­çš„æœºä¼šï¼Œå› æ­¤ æ¯ä¸ªæ£‹å­è‚¯å®šä¸ºç‹¬å ä¸€è¡Œæˆ–è€…ä¸€åˆ—ã€‚å¯ä»¥ä¸€è¡Œä¸€è¡Œçš„è¿›è¡Œå¡«å……ï¼ŒçŸ¥é“ä¸ä¼šå‡ºç°å†²çªï¼Œå…¶æ—¶é—´å¤æ‚åº¦ä¸º O(n!) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution {public: vector&lt;vector&lt;string&gt;&gt; ans; void traceback(vector&lt;string&gt; &amp;checked,int x,int n){ if( x == n ) { ans.push_back(checked); return; } for(int i=0;i&lt;n;i++){ if(!check(checked,n,x,i)){ continue; } checked[x][i] = 'Q'; traceback(checked,x+1,n); checked[x][i] = '.'; } } bool check(vector&lt;string&gt; &amp;checked,int n,int x, int y){ // æ ¸æŸ¥å…¶ä½œç”¨åŸŸä¸Šæ˜¯å¦æœ‰æ£‹å­ï¼Œæœ‰çš„è¯å°±è¿”å›false for(int i=0;i&lt;n;i++){ // çºµå‘ if(checked[i][y] == 'Q') return false; } // æ–œçº¿ ã€ã€ã€ for(int i=x-1,j=y-1;i&gt;=0 &amp;&amp; j &gt;=0;i--,j--){ if(checked[i][j] == 'Q') return false; } // æ–œçº¿ ã€ã€ã€ for(int i=x-1,j=y+1;i&gt;=0 &amp;&amp; j &lt; n;i--,j++){ if(checked[i][j] == 'Q') return false; } return true; } vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) { // -1ç©º 0 ä»£è¡¨ä¸èƒ½æ”¾ç½® 1 ä»£è¡¨å·²ç»æ”¾ç½®çš„ vector&lt;string&gt; checked(n,string(n,'.')); traceback(checked,0,n); return ans; }};","link":"/2020/05/08/2020-05-08-51.-N%E7%9A%87%E5%90%8E/"},{"title":"Next Step","text":"è€ƒç ”ç»“æŸï¼ŒåŸºæœ¬è¾¾åˆ°é¢„æœŸç›®æ ‡å§ï¼Œæ¥ä¸‹æ¥å‡†å¤‡å¼€å§‹æ–°ä¸€æ­¥çš„è§„åˆ’ï¼š çŸ©é˜µåˆ†æ æœ€å€¼ä¼˜åŒ–ï¼ˆå‡¸ä¼˜åŒ–ï¼‰ æœºå™¨å­¦ä¹  è‹±è¯­ lcåˆ·åˆ°80% moreâ€¦","link":"/2020/05/18/2020-05-18-Next-Step/"},{"title":"Theory behind GAN","text":"GenerationTarget: find data distribution $$P_{data}(x)$$.x æ˜¯ä¸€ä¸ªå›¾ç‰‡ ( a high-dimensional vector) Before GANTargetï¼šä½¿ç”¨ä¸€ä¸ªåˆ†å¸ƒ $P_G(x,\\theta)$ å»æ‹Ÿåˆåˆ†å¸ƒ$P_{data}(x)$ï¼ˆå›ºå®šçš„ï¼‰ï¼Œä½¿ä¸¤è€…è¶Šæ¥è¿‘è¶Šå¥½. ä¾‹å¦‚$P_G(x,\\theta)$å¯ä»¥æ˜¯ gaussian mixture model,æ­¤æ—¶ $\\theta$ä¸º means and variances of this model Given a data distribution $P_{data}(x)$ (We can sample from it) $P_{data}(x)$ æœªçŸ¥ï¼Œä½†æ˜¯å¯ä»¥ sample from it. (å°±æ˜¯ä»å·²æœ‰çš„databaseä¸­sampleå‡ºæ¥ä¸€äº›) We have a data distribution $P_G(x;\\theta)$ parameterized by $\\theta$ We want to find $\\theta$ such that $P_G$ close to $P_{data}$ Sample {$x^1,x^2â€¦,x^m$} from $P_{data}(x)$ and compute $P_G(x^i;\\theta)$ Find $\\theta^*$ maximizing the Object Function Object Functionï¼šMaximum Likelihood Estimation (æœ€å¤§ä¼¼ç„¶ä¼°è®¡) $$\\begin{aligned}F(\\theta) &amp;= \\prod_{x=1}^{m} P_G(x^i;\\theta)\\tag{1}\\end{aligned}$$ è¦ä½¿ $F(\\theta)$ è¾¾åˆ°æœ€å¤§ï¼Œå³æ±‚ $\\theta^*$ ä½¿$F(\\theta)$å–å¾—æœ€å€¼ $$\\begin{aligned} \\theta^* &amp;= \\arg\\mathop{\\max}\\limits_{\\theta}F(\\theta) \\tag{2} \\ &amp;= \\arg\\mathop{\\max}\\limits_{\\theta}\\sum_{x=1}^mlog(P_G(x^i;\\theta)) \\ &amp;\\approx \\color{red}\\arg\\mathop{\\max}\\limits_{\\theta}E_x\\sim_{P_{data}(x)}(log(P_G(x;\\theta)))\\ &amp;= \\color{red}\\arg\\mathop{\\max}\\limits_{\\theta} (\\int_x P_{data}(x)log(P_G(x;\\theta))dx - \\int_x P_{data}(x)log(P_{data}(x))dx) \\ &amp;= \\arg\\mathop{\\max}\\limits_{\\theta}\\int_xP_{data}(x)log(P_G(x;\\theta)/P_{data}(x))dx \\ &amp;= \\arg\\mathop{\\min}\\limits_{\\theta} KL Div(P_{data}||P_G) \\end{aligned}$$ å³ï¼š Maximum Likelihood Estimation $\\approx$ KL Divergence å› æ­¤ å¯¹äº Generator çš„ç›®çš„å°±æ˜¯ $G^* = \\arg\\mathop{\\min}\\limits_{G}Div(P_G,P_{data})$,å³ä½¿ $P_G å’Œ P_{data}$ ä¹‹é—´çš„æ•£åº¦æœ€å°ã€‚ è¿™é‡Œå­˜åœ¨ä¸€ä¸ªé—®é¢˜: How to define general $P_G(x)$ ? å¯¹äº $P_G(x)$åˆ†å¸ƒ(æ›´åŠ  general distribution),å®ƒå¯èƒ½æ— æ³•è¿›è¡Œè®¡ç®—(å¦‚ Nerual Network),å³ $logP_G(x;\\theta)$æ— æ³•è®¡ç®—. Using GANGAN æ˜¯å¦‚ä½•å¤„ç†è¿™ä¸ªé—®é¢˜çš„å‘¢ï¼Ÿ (Generator)GAN é‡‡ç”¨äº†ä¸€ä¸ª NN æ¥æ‹Ÿåˆ $P_G(x)$ï¼Œå³ Generator æ˜¯ä¸€ä¸ª network, ä½¿ç”¨å®ƒæ¥å®šä¹‰åˆ†å¸ƒ $P_G$ To learn the generatorâ€™s distribution $P_G$,we define a prior on input noise variables $P_z(z)$, then represent a mapping to data space as $G(z;\\theta_g)$,where G is a differentiable function represented by a multilayer perceptron with parameters $\\theta_g$. prior distribution $P_z(z) ä¸€èˆ¬å¯ä»¥é€‰å–ä»»æ„åˆ†å¸ƒï¼Œå¦‚ Gussian Mixture Distribution$ æ ¹æ®ä¸Šé¢å¯çŸ¥ï¼Œå®ƒçš„ Object Function (loss) æ˜¯æŸç§ Divergence, å³ $Div(P_G,P_{data})$,è€Œä¸”ç›®çš„ä¸ºæ˜¯è¿™ç§æ•£åº¦æœ€å°ï¼Œå³ $G^* = \\arg\\mathop{\\min}\\limits_G Div({P_G,P_{data}})$.å…³é”®å°±æ˜¯å¦‚ä½•è®¡ç®—è¿™ç§ Divergenceï¼Ÿ How to Compute Divergence (Discriminator) ?å¯¹äº $P_G$æˆ–è€…$P_{data}$ å› ä¸ºæ˜¯æœªçŸ¥çš„ï¼Œæˆ‘ä»¬æ— æ³•è®¡ç®—ï¼Œä½†æ˜¯å¯ä»¥ Sample from them. We alse define a second multilayer perceptron $D(x;\\theta_d)$ that outputs a single scalar. D(x) represents the probability that x came from the data rather that $P_g$. We train D to maximize the probability of assigning the correct label to both training examples and samples from G. Object Function For DWhen train D, Gis fixed: $$\\begin{aligned} V(G,D) &amp;= E_x \\sim_{P_{data}(x)}[log(D(x))] + E_z \\sim_{P_z(z)}[log(1-D(G(z)))] \\ &amp; = E_x \\sim_{P_{data}(x)}[log(D(x))] + E_x \\sim_{P_G(x)}[log(1-D(x))] \\tag{3} \\end{aligned} $$ å³ $$D^* = \\arg\\mathop{\\max}\\limits_DV(D,G) \\tag{4}$$ å¼(3)å¦‚ä½•è§£é‡Šå‘¢ï¼Ÿ å½“ x ä» $P_data(x)$ sample å‡ºæ¥çš„æ—¶ï¼Œé‚£å°±ä½¿ scalar(D(x)) è¶Šå¤§è¶Šå¥½ï¼ˆå› ä¸ºå®ƒæ˜¯çœŸå®çš„ï¼‰ å½“ x ä» $P_G(x)$ sample å‡ºæ¥æ—¶ï¼Œsaclar(D(x))è¶Šå°è¶Šå¥½ï¼Œå³1-D(x) è¶Šå¤§è¶Šå¥½ï¼ˆå› ä¸ºå®ƒæ˜¯Generatorå‡ºæ¥çš„çš„ï¼‰ ä¸Šé¢æˆ‘ä»¬è®²åˆ°ï¼Œgeneratorçš„ç›®çš„ä½¿ $P_G$ å’Œ $P_{data}$ çš„æŸç§ Divergence è¶Šå°è¶Šå¥½,å…¶å®å¯¹äºå¼(3)å®ƒå°±ç­‰åŒäºæŸç§ Divergence è¯æ˜ V(G,D) ç­‰åŒäº JS-Divergence fixed G, æ±‚è§£ $D^*$$$ \\begin{aligned} D^* &amp;= \\arg\\mathop{\\max}\\limits_DV(D,G) \\ &amp;= \\arg\\mathop{\\max}\\limits_D[\\int_xP_{data}(x)log(D(x))dx + \\int_xP_G(x)log(1-D(x))dx ]\\\\ &amp;= \\arg\\mathop{\\max}\\limits_D\\int_x[P_{data}(x)log(D(x)) + P_G(x)log(1-D(x))]dx \\tag{5} \\end{aligned}$$ Given x, $D^*$ä½¿ $P_{data}(x)log(D(x)) + P_G(x)log(1-D(x))$ maximumç®€åŒ–ä¸º $L(D) = alogD + blog(1-D)$ Assumed: $a = P_{data}(x)$ and $b = P_G(x)$ $$\\begin{aligned} &amp;L(D) = alogD + blog(1-D) \\ &amp;\\frac{dL(D)}{dD} = a/D + b/(1-D)(-1) = 0\\ &amp; D^ = a/(a+b) \\tag{6} \\end{aligned}$$ For any (a,b) $\\in R^2$, function $y\\to alog(y) + blog(1-y)$ achieves its maximum in [0,1] at $\\frac{a}{a+b}$ å°† $D^* = a/(a+b)$ å¸¦å…¥åˆ°å¼ï¼ˆ3ï¼‰ä¸­ï¼Œæœ‰: $$\\begin{aligned} V(G,D) &amp;= E_x \\sim_{P_{data}(x)}[log(\\frac{P_{data}(x)}{(P_{data}(x)+P_G(x))})] + E_x \\sim_{P_G(x)}[log(\\frac{P_G(x)}{(P_{data}(x)+P_G(x))})] \\ &amp;= \\int_x[P_{data}(x)log(\\frac{P_{data}(x)}{(P_{data}(x)+P_G(x))}) + P_G(x)log(\\frac{P_G(x)}{(P_{data}(x)+P_G(x))})]dx \\ &amp;= \\int_x[P_{data}(x)log(\\frac{P_{data}(x)/2}{(P_{data}(x)+P_G(x))/2}) + P_G(x)log(\\frac{P_G(x)/2}{(P_{data}(x)+P_G(x))/2})]dx \\ &amp;= -\\int_x[P_{data}(x)log2 + P_G(x)log2]dx + \\int_x[P_{data}(x)log(\\frac{P_{data}(x)}{(P_{data}(x)+P_G(x))/2}) + P_G(x)log(\\frac{P_G(x)}{(P_{data}(x)+P_G(x))/2})]dx \\ &amp;= -log4 + KLDiv(P_{data}(x)||(P_{data}(x)+P_G(x))/2) + KLDiv(P_G(x)||(P_{data}(x)+P_G(x))/2) \\ &amp;= -log4 + 2*\\color{red}JSDiv(P_{data}||P_G)\\end{aligned}$$ è®¡ç®— $G^* = \\mathop{\\arg\\min}\\limits_GDiv(P_{data},P_G)$ä¸Šå¼å°±ç­‰åŒäº: $$\\begin{aligned} G^* &amp;= \\arg\\mathop{\\min}\\limits_GDiv(P_{data},P_G) \\ &amp;= \\arg\\mathop{\\min}\\limits_G\\mathop{\\max}\\limits_DV(G,D) \\ &amp;= \\arg\\mathop{\\min}\\limits_GC(G) \\end{aligned}$$ å…¶ä¸­ $C(G)= \\arg\\mathop{\\max}\\limits_DV(G,D)$ Algorithm Initialize generator and discriminator In each training iteration: Fix G, update D Fix D, update G Procersså®é™…ä¸Šï¼š $$\\begin{aligned} V(G,D) &amp;= E_x \\sim_{P_{data}(x)}[log(D(x))] + E_x \\sim_{P_G(x)}[log(1-D(x))] \\ &amp;\\approx \\frac{1}{m}\\sum_{i=1}^{m}logD(x^i) + \\frac{1}{m}\\sum_{i=1}^{m}log(1-D(\\hat{x}^i)) \\end{aligned}$$ initialize $\\theta_d$ for D and $\\theta_g$ for G In each training iteration Training D, repeat K times sample m examples{$x^1,x^2,â€¦x^m$} from database $P_{data}(x)$ sample m examples{$z^1,z^2,â€¦z^m$} from prior distribution $P_z(z)$ get generated data {$\\hat{x}^1,\\hat{x}^2,â€¦\\hat{x}^m$} via $G(z^i)$ fixed $\\theta_g$,update $\\theta_d$ to maximize:$$\\begin{aligned} \\hat{V} &amp;= \\frac{1}{m}\\sum_{i=1}^{m}logD(x^i) + \\frac{1}{m}\\sum_{i=1}^{m}log(1-D(\\hat{x}^i)) \\ \\theta_d &amp;\\gets \\theta_d + \\eta\\bigtriangledown\\hat{V}(\\theta_d)\\end{aligned}$$ Training G, only once sample m examples{$z^1,z^2,â€¦z^m$} from prior distribution $P_z(z)$ fixed $\\theta_d$,update $\\theta_g$ to minimize:$$\\begin{aligned} \\hat{V} &amp;= \\frac{1}{m}\\sum_{i=1}^{m}logD(x^i) + \\frac{1}{m}\\sum_{i=1}^{m}log(1-D(G(z^i))) \\ &amp;\\approx\\frac{1}{m}\\sum_{i=1}^{m}log(1-D(G(z^i))) \\ \\theta_g &amp;\\gets \\theta_g - \\eta\\bigtriangledown\\hat{V}(\\theta_g)\\end{aligned}$$ å®é™…ä¸Šï¼Œåœ¨ Training G æ—¶ï¼Œé‡‡ç”¨çš„æ˜¯ï¼š $$\\begin{aligned} \\hat{V} &amp;= -\\frac{1}{m}\\sum_{i=1}^{m}log(D(G(z^i))) \\ \\theta_g &amp;\\gets \\theta_g - \\eta\\bigtriangledown\\hat{V}(\\theta_g)\\end{aligned}$$","link":"/2020/06/15/2020-06-15-Theory-behind-GAN/"},{"title":"pascals-triangle","text":"åŠ›æ‰£ æ€è·¯ ğŸ’¥æ¯ä¸€è¡Œçš„ç¬¬ä¸€ä¸ªå…ƒç´ å’Œæœ€åä¸€ä¸ªå…ƒç´ å‡ä¸º1ï¼Œä¸­é—´å…ƒç´ æœ‰ï¼š å‡è®¾ä¸Šä¸€è¡Œå…ƒç´ ä¸º prev æ•°ç»„ï¼Œ æœ¬è¡Œä¸º nextæ•°ç»„ï¼Œ åˆ™æœ‰ï¼š $$next[i] = prev[i-1] + prev[i]$$ åˆ™ï¼Œä½¿ç”¨è¯¥é€’æ¨å…¬å¼å³å¯ã€‚ Code ğŸ˜123456789101112131415161718192021class Solution {public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) { vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; prev = {1}, next; ans.push_back(prev); int i = 2; while(i &lt;= numRows){ // é‡æ–°åˆå§‹åŒ–ï¼Œæ‰©å……å…ƒç´  next.resize(i,1); for(int j = 1; j &lt; i -1; j++){ next[j] = prev[j-1] + prev[j]; } prev = next; ans.push_back(next); i++; } return ans; }}; å¤æ‚åº¦åˆ†æ ğŸ¥‡ æ—¶é—´å¤æ‚åº¦ ç©ºé—´å¤æ‚åº¦ O(N^2) O(N)","link":"/2022/02/19/pascals-triangle/"}],"tags":[{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"algorithms","slug":"algorithms","link":"/tags/algorithms/"},{"name":"ç¨‹åºå‘˜é¢è¯•å®å…¸","slug":"ç¨‹åºå‘˜é¢è¯•å®å…¸","link":"/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"},{"name":"sort","slug":"sort","link":"/tags/sort/"},{"name":"usage","slug":"usage","link":"/tags/usage/"},{"name":"hpc","slug":"hpc","link":"/tags/hpc/"},{"name":"parallel computers","slug":"parallel-computers","link":"/tags/parallel-computers/"},{"name":"introduction","slug":"introduction","link":"/tags/introduction/"},{"name":"machine learning","slug":"machine-learning","link":"/tags/machine-learning/"},{"name":"classification","slug":"classification","link":"/tags/classification/"},{"name":"probability","slug":"probability","link":"/tags/probability/"},{"name":"deep learning","slug":"deep-learning","link":"/tags/deep-learning/"},{"name":"perceptron","slug":"perceptron","link":"/tags/perceptron/"},{"name":"regression","slug":"regression","link":"/tags/regression/"},{"name":"linear regression","slug":"linear-regression","link":"/tags/linear-regression/"},{"name":"æœ€ä¼˜åŒ–ç†è®º","slug":"æœ€ä¼˜åŒ–ç†è®º","link":"/tags/%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA/"},{"name":"SVM","slug":"SVM","link":"/tags/SVM/"},{"name":"å¹¶æŸ¥é›†","slug":"å¹¶æŸ¥é›†","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"pat","slug":"pat","link":"/tags/pat/"},{"name":"graph","slug":"graph","link":"/tags/graph/"},{"name":"dynamic","slug":"dynamic","link":"/tags/dynamic/"},{"name":"dynamic-programming","slug":"dynamic-programming","link":"/tags/dynamic-programming/"},{"name":"tree","slug":"tree","link":"/tags/tree/"},{"name":"datastructure","slug":"datastructure","link":"/tags/datastructure/"},{"name":"æ„Ÿæ‚Ÿ","slug":"æ„Ÿæ‚Ÿ","link":"/tags/%E6%84%9F%E6%82%9F/"},{"name":"è¯»ä¹¦","slug":"è¯»ä¹¦","link":"/tags/%E8%AF%BB%E4%B9%A6/"},{"name":"ç§‘å¹»","slug":"ç§‘å¹»","link":"/tags/%E7%A7%91%E5%B9%BB/"},{"name":"ç”Ÿæ´»","slug":"ç”Ÿæ´»","link":"/tags/%E7%94%9F%E6%B4%BB/"},{"name":"ml","slug":"ml","link":"/tags/ml/"},{"name":"math","slug":"math","link":"/tags/math/"},{"name":"å­¦ä¹ ","slug":"å­¦ä¹ ","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"dfs","slug":"dfs","link":"/tags/dfs/"},{"name":"ä¸€åˆ·leetcode","slug":"ä¸€åˆ·leetcode","link":"/tags/%E4%B8%80%E5%88%B7leetcode/"},{"name":"bfs","slug":"bfs","link":"/tags/bfs/"},{"name":"The Economist APRIL 18THâ€“24TH 2020","slug":"The-Economist-APRIL-18THâ€“24TH-2020","link":"/tags/The-Economist-APRIL-18TH%E2%80%9324TH-2020/"},{"name":"newcode","slug":"newcode","link":"/tags/newcode/"},{"name":"machine-learning","slug":"machine-learning","link":"/tags/machine-learning/"},{"name":"gan","slug":"gan","link":"/tags/gan/"},{"name":"æå®æ¯…","slug":"æå®æ¯…","link":"/tags/%E6%9D%8E%E5%AE%8F%E6%AF%85/"},{"name":"deep-learning","slug":"deep-learning","link":"/tags/deep-learning/"},{"name":"DP","slug":"DP","link":"/tags/DP/"}],"categories":[{"name":"Daily Check","slug":"Daily-Check","link":"/categories/Daily-Check/"},{"name":"è¯´æ˜ä¹¦","slug":"è¯´æ˜ä¹¦","link":"/categories/%E8%AF%B4%E6%98%8E%E4%B9%A6/"},{"name":"parallel computers","slug":"parallel-computers","link":"/categories/parallel-computers/"},{"name":"machine learning","slug":"machine-learning","link":"/categories/machine-learning/"},{"name":"deep learning","slug":"machine-learning/deep-learning","link":"/categories/machine-learning/deep-learning/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Generative Adversial Network","slug":"Generative-Adversial-Network","link":"/categories/Generative-Adversial-Network/"},{"name":"PAT","slug":"PAT","link":"/categories/PAT/"},{"name":"è¯»ä¹¦","slug":"è¯»ä¹¦","link":"/categories/%E8%AF%BB%E4%B9%A6/"},{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"}]}