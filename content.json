{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"about","text":"","link":"/2021/07/06/about/"},{"title":"find-majority-element-lcci","text":"数组中占比超过一半的元素称之为主要元素。给你一个 整数 数组，找出其中的主要元素。若没有，返回 -1 。请设计时间复杂度为 O(N) 、空间复杂度为 O(1) 的解决方案。 示例 1： 12输入：[1,2,5,9,5,9,5,5,5]输出：5 示例 2： 输入：[3,2]输出：-1 示例 3： 12输入：[2,2,1,1,1,2,2]输出：2 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-majority-element-lcci著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 核心思想假设存在元素a的数量超过一半,则将所有不同的元素相互抵消，剩余的那一个肯定是a.如： 12[2,2,1,1,1,2,2]-&gt; [2] 当不存在这样的元素时，也可能最后剩余的元素不符合条件，这时候就需要统计剩余元素的个数，然后判断是否超过总数的一半即可。如： 12[1,2,3]-&gt; [3] Code123456789101112131415161718192021222324class Solution {public: int majorityElement(vector&lt;int&gt;&amp; nums) { int num = nums[0], count = 1, n = nums.size(); for(int i =1; i&lt;n; i++){ if(count == 0){ num = nums[i]; count = 1; }else{ if(nums[i] != num){ count --; }else count++; } } if(count == 0) return -1; else{ count = 0; for(int nu: nums){ if(nu == num) count++; } return count*2 &gt;= n ? num:-1; } }};","link":"/2021/07/09/find-majority-element-lcci/"},{"title":"group-anagrams-lcci [计数统计]","text":"编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。 注意：本题相对原题稍作修改 示例: 123456789输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],输出:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/group-anagrams-lcci著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解由于只有小写字母，只需要申请一个长度为26的数组统计每一个字符串的字母数量即可（类似于hashcode的构造思想）。这样所有的变位词可以映射到相同的数组，使用map，将数组（或者转为字符串）作为key，value 即是对应的字符数组。 Code12345678910111213141516171819202122232425262728293031class Solution {public: string hashcode(vector&lt;int&gt; chs){ string ans = &quot;&quot;; for(int ch: chs){ ans.append(to_string(ch) + &quot;_&quot;); } return ans; } vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) { // hash 编码 // eat tea tan ate nat bat unordered_map&lt;string,vector&lt;string&gt;&gt; containers; for(string str: strs){ vector&lt;int&gt; counts(26,0); for(char c: str){ counts[c-'a'] ++; } containers[hashcode(counts)].emplace_back(str); } vector&lt;vector&lt;string&gt;&gt; res; for(auto &amp;p: containers){ res.push_back(p.second); } return res; }};","link":"/2021/07/18/group-anagrams-lcci/"},{"title":"minimize-maximum-pair-sum-in-array","text":"一个数对 (a,b) 的 数对和 等于 a + b 。最大数对和 是一个数对数组中最大的 数对和 。 比方说，如果我们有数对 (1,5) ，(2,3) 和 (4,4)，最大数对和 为 max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8 。给你一个长度为 偶数 n 的数组 nums ，请你将 nums 中的元素分成 n / 2 个数对，使得： nums 中每个元素 恰好 在 一个 数对中，且最大数对和 的值 最小 。请你在最优数对划分的方案下，返回最小的 最大数对和 。 示例 1： 12345输入：nums = [3,5,2,3]输出：7解释：数组中的元素可以分为数对 (3,3) 和 (5,2) 。最大数对和为 max(3+3, 5+2) = max(6, 7) = 7 。 示例 2： 12345输入：nums = [3,5,4,2,4,6]输出：8解释：数组中的元素可以分为数对 (3,5)，(4,4) 和 (6,2) 。最大数对和为 max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8 。 提示： n == nums.length2 &lt;= n &lt;= 105n 是 偶数 。1 &lt;= nums[i] &lt;= 105 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 Solution贪心算法，假设序列 [a1,a2,a3,a4,a5,a6],且 a1 &lt;= a2 &lt;= a3 &lt;= .. &lt;= a6, 则必有最小的 最大数对和只能是(a1,a6),(a2,a5),(a3,a4)数对之和的最大值。 证明简单证明一下，假设存在四个数 a &lt; b &lt; c &lt; d, 则符合条件的数为 max(a+d,b+c)。反证法: 若 d 不与 a搭配,与其它任意搭配，都存在结果为 d + ?. Code12345678910111213class Solution {public: int minPairSum(vector&lt;int&gt;&amp; nums) { sort(nums.begin(),nums.end()); int ans = 0, n = nums.size() - 1, i = 0; while(i &lt; n){ ans = max(ans,nums[i]+nums[n]); i++; n--; } return ans; }};","link":"/2021/07/20/minimize-maximum-pair-sum-in-array/"},{"title":"template","text":"常见的一些latex、hexo bug 或者其它的使用说明书. 1. latexlatex syntax 1.1 行内样式 inline synatx$\\hat{x}_{k}=\\hat{x}_{k}^{-}+K_{t}\\left(y_{k}\\right)$ 1.2 equation \\begin{align} & \\arg\\min_{w,b} \\frac{1}{2m}\\sum_{i=1}^m (\\hat{y_i} - y_i)^2 \\\\ & s.t \\quad \\hat{y_i}(w^x_i + b) >= 0\\\\ \\end{align} 1.3 矩阵 $$\\begin{bmatrix} {a_{11}}&{a_{12}}&{\\cdots}&{a_{1n}}\\\\ {a_{21}}&{a_{22}}&{\\cdots}&{a_{2n}}\\\\ {\\vdots}&{\\vdots}&{\\ddots}&{\\vdots}\\\\ {a_{m1}}&{a_{m2}}&{\\cdots}&{a_{mn}}\\\\ \\end{bmatrix}$$ 1.4 分母$$P(A_i \\mid B) = \\frac{P(B\\mid A)P(A_i)}{\\sum_{j=1}^{n}P(A_j)P(B \\mid A_j)}$$ 1.5 常见的希腊字符 希腊字符 latex 大写 latex｜ $\\alpha$ \\alpha $\\lambda$ \\lambda $\\Lambda$ \\Lambda $\\delta$ \\delta $\\Delta$ \\Delta $\\beta$ \\beta $\\sigma$ \\sigma $\\Sigma$ \\Sigma $\\theta$ \\theta $\\Theta$ \\Theta $\\epsilon$ \\epsilon To be continue","link":"/2021/07/06/template/"},{"title":"time-based-key-value-store","text":"创建一个基于时间的键值存储类 TimeMap，它支持下面两个操作： set(string key, string value, int timestamp) 存储键 key、值 value，以及给定的时间戳 timestamp。 get(string key, int timestamp) 返回先前调用 set(key, value, timestamp_prev) 所存储的值，其中 timestamp_prev &lt;= timestamp。如果有多个这样的值，则返回对应最大的 timestamp_prev 的那个值。如果没有值，则返回空字符串（””）。 示例 1：12345678910输入：inputs = [&quot;TimeMap&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;], inputs = [[],[&quot;foo&quot;,&quot;bar&quot;,1],[&quot;foo&quot;,1],[&quot;foo&quot;,3],[&quot;foo&quot;,&quot;bar2&quot;,4],[&quot;foo&quot;,4],[&quot;foo&quot;,5]]输出：[null,null,&quot;bar&quot;,&quot;bar&quot;,null,&quot;bar2&quot;,&quot;bar2&quot;]解释： TimeMap kv; kv.set(&quot;foo&quot;, &quot;bar&quot;, 1); // 存储键 &quot;foo&quot; 和值 &quot;bar&quot; 以及时间戳 timestamp = 1 kv.get(&quot;foo&quot;, 1); // 输出 &quot;bar&quot; kv.get(&quot;foo&quot;, 3); // 输出 &quot;bar&quot; 因为在时间戳 3 和时间戳 2 处没有对应 &quot;foo&quot; 的值，所以唯一的值位于时间戳 1 处（即 &quot;bar&quot;） kv.set(&quot;foo&quot;, &quot;bar2&quot;, 4); kv.get(&quot;foo&quot;, 4); // 输出 &quot;bar2&quot; kv.get(&quot;foo&quot;, 5); // 输出 &quot;bar2&quot; 示例 2：12输入：inputs = [&quot;TimeMap&quot;,&quot;set&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;,&quot;get&quot;,&quot;get&quot;,&quot;get&quot;], inputs = [[],[&quot;love&quot;,&quot;high&quot;,10],[&quot;love&quot;,&quot;low&quot;,20],[&quot;love&quot;,5],[&quot;love&quot;,10],[&quot;love&quot;,15],[&quot;love&quot;,20],[&quot;love&quot;,25]]输出：[null,null,null,&quot;&quot;,&quot;high&quot;,&quot;high&quot;,&quot;low&quot;,&quot;low&quot;] 提示： 所有的键/值字符串都是小写的。 所有的键/值字符串长度都在 [1, 100] 范围内。 所有 TimeMap.set 操作中的时间戳 timestamps 都是严格递增的。 1 &lt;= timestamp &lt;= 10^7 TimeMap.set 和 TimeMap.get 函数在每个测试用例中将（组合）调用总计 120000 次。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/time-based-key-value-store著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 Code123456789101112131415161718192021222324252627282930313233class TimeMap {public: using P = pair&lt;int,string&gt;; unordered_map&lt;string,vector&lt;P&gt;&gt; container; /** Initialize your data structure here. */ TimeMap() { // unordered_map&lt;string,priority_queue&lt;Point&gt;&gt; container; } void set(string key, string value, int timestamp) { container[key].emplace_back(P(timestamp,value)); } string get(string key, int timestamp) { auto &amp;pairs = container[key]; auto it = upper_bound(pairs.begin(),pairs.end(),P(timestamp,string({127}))); if(it != pairs.begin()){ return (it -1)-&gt;second; } return &quot;&quot;; }};/** * Your TimeMap object will be instantiated and called as such: * TimeMap* obj = new TimeMap(); * obj-&gt;set(key,value,timestamp); * string param_2 = obj-&gt;get(key,timestamp); */ More Info1. Pair&lt;int,string&gt;2. Vector&lt;Pair&lt;int,string&gt;&gt;","link":"/2021/07/10/time-based-key-value-store/"}],"tags":[{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"algorithms","slug":"algorithms","link":"/tags/algorithms/"},{"name":"程序员面试宝典","slug":"程序员面试宝典","link":"/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"},{"name":"sort","slug":"sort","link":"/tags/sort/"},{"name":"usage","slug":"usage","link":"/tags/usage/"}],"categories":[{"name":"Daily Check","slug":"Daily-Check","link":"/categories/Daily-Check/"},{"name":"说明书","slug":"说明书","link":"/categories/%E8%AF%B4%E6%98%8E%E4%B9%A6/"}]}